      program driver
c
c=======================================================================
c
c     This is the main driver for the Modular Ocean Model (MOM). The  
c     structure allows for surface boundary conditions (SBC) to
c     come from a dataset or an atmospheric model. Integration time
c     is divided into a number of equal time segments and SBC are held 
c     fixed for each time segment. When coupling to an atmospheric
c     model, SBC are supplied each time segment (the coupling period)
c     and held fixed for that period. When supplying SBC to MOM from a
c     dataset, the length of each time segment is one ocean time step.
c     
c     author:        r. c. pacanowski      e-mail=> rcp@gfdl.gov
c                    a. rosati             e-mail=>  ar@gfdl.gov
c=======================================================================
c
c====================== include file "param.h" =========================
c
c     main parameter file which sets ocean characteristics:
c
c     "size.h" sets model size "imt", "jmt", and "km"
c
c====================== include file "size.h" ==========================
c                                                                       
c-----------------------------------------------------------------------
c     USER INPUT: 
c-----------------------------------------------------------------------
c
c     imt    = number of grid points in the longitudinal direction
c              (calculated points are from 2 through imt-1. End points
c               are boundaries)          
c
c     jmt    = number of grid points (latitude rows) in the latitudinal
c              direction (calculated points are from 2 through jmt-1.           
c              End points are boundaries)   
c                                
c     km     = number of grid points in the vertical direction          
c              (calculated points are from 1 through km)
c
c     nt     = number of tracers (temperature, salinity, ...)
c
c     mnisle = maximum number of islands (unconnected land masses)
c
c     maxipp = maximum number of all island perimeter points
c-----------------------------------------------------------------------
c                                                                       
      parameter (imt=  92, jmt=  61, km= 15)
      parameter (nt=2)
      parameter (nat=2)
      parameter (mnisle=50, maxipp=5000)
c

c






c
c-----------------------------------------------------------------------
c     END USER INPUT
c-----------------------------------------------------------------------
c                                                                       
c-----------------------------------------------------------------------
c     By default, the MW (memory window) is 2nd order except for the
c     following options which require a 4th order MW 
c
c     for 2nd order schemes, the minimum sized MW is 3 latitude rows
c     for 4th order schemes, the minimum sized MW is 4 latitude rows
c                            (5 if using coarse_grained_parallelism)
c-----------------------------------------------------------------------
c













c
c-----------------------------------------------------------------------
c     set MW (memory window) size "jmw" 
c-----------------------------------------------------------------------
c                                                                       

c
c     for UNI-TASKING: "jmw" is set to the minimum for each option class 
c     "jmw" may be increased up to "jmt" 
c

      parameter (jmw=jmt)


c
c-----------------------------------------------------------------------
c     set first and last calculated row within the MW. other rows
c     are used as buffers
c-----------------------------------------------------------------------
c
c     jsmw   = 1st calculated row within the MW     
c     jemw   = last calculated row within the MW
c
      parameter (jsmw=2, jemw=jmw-1)
c
c
c     jextra = extra buffer rows needed for coarse_grained_parallelism.
c              "jextra" rows are added to the top and bottom of the MW
c              so the MW size increases by 2*jextra       
c

          parameter (jextra = 0)




c
c     nvar   = number of prognostic variables
c     lseg   = maximum number of longitudinal stream function segments
c     nlatpr = maximum number of latitudes for matrix printouts
c              on diagnostic time steps
c     nhreg  = number of regions in the horizontal used for averaging
c              tracers.
c     nvreg  = number of regions in the vertical used for term balance
c              calculations. note "nvreg" isn`t used for tracer averages
c     numreg = total number of regions ( = product of nhreg & nvreg)
c              used for term balance calculations
c
      parameter (lseg=5, nlatpr=10)

      parameter (nhreg=5, nvreg=2, numreg=nhreg*nvreg)

      parameter (nvar=nt+2)
c

c
      parameter (imtm1=imt-1, kmm1=km-1)                                
      parameter (imtp1=imt+1, imtm2=imt-2
     &,          jmtp1=jmt+1, jmtm1=jmt-1, jmtm2=jmt-2

     &,          jscan=jmtm2

     &,          kmp1=km+1, kmp2=km+2
     &,          imtkm=imt*km, nwds=imt*jmt, nkflds=2
     &,          nslab=imt*nvar*km, ntmin2=nt+1/nt)
c
c     include parameter constants
c
c====================== include file "pconst.h" ========================
c
c
c     rules for parameter constants
c
c     use prefix of "c" for whole real numbers (eg: c57 for 57.0)
c     use "m" after prefix to designate negative values (minus sign)
c       (eg: cm7 for -7.0)
c     use prefix of "p" for non repeating fractions (eg: p5 for 0.5)
c     use prefix of "r" for reciprocals (eg: r3 for 1/3.0)
c     combine use of prefix above and "e" for scientific notation, with
c       (eg: c5e4 for 5.0e4, c1em10 for 1.0e-10)
c
      parameter (c0=0.0, c1=1.0, c2=2.0, c3=3.0, c4=4.0, c5=5.0, c7=7.0)
      parameter (c8=8.0)
      parameter (c14=14.0, c16=16.0, c360=360.0)
      parameter (p125=0.125, p25=0.25, p5=0.5, p75=0.75)
      parameter (epsln=1.0e-20)
c
      parameter (c24=24.0, c60=60.0, c1440=1440.0)
      parameter (r24=c1/c24, r60=c1/c60, r1440=c1/c1440)
      parameter (secday=c1/(c60*c1440))
c
c     include standard I/O units
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c
c     ncrows = number of calculated rows within the MW.
c              (the remaining rows are buffer rows). 
c


      parameter (ncrows = jmw - 2)


c====================== include file "atm.h" ===========================
c
c     arrays for the energy-moisture balance model
c
c     note: units for heat flux are in g/cm**2/s**3/cm**2 or (mW/m**2)
c           units for fresh water flux are in cm/s
c           downward is into the surface (ocean, ice or land)
c           upward is into the bottom of the atmosphere
c           outward is out of the top of the atmosphere
c           inward is into the top of the atmosphere
c
c     outlwr(imt,jmt)	 = outgoing atmosphere longwave flux
c     at(imt,jmt,2,nat)	 = tracers (previous and most recent)
c     surf(imt,jmt,nat)	 = surface values (1=temperature, 2=humidity)
c     flux(imt,jmt,nat)	 = downward flux (1=heat, 2=fresh water)
c     precip(imt,jmt)	 = precipitation
c     evap(imt,jmt)	 = evaporation
c     dnswr(imt,jmt)  	 = downward surface shortwave flux
c     uplwr(imt,jmt)  	 = upward surface longwave flux
c     upsens(imt,jmt)	 = upward surface sensible heat flux
c     upltnt(imt,jmt)    = upward surface latent heat flux
c     ssh(imt,jmt) 	 = saturation specific humidity
c     spd(imt,jmt) 	 = wind speed (cm/sec)
c     da(jmt,nat)	 = tracer diffusivity parameterization
c     coalbedo(jmt)	 = planetary coalbedo
c     solins(jmt)	 = solar insolation (units of solarconst)
c     esatm(jmt)	 = atmosphere emissivity times Stefan's constant
c     scatter(jmt)	 = solar scattering into atmosphere





c     cori(jmt,2)	 = Coriolis parameter

c
      real outlwr(imt,jmt), at(imt,jmt,3,nat), surf(imt,jmt,nat)
      real flux(imt,jmt,nat), precip(imt,jmt), evap(imt,jmt)
      real dnswr(imt,jmt), uplwr(imt,jmt), upsens(imt,jmt)
      real upltnt(imt,jmt), ssh(imt,jmt), spd(imt,jmt), da(jmt,nat)
      real coalbedo(jmt), solins(jmt), esatm(jmt), scatter(jmt)





      real cori(jmt,2)
c
      common /atm/ outlwr, at, surf, flux, precip, evap, dnswr, uplwr
     &,            upsens, upltnt, spd, ssh, da, coalbedo, solins
     &,            esatm, scatter





     &,            cori
c
c====================== include file "coord.h" =========================
c
c                    model grid point coordinates
c
c     grid definition:
c
c     the model uses a staggard arakawa "b" grid which is setup and 
c     generated by the "grids.F" module. 
c
c     xt(i)   = longitude of the ith "t" point in degrees.   i=1..imt
c     xu(i)   = longitude of the ith "u,v" point in degrees. i=1..imt
c     yt(j)   = latitude of the jth "t" point in degrees.    j=1..jmt
c     yu(j)   = latitude of the jth "u,v" point in degrees.  j=1..jmt
c     zt(k)   = distance from surface down to center of level k (in cm)
c               (for depth of "t" and "u,v" grid points: k=1,km)
c     zw(k)   = distance from surface down to bottom of level k (in cm)
c               (for depth of "t" and "u,v" grid points: k=1,km)
c     dxtdeg  = widths for "t" grid cells (degrees)
c     dytdeg  = heights for "t" grid cells (degrees)
c     dxudeg  = widths for "u" grid cells (degrees)
c     dyudeg  = heights for "u" grid cells (degrees)
c     dzt(k)  = vertical resolution of "t" and "u" grid cells (in cm)
c     dzw(k)  = vertical resolution of "w" grid cells (in cm)
c
c     "i" increases in an eastward direction, "j" increases in a
c     northward direction, and "k" increases downward.
c     
      common /coord/ xt(imt), yt(jmt), xu(imt), yu(jmt), zw(km), zt(km)
      common /coord/ dxtdeg(imt), dytdeg(jmt), dzt(km)
      common /coord/ dxudeg(imt), dyudeg(jmt), dzw(0:km)
c
c====================== include file "csbc.h" ==========================
c
c                    surface boundary conditions (S.B.C.)
c
c
c     numosbc = number of ocean S.B.C..
c
c     numasbc = number of atmospheric S.B.C..
c
c     maxsbc  = maximum number of allowable S.B.C. fields.
c
c     numsbc  = total number of S.B.C. this is the sum of the 
c               atmosphere S.B.C. and ocean S.B.C. fields. it must
c               be less than or equal to "maxsbc".
c
c     sbcocn  = S.B.C. fields on the ocean grid.
c               n=1..numosbc are for the incoming ocean S.B.C.
c               n=numosbc+1..numosbc+numasbc are for the outgoing S.B.C.
c

c
c     ntspos  = number of time steps per ocean segment
c
c     sbcname  = S.B.C. character string names (eg: "SST", "taux", etc)
c               note that these character strings should be changed with
c               care since they are used to identify fields for special
c               treatment
c
c     dunits  = dimensional units for S.B.C. (eg: "deg C")
c
c     mapsbc  = indices for relating how S.B.C. fields are stored
c               within arrays "sbcocn" and "sbcatm"  
c               eg: m = mapsbc(n) where sbcocn(,,m) is S.B.C. "n"
c
c     restrictions on re-arranging S.B.C. fields and "mapsbc":
c
c     1) all ocean S.B.C. (taux, tauy, etc) should be grouped together. 
c        relative ordering within the group is unimportant but the
c        group must preceed the atmos S.B.C. group.
c
c     2) all atmos S.B.C. (sst, ...) should also be grouped together.
c        relative ordering within the group is unimportant.
c
c     the default arrangement is defined as:
c
c             (these five ocean S.B.C. come from the atmos )
c     mapsbc(1) references taux
c     mapsbc(2) references tauy
c     mapsbc(3) references heat flux
c     mapsbc(4) references salt flux
c      if the atmos supplied fresh water flux then it
c      would have to be converted to ...
c      salt flux  = -(P-E+R) * rho * Sref
c      where...
c      P-E+R represents a precipitation minus evaporation
c            plus runoff rate in cm of water/sec
c      rho is the density if water taken to be 1 g/cm**3, and
c      Sref is a reference salinity in units of grams of salt per
c            gram of water (in units of "parts per part" such
c            as 0.035 ... not "parts per thousand")
c      Depending upon the application of interest, users may wish
c      to set Sref to either be a constant over the entire model
c      domain or for it to be the locally predicted salinity of
c      the uppermost model level (S(1)).  If one desires to ensure
c      that a global average P-E+R flux of zero translates to zero
c      trend in the salt content of the ocean, then a constant Sref
c      is needed.      
c     mapsbc(5) references short wave
c
c             (these four atmos S.B.C. come from the ocean)
c     mapsbc(6) references SST
c     mapsbc(7) references SSS
c     mapsbc(8) references surface u
c     mapsbc(9) references surface v
c
c
c     when re-ordering S.B.C., search for "mapsbc"  
c     (eg: grep mapsbc *.F) to insure the new indexing is consistant
c     with the re-ordering. also make changes in "sbcname", "dunits", 
c     "coabc", and "crits" to maintain consistancy.
c
c     example 1: suppose you want only the first six S.B.C...
c                in "csbc.h", set  numosbc=5, numasbc=1
c                this reduces memory requirements.
c                no other changes are necessary
c
c     example 2: suppose you want to remove the short wave boundary
c                condition (to save more memory) from example 1 . 
c                a) in "csbc.h", set numosbc=4, numasbc=1
c                b) grep "mapsbc(5)" *.F to find and remove references
c                c) grep "mapsbc(6)" *.F to change references to 
c                                        mapsbc(5)
c
c     
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c
c
      logical asegs, asege, afirst, alast
      character*10 sbcname
      character*15 dunits
c
      parameter (numosbc=5
     &,          numasbc=4
     &,          maxsbc=numosbc+numasbc, numsbc=maxsbc)
c
      common /csbc/ sbcocn(imt,jmt,numsbc) 
      common /csbc/ dampts(nt), dampdz(nt)
      common /csbc/ coabc(maxsbc), crits(maxsbc)
      common /csbc1/ mapsbc(maxsbc), numpas, iombc, ntspos, ntspas
      common /csbc2/ sbcname(maxsbc), dunits(maxsbc)
      common /csbc3/ asegs, asege, afirst, alast 
c
c====================== include file "iounit.h" ========================
c
c     i/o units and related variables
c
c     taum1disk = disk pointer for tau-1 latitude rows
c     taudisk   = disk pointer for tau   latitude rows
c     taup1disk = disk pointer for tau+1 latitude rows
c     kflds     = disk unit used for two dimensional fields
c     latdisk   = disk units for latitude rows (alternately pointed to 
c                by taum1disk, taudisk, and taup1disk)
c     wide_open_mw = logical to indicate that the MW is fully opened.
c              if .true. then jmw = jmt and there are no latitude rows
c              on disk. Instead, they are all in the MW.
c              if .false. then jmw < jmt and all latitude rows are on
c              disk so they must be transferred between the MW and disk.
c              
c     iodoc  = unit for documentation
c     iostab = unit for stability testing
c     iotim  = unit for time means
c     iotim1 = scratch disk (SSD) unit for accumulating time means
c     ionew1 = unit for reading sponge layer data
c     ionew2 = mirror unit of sponge layer data on SSD




c     
c     for the following, a control # < 0 implies that unformatted data
c     will be written to a unit selected by the i/o manager "iomngr.F"
c     and given a hardwired name (grep getunit *.F to see names) 
c     and formatted data (to stdout) will be written. if a # > 0 and
c      # <> stdout, only unformatted data will be written.
c
c     iotavg = control # for tracer averages
c     iotmb  = control # for writing tracer meridional budget.
c     iotrmb = control # for term balances for tracer and momentum
c     ioglen = control # for writing global energetics integrals
c     iovmsf = control # for writing meridional stream function
c     iogyre = control # for writing gyre transport.
c     ioprxz = control # for writing x-z sections from latitudes
c     ioext  = control # for writing external mode (stream function)
c     iodsp  = control # for writing diagnostic surface pressure
c     iotsi  = control # for writing time step integrals
c     ioxbt  = control # for writing time averaged xbt data
c     iozmbc = control # for writing zonal mean surf boundary conditons
c
      integer taum1disk, taudisk, taup1disk
      common /iounit/ taum1disk, taudisk, taup1disk

      common /iounit/ latdisk(2), kflds

      common /iounit/ iodoc, iostab, iotavg, iotmb, iotrmb
      common /iounit/ iotim, iotim1
      common /iounit/ ioglen, iovmsf, iogyre, ioprxz, ioext, iodsp
      common /iounit/ iotsi, iozmbc, ionew1, ionew2, ioxbt




      logical wide_open_mw
      common /iounitl/ wide_open_mw
c
c     iotext  = 80 character text string for describing the details
c                of the next unformatted data record.
c     expnam  = 60 character text string for the experiment name
c
      character iotext*80, expnam*60
      common /iounitc/ iotext, expnam
c
c     when writing unformatted data records in MOM, each data record is
c     preceeded by a header record which was written as:
c     write(unit) stamp, iotext, expnam
c     where stamp is a 32 character specification of the model date &
c     time corresponding to the time step when the data was written and
c     iotext is a 80 character description of what is in the
c     data record and how it is to be read. expnam is a 60 character
c     experiment name which shows which experiment wrote the data.
c     this makes it easy to decipher any unformatted output from the
c     model by using a program similar to the following: 
c
c      program decifr
c
c-----------------------------------------------------------------------
c      decifer an unformatted file from MOM by showing the header
c      records. the file needs to copied to file "fort.21"
c-----------------------------------------------------------------------
c
c      character*32 stamp
c      character*80 iotext
c      character*60 expnam
c
c      iounit = 21
c      rewind iounit
c      do n=1,100000
c
c        read the header record
c
c        read (iounit, end=110) stamp, iotext, expnam
c        write (*,'(1x,a32,1x,a80)') stamp, iotext
c
c        skip the data record
c
c        read (iounit)
c      enddo
c110   continue
c      write (*,*) " => end of file on fort.",iounit
c      stop
c      end
c
c     note: all unformatted diagnostic MOM data is handled this way.
c     to insure that data is read properly, verify that arrays are
c     dimensioned corectly by comparing the listed variables against
c     those in the *.h files. (grep -i -n "variable" *.h) Also, most
c     data from MOM is written IEEE 32bit so it is read directly by
c     most workstations. However, when trying to read these IEEE files
c     on the CRAY, they must be assigned IEEE before being read.
c     Some diagnostic data is averaged over time before being written.
c     In these cases, the time "stamp" refers to the last time step
c     at the end of the averaging period. An averaging interval is
c     also written as part of the data. Averaging periods = zero 
c     indicate instantaneous data.
c
c====================== include file "levind.h" ========================
c
c     vertical level indicators which define model geometry & bottom
c     topography:
c
c     kmt = number of vertical boxes over "t" points
c     kmu = number of vertical boxes over "u,v" points
c
      common /levind/ kmt(imt,jmt), kmu(imt,jmt)
c
c====================== include file "scalar.h" ========================
c
c     various scalar quantities:
c
c     dtts   = time step for density & tracers (in seconds)
c     dtuv   = time step for baroclinic velocity (in seconds)
c     dtsf   = time step for barotropic velocity (in seconds)
c     c2dtts = 2*dtts
c     c2dtuv = 2*dtuv
c     c2dtsf = 2*dtsf
c     acor   = (>0, 0) = (implicit, explicit) treatment of coriolis
c               term for internal and external modes.
c     rho0   = mean density for Bousinessq approximation
c     rho0r  = 1/rho0 
c     omega  = earth`s rotation rate (radians/sec)
c     radius = earth`s radius (cm)
c     grav   = earth`s gravitational acceleration (cm/sec**2)
c     cdbot  = bottom drag coefficient
c     ncon   = number of  passes through convective code in tracer
c     gcor   = time centering for coriolis term
c
c     taux0  = constant zonal windstress (dynes/cm**2) for idealized
c              equatorial studies
c     tauy0  = constant meridional windstress (dynes/cm**2) for
c              idealized equatorial studies
c
      common /scalar/ dtts, dtuv, dtsf, c2dtts, c2dtuv, c2dtsf, acor
      common /scalar/ rho0, rho0r, omega, radius, grav, cdbot, gcor
      common /scalar/ taux0, tauy0
      common /scalri/ ncon
c
c     bring in non dimensional constants
c
c====================== include file "ndcon.h" ========================
c
c     various non dimensional quantities:
c
c     radian = degrees per radian
c     pi     = something good to eat
c
      common /ndcon/ radian, pi
c
c
c====================== include file "switch.h" ========================
c
c     all time dependent decisions are made by time manager "tmngr.F"
c     and communicated elsewhere to the model via logical switches.
c
c     inputs: (defaulted in "blkdta.F", optionally reset via namelist)
c
c
c     runlen  = integration period (see rununits). note "runlen" should
c               be an integral number of density time steps. if not,
c               then "runlen" is automatically adjusted to insure this.
c               fractional days are supported but not fractional months
c               or years.
c     rununits= units of "runlen". may be "days", "months", or "years".
c               tmngr will convert "runlen" which is in "rununits"
c               to "rundays" in units of days.
c
c     segtim  = the integration time "runlen" is broken into a number of
c               segments each of length "segtim" days. updated surface
c               boundary conditions are applied to MOM every "segtim" 
c               days. this is useful when coupling to atmospheric models
c               in which case both models exchange surface boundary
c               conditions every "segtim" days where "segtim"
c               is 1/(coupling frequency). without an atmospheric model,
c               when getting surface boundary conditions from data, 
c               "segtim" is set to the time step (in days) by mom.F. in
c               either case, "runlen" (in days) should be an integral
c               number of "segtim".     
c
c     nmix    = number of time steps between mixing timesteps. used
c               to damp timestep splitting due to centered leapfrog.
c
c     init    = (true,false)  indicates that this run is a
c               (start from initial conditions, restart)
c
c     restrt  = (true,false) = (do,don`t) write a restart at the end
c               of the run
c
c     eb      = (true,false) configures for the use of a 
c               (euler backward,forward) type mixing timestep
c
c-----------------------------------------------------------------------
c     inputs to tmngr.F: diagnostic intervals
c-----------------------------------------------------------------------
c
c     note: switches are used to control the interval between doing
c           diagnostics. units for all switches are in days. 
c           setting a switch < 0.0 disables whatever the switch is 
c           controlling. setting it = 0.0 causes the diagnostic to be 
c           done every time step, and setting it > 0.0 causes the 
c           diagnostic to be done repeatedly on the specified interval. 
c
c     cmixint = number of days between writing estimated mixing coeffs
c               on faces of T cells and U cells
c
c     crossint = number of days between writing diapycnal and isopycnal
c               components of flow
c
c     fctint = number of days between writing difference between 
c              FCT and leapfrog advection
c
c     densityint = number of days between writing density
c
c     exconvint = number of days between writing temperature rate of
c                 change due to explicit convection
c
c     glenint =  number of days between global energetics integrals.
c
c     trmbint =  number of days between momentum and tracer term
c                balances (global and regional).
c
c     itrmb   = (true,false) = (do,don`t) write regional mask info for
c               the term balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     gyreint =  number of days between calculation of tracer northward
c                transport.
c     igyre   = (true,false) = (do,don`t) write regional mask info for
c               the gyre diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     vmsfint =  number of days between calculation of vertical and
c                meridional stream function.
c
c     tyzint  =  number of days between calculation of zonally averaged
c                tracer components.
c
c     prxzint =  number of days between printouts of x-z data.
c
c     extint  =  number of days between printouts of external mode.
c
c     dspint  =  number of days between surface pressure calculation.
c                Note: only when "diagnostic_surface_height" is enabled.
c     dspper  = averaging period for "diagnostic_surface_height"
c
c     tavgint = number of days between regional tracer averages (under
c               horizontal regions).
c
c     itavg   = (true,false) = (do,don`t) write regional mask info for
c               the tracer average diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     tmbint  = number of days over which tracer equation in averaged
c               in depth and longitude to determine the meridional 
c               balance among storage, divergence, dissipation and 
c               forcing.
c     tmbper  = averaging period for "meridional_tracer_balance"
c
c     itmb    = (true,false) = (do,don`t) write "msktmb" for tracer
c               the meridional balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c
c     tsiint  = number of days between printing of time step integrals.
c
c     stabint = number of days between sampling for various stability
c               criteria.
c
c     snapint = number of days between writing instantaneous samples
c               of data from the MOM grid. note: only when "snapshots"
c               is enabled. see "iounit.h" for more details.
c               all data is at time level "tau" so it is one time step
c               before the date shown in "stamp".
c
c     timavgint= interval (days) for writing time mean data from
c               the "averaging" grid (only when "time_averages" is
c               enabled). if "timavgint" is not an integral number of
c               density time steps,"timavgint" is automatically adjusted
c               to insure this. if the number of days to integrate is
c               not an integral number of "timavgint" then the last
c               averaging period will be less than "timavgint" days.this 
c               may lead to one more averaging period than expected. 
c               see "iounit.h" for more details.
c     timavgper= averaging period for "time_averages"
c
c     xbtint  = averaging period (days) for writing XBT data (only when
c               "xbts" is enabled). if "xbtint" is not an integral
c               number of density time steps, "xbtint" is automatically
c               adjusted to insure this. if the number of days to 
c               integrate is not an integral number of "xbtint" then the
c               last averaging period will be less than "xbtint" days.
c               this may lead to one more averaging period than  
c               expected. see "iounit.h" for more details.
c     xbtper  = averaging period for "xbts"
c
c     zmbcint = number of days between calculation of zonal mean
c               surface boundary conditions (and related  quantities)
c
c     trajint = number of days between writing particle trajectories.
c               particle trajectories are always written on the last
c               time step of the run to allow for restarting.
c
c-----------------------------------------------------------------------
c     outputs from tmngr.F: logical switches
c-----------------------------------------------------------------------
c
c     rundays = integration time in days (from "runlen")
c
c     the following are logical counterparts to the above switches are 
c     set within "tmngr" every time step. logical switches control all
c     decisions about when to do things in MOM.
c
c     cmixts  = (false,true) = (don`t, do) do write estimated mixing
c               coefficients on this time step.
c               based on "cmixint".
c
c     crossts  = (false,true) = (don`t, do) write diapycnal and 
c               isopycnal components of flow on this time step.
c               based on "crossint".
c
c     fctts    = (false,true) = (don`t, do) write difference between 
c               FCT and leapfrog advection on this time step.
c               based on "fctint".
c
c     densityts  = (false,true) = (don`t, do) write density on this time
c               step. based on "densityint".
c               
c
c     exconvts  = (false,true) = (don`t, do) do write temperature change
c               due to explicit convection on this time step.
c               based on "exconvint".
c
c     glents  = (false,true) = (don`t, do) do calculation of global
c               energy integrals on this time step. based on "glenint".
c
c     trmbts  = (false,true) = (don`t, do) do calculation of momentum &
c               tracer term balance on this timestep. based on "trmbint"
c
c     gyrets  = (false,true) = (don`t, do) do calculation of tracer
c               northward transport on this timestep. based on "gyreint"
c
c     vmsfts  = (false,true) = (don`t, do) do calculation of vertical
c               and meridional stream function on this time step.
c               based on "vmsfint"
c
c     tyzts   = (false,true) = (don`t, do) do calculation of zonally
c               averaged tracer components on this time step.
c               based on "tyzint"
c
c     prxzts  = (false,true) = (don`t, do) do printouts of x-z data
c               on this time step. based on "prxzint"
c
c     extts  = (false,true) = (don`t, do) do printout of external mode
c               on this time step. based on "extint"
c
c     dspts  = (false,true) = (don`t, do) do calculation of diagnostic 
c              surface pressure on this time step. based on "dspint"
c               
c
c     stabts  = (false,true) = (don`t, do) test for stability on this
c               time step. based on "stabint"
c
c     tavgts  = (false,true) = (don`t do) do tracer averages on this
c               time step. based on "tavgint"
c
c     tmbts   = (false,true) = (don`t, do) write out tracer meridional .
c               balance on this time step. based on "tmbint"
c
c     tsits   = (false,true) = (don`t, do) print time step integrals
c               on this time step. based on "tsiint"
c
c     zmbcts  = (false,true) = (don`t, do) print zonal mean boundary
c               conditions on this time step.  based on "zmbcint"
c
c     trajts  = (false,true) = (don`t, do) print particle trajectories
c               on this time step. based on "trajint"
c
c     snapts  = (false,true) = (don`t, do) save a snapshot of the data
c               on this time step. based on "snapint"
c
c     timats  = (false,true) = (don`t, do) write time mean data
c               on this time step. based on "timavgint"
c                                          
c     xbtts   = (false,true) = (don`t, do) write averaged XBT data on
c               this time step based on "xbtint"
c
c
c     leapfrog= (false,true) on a (mixing, normal leapfrog) time step
c                based on "nmix"
c                                          
c     euler1  = true on the 1st pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     euler2  = true on the 2nd pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     forward = true on a forward time step. otherwise false
c		(applies when "eb" = false)		  
c                                          
c
c     the following logical switches are based on the model time step. 
c    
c     first   = (true,false) =  when it`s (the first, not the first)
c                               time step of a run
c     eots    = end of a time step. always true except for first
c               pass of an euler backward time step
c     eorun   = last time step of a run. always false except during the
c               last time step of the run.
c
c     eoday   = true when within 1/2 time step of the end of a day
c               else ... false
c     eoweek  = true when within 1/2 time step of the end of a 7 day
c               week (referenced to the start of a year) else ...false
c     eo2wks  = true when within 1/2 time step of the end of two weeks
c               (referenced to the start of a year) else ... false
c     midmon  = true when within 1/2 time step of the middle of a month
c               else ... false
c     eomon   = true when within 1/2 time step of the end of a month
c               else ... false
c     eoyear  = true when within 1/2 time step of the end of a year
c               else ... false
c     osegs   = true on the 1st time step of an ocean segment in mom.F
c               otherwise false.
c     osege  =  true on the last time step of an ocean segment in mom.F
c               otherwise false.
c
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c
c
      logical eb, leapfrog, euler1, euler2, forward, eots
      logical init, first, restrt
      logical itavg, itmb, itrmb, igyre
      character *8 rununits
c
      common /switcc/ rununits
      common /switcr/ runlen, rundays
      common /switci/ nmix
      common /switcl/ eb, leapfrog, euler1, euler2, forward, eots
      common /switcl/ init, first, restrt
      common /switcl/ itavg, itmb, itrmb, igyre
c
      logical          eoday, eoweek, eo2wks
      common /switci/ ieoday,ieoweek,ieo2wks
      common /switcl/  eoday, eoweek, eo2wks
c
      logical          eomon, midmon, eoyear, eorun
      common /switci/ ieomon,imidmon,ieoyear,ieorun
      common /switcl/  eomon, midmon, eoyear, eorun
c
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c     each interval switch needs three variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output (e.g,.  glenint)
c         2) a switch (logical) for the interval (e.g.,  glents )
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c         3) an index (integer)                       (e.g., iglenint)
c
c     the user must specify the interval [e.g., glenint] for diagnostic
c     output in units of days. tmngr sets the corresponding logical  
c     switch [e.g., glents] every time step. It is set to true when  
c     within half a time step of the requested interval, otherwise it is
c     false. All decisions relating to the interval [e.g., glenint]
c     are based on the logical switch [e.g., glents].
c           
c     internal time structures
c
c     The switch index [e.g., iglenint] is used to subsrcipt into  
c     internal arrays maintained by tmngr.F. The switch index is
c     allocated on the first call to function "alarm".
c     The array entry [e.g., iinterval(iglenint)] is a time index to the
c     internal representation of the interval [e.g., glenint].
c     The array entry [e.g., ialarm(iglenint)] is a time index to the
c     next time the alarm will be true.
c-----------------------------------------------------------------------
c
      logical           tavgts,    glents,    trmbts,   prxzts
      common /switcr/   tavgint,   glenint,   trmbint,  prxzint
      common /switci/  itavgint,  iglenint,  itrmbint, iprxzint
      common /switcl/   tavgts,    glents,    trmbts,   prxzts
c
      logical          extts,   trajts,   exconvts,   cmixts
      common /switcr/  extint,  trajint,  exconvint,  cmixint
      common /switci/ iextint, itrajint, iexconvint, icmixint
      common /switcl/  extts,   trajts,   exconvts,   cmixts
c
      logical          vmsfts,   gyrets,    tsits,   snapts,   fctts
      common /switcr/  vmsfint,  gyreint,   tsiint,  snapint,  fctint
      common /switci/ ivmsfint, igyreint,  itsiint, isnapint, ifctint
      common /switcl/  vmsfts,   gyrets,    tsits,   snapts,   fctts
c
      logical          tyzts
      common /switcr/  tyzint
      common /switci/ ityzint
      common /switcl/  tyzts
c
      logical          stabts,   zmbcts,   crossts,   densityts
      common /switcr/  stabint,  zmbcint,  crossint,  densityint
      common /switci/ istabint, izmbcint, icrossint, idensityint
      common /switcl/  stabts,   zmbcts,   crossts,   densityts
c
      logical          osegs,  osege
      common /switcr/          segtim
      common /switci/ iosegs, iosege
      common /switcl/  osegs,  osege
c   
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c              A N D   A V E R A G I N G   P E R I O D
c
c     each averaging period switch needs five variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output    (e.g. xbtint  )   
c         2) a switch (logical) for the interval         (e.g. xbtts   )
c         3) an averaging period (real)                  (e.g. xbtper  )   
c         4) a switch (logical) for accumulating         (e.g. xbtperts)
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switches
c
c         5) an index (integer)                         (e.g. ixbtint  )
c
c     The user must specify the interval [e.g., xbtint] for diagnostic
c     output in units of days and the averaging period [e.g., xbtper] 
c     in units of days. The averaging period may be less than or equal
c     to the interval. For example, if the interval is 30.0 days and the
c     averaging period is 5.0 days, results will be averaged over all
c     time steps within days 26, 27, 28, 29, and 30.  An averaging period
c     of 0.0 days averages over the last time step of the interval (as
c     does xbtper = dt), and an averaging period less than zero turns
c     the switches off for all time steps.  
c
c     The logical switch for writing output at the specified interval 
c     [e.g., xbtts] is set to true on the last time step of the 
c     averaging period. The logical switch for accumulating results
c     [e.g., xbtperts] is true for all time steps within the averaging
c     period, otherwise it is false. 
c
c     internal time structures
c
c     The index [e.g., ixbtint] is allocated on the first call to 
c     function "avg_alarm". The array element iperiod(ixbtint) is an
c     index to the time structure for the internal representation of 
c     "xbtper", and ilastsw(ixbtint) is the index of the switch that 
c     flags the last time step of the accumulation period.
c     Depending on use,  ilastsw(ixbtint) may either be the index
c     of another "named" switch or the index of a new switch
c     allocated on the first time step.
c     In the latter case, iinterval(ilastsw(ixbtint)) is the index of
c     the time structure where "xbtint" is stored in internal form,
c     and ialarm(ilastsw(ixbtint)) is the index of the time when an
c     accumulation period will next end.
c     The variable nextts(ixbtint) is true whenever the next
c     time step will begin the accumulation period.
c
c-----------------------------------------------------------------------
c
      logical         xbtts,     dspts,    tmbts,    timavgts
      logical         xbtperts,  dspperts, tmbperts, timavgperts
      common /switcr/ xbtint,    dspint,   tmbint,   timavgint
      common /switcr/ xbtper,    dspper,   tmbper,   timavgper
      common /switci/ixbtint,   idspint,  itmbint,  itimavgint
      common /switcl/ xbtts,     dspts,    tmbts,    timavgts
      common /switcl/ xbtperts,  dspperts, tmbperts, timavgperts
c
c-----------------------------------------------------------------------
c
c                 S W I T C H E S    B A S E D    O N    
c
c         C A L E N D A R   O R    P R E V I O U S    S W I T C H   
c
c               A N D   A V E R A G I N G    P E R I O D
c
c    
c
c     the following logical switches are based on any calendar or 
c     interval switch and an averaging period (in days). The  averaging
c     period must be less than or equal to the interval. The last
c     time step of the averaging period is at the end of the interval.
c     If the averaging period is set to zero, the averaging period
c     consists only of the last time period of the interval.  If
c     the averaging period is less than zero, these switches are always
c     false.
c
c     each averaging period switch needs four variables in common. For
c     example, if the averaging period is before the end of each month
c     then the calendar switch (eomon), and index (ieomon) are presumed
c     to exist in common and need not be added.
c     
c     Additionally, four items are needed.
c
c       1) an averaging period (real)                  (e.g.  testper  )   
c       2) a switch (logical) for accumulating results (e.g.  testperts)
c       3) a switch (logical) for the end of interval  (e.g.  testts   )
c
c     the fourth is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c       4) an index (integer)                          (e.g.  itestper )
c
c     Suppose it is required to produce averages over all time steps
c     during the last 5 days of each month. Then "testper" = 5.0 and 
c     the following will calculate the accumulating switch.
c
c      testts = avg_alarm(itestper, ihalfstep, 0, testper, iref, ieomon)
c      testperts = on(itestper)
c
c     Note the use of "ieomon" to key off the months.  The switch
c     "testts" will be true whenever "eomon" is true.
c     Also note that when an averaging switch is keyed off another
c     switch, the switch inverval argument is not used, but is 
c     retained for consistency with the form of other averaging
c     switches.
c-----------------------------------------------------------------------
c
      logical           testperts
      logical           testts
      common /switcr/   testint
      common /switcr/   testper
      common /switci/  itestper
      common /switcl/   testts
      common /switcl/   testperts

c
      parameter (maxsw=100)
      logical          on, lastts, nextts
      common /switci/  nsw  
      common /switci/  ialarm(maxsw), iinterval(maxsw), iperiod(maxsw)
     &,                ilastsw(maxsw)
      common /switcl/  on(maxsw), lastts(maxsw), nextts(maxsw)
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c

c====================== include file "mapsbc.h" ========================
c
c     indicies for surface boundary condition arrays.  names must be
c     unique and are set at the begining of "driver"
c
c     itaux is the x component of wind stress
c     itauy is the y component of wind stress
c     ihflx is heat flux
c     ipme is for precipitation minus evaporation
c     ipsw is for penitrating shortwave (into ocean first layer)
c     isst is the ocean model SST
c     isss is the ocean model SSS
c     isu is the x component of the ocean model first layer velocity
c     isv is the y component of the ocean model first layer velocity
c     it10 is the 10 metre atmopheric temperature
c     iq10 is the 10 metre atmopheric humidity
c     ilwr is incoming longwave radiation
c     iswr is incoming shortwave radiation
c     igu is the x component of the ocean model second layer velocity
c     igv is the y component of the ocean model second layer velocity
c
      common /mapsbc/ itaux, itauy, ihflx, ipme, ipsw, isst, isss
     &,               isu, isv, it10, iq10, ilwr, iswr, igu, igv
c
c
c-----------------------------------------------------------------------
c     Initialize S.B.C. names and related items.
c     
c     Dimensional units for the S.B.C. are for the model where they
c     will be used. eg: Heat flux will be used as a S.B.C. for the
c     ocean in cal/cm**2/sec.

c-----------------------------------------------------------------------
c
      do n=1,maxsbc
        mapsbc(n)  = 0
	coabc(n)   = c0
	crits(n)   = c0
	sbcname(n) = 'unknown'
	dunits(n)  = 'unknown'
      enddo
c
      write (stdout,*) ' '
      write (stdout,*)
     & ' Surface Boundary Conditions are defined as follows:'
c
      write (stdout,*) ' '
      write (stdout,*) ' for the ocean (applied to MOM):'
c-------------------------------------------------------------------
c define order of sbcs
c-------------------------------------------------------------------

      itaux=1
      itauy=2
      ihflx=3
      ifflx=4
      isst=5
      isss=6
c

      do n=1,numsbc
c

c       order S.B.C.'s such that S.B.C. "n" has index "m"=mapsbc(n)
c       within arrays "sbcocn" and "sbcatm"
c
        mapsbc(n) = n
        m = mapsbc(n)
	if (m .eq. 1) then
	  sbcname(m) = ' taux     '
	  dunits(m)  = ' dynes/cm**2   '
	  coabc(m)   = 1.0
	  crits(m)   = 1.e-3
	else if (m .eq. 2) then
	  sbcname(m) = ' tauy     '
	  dunits(m)  = ' dynes/cm**2   '
	  coabc(m)   = 1.0
	  crits(m)   = 1.e-3
	else if (m .eq. 3) then
	  sbcname(m) = ' heat flux'
	  dunits(m)  = ' cal/cm**2/sec '
	  coabc(m)   = 1.0
	  crits(m)   = 1.e-5
	else if (m .eq. 4) then
	  sbcname(m) = ' salt flux'
	  dunits(m)  = ' gm/cm**2/sec  '
	  coabc(m)   = 1.0
	  crits(m)   = 1.e-6
	else if (m .eq. 5) then
	  sbcname(m) = ' SST      '
	  dunits(m)  = ' deg C         '
	  coabc(m)   = 0.0
	  crits(m)   = 0.05
	else if (m .eq. 6) then
	  sbcname(m) = ' SSS      '
	  dunits(m)  = ' (S-35.0)/1000 '
	  coabc(m)   = 1.0
	  crits(m)   = 1.e-5
	endif
c

        if (n .eq. numosbc+1) then
          write (stdout,*) ' '
          write (stdout,*) ' for the atmosphere (from MOM):'
	endif
	if (n .le. numosbc) then
	  write (stdout,*) ' S.B.C. # ',m,' is ',sbcname(m)
     &,', atmos native units are ', dunits(m)

        else
	  write (stdout,*) ' S.B.C. # ',m,' is ',sbcname(m)
     &,', MOM native units are ', dunits(m)

	endif
      enddo
c-----------------------------------------------------------------------
c read in surface temperature
c-----------------------------------------------------------------------

      open(1,file='surtemp0kam',status='old')
      do j=2,jmt-1
      read(1,6666)(sbcocn(i,j,1),i=2,imt-1)
      end do
      close(1)
 6666 format(10f8.4)

c
c-----------------------------------------------------------------------
c     do the introductory ocean setup once per run
c-----------------------------------------------------------------------
c

      call setmom
c
c-----------------------------------------------------------------------
c     do the introductory atmosphere setup once per run
c-----------------------------------------------------------------------
c
c     "setatm" must do the following:
c       1) set up the atmospheric S.B.C. grid definition
c       2) define the atmosphere land/sea mask
c       3) set the atmosphere time step "dtatm" {seconds}
c

      call setembm (dtatm)



c
c     when the MOM S.B.C. come from a dataset, force the segment time
c     and atmospheric time step to one MOM time step. This will force
c     the number of segments to one and the number of time steps per
c     segment to represent the length of the run in days. 
c
      dtatm = dtts
      segtim = dtts*secday

c
c-----------------------------------------------------------------------
c     compute the number of ocean time steps "numots" for this run and 
c     the number of ocean time steps per ocean segment "ntspos".
c     compute the number of atmos time steps "numats" for this run and
c     the number of atmos time steps per atmos segment "ntspas".
c     divide the integration time "days" into "numseg" segments.
c     each will be length "segtim" days. Surface boundary conditions
c     are supplied every "segtim" days.
c-----------------------------------------------------------------------
c
      numots = nint(rundays/(dtts*secday))
      ntspos = nint(segtim/(dtts*secday))
      numats = nint(rundays/(dtatm*secday))
      ntspas = nint(segtim/(dtatm*secday))
      numseg = numots/ntspos
c

      write (stdout,8800) rundays, numseg, segtim, ntspos, ntspas, dtts
     &,                   dtatm

c
c-----------------------------------------------------------------------
c     check for consistency in the S.B.C. setup
c-----------------------------------------------------------------------
c
      call chkcpl (dtatm, dtts)

c
c
c
c
c-----------------------------------------------------------------------
c     S T A R T    S E G M E N T    L O O P
c-----------------------------------------------------------------------
c
      do n=1,numseg


c
c-----------------------------------------------------------------------
c       get the atmospheric S.B.C. from MOM
c-----------------------------------------------------------------------
c
        call gasbc (n)
c

c
c-----------------------------------------------------------------------
c       call the atmospheric model once for each time step until one
c       segment of "segtim" days is complete. hold atmos S.B.C. fixed
c       during each segment and predict average S.B.C. for MOM
c-----------------------------------------------------------------------
c
        do loop=1,ntspas

          call embm

        enddo

c

c

c-----------------------------------------------------------------------
c       update timestep counter, set corresponding model time, and set
c       time dependent logical switches which determine program flow.
c-----------------------------------------------------------------------
c
        itt = itt + 1
        call increment_time (dtts)

	call embmout


      enddo
c
c-----------------------------------------------------------------------
c     E N D    S E G M E N T    L O O P
c-----------------------------------------------------------------------
c

8800  format (/,/,1x,'The model has been configured to run for'
     &,g14.7,' days in ',i10,' segments of ',g14.7,' days each.'
     &,/1x,'There will be ',i6,' ocean time steps per segment'
     &,' and ',i6,' atmosphere time steps per segment.'/
     &,/1x,' The ocean "dtts" =', g14.7, ' seconds'
     &,', and the atmosphere "dtatm" =', g14.7,' seconds'
     &,/,/)
9000  format(/,/,1x,'==== E N T E R I N G    ',a9,'    S E G M E N T  #'
     &,       i4, ',  time = ',a32,' ===='/,/)
9100  format (10x,'==> Finished reading MOM S.B.C. data from file'
     &,    ' restrt_sbc.dta at time = ',a32)
9200  format (10x,'==> Finished writing MOM S.B.C. data to file '
     &,    'restrt_sbc.dta at time = ',a32)

      stop
      end


      subroutine chkcpl (dtatm, dtts)
      logical errorc
c====================== include file "param.h" =========================
c
c     main parameter file which sets ocean characteristics:
c
c     "size.h" sets model size "imt", "jmt", and "km"
c
c====================== include file "size.h" ==========================
c                                                                       
c-----------------------------------------------------------------------
c     USER INPUT: 
c-----------------------------------------------------------------------
c
c     imt    = number of grid points in the longitudinal direction
c              (calculated points are from 2 through imt-1. End points
c               are boundaries)          
c
c     jmt    = number of grid points (latitude rows) in the latitudinal
c              direction (calculated points are from 2 through jmt-1.           
c              End points are boundaries)   
c                                
c     km     = number of grid points in the vertical direction          
c              (calculated points are from 1 through km)
c
c     nt     = number of tracers (temperature, salinity, ...)
c
c     mnisle = maximum number of islands (unconnected land masses)
c
c     maxipp = maximum number of all island perimeter points
c-----------------------------------------------------------------------
c                                                                       
      parameter (imt=  92, jmt=  61, km= 15)
      parameter (nt=2)
      parameter (nat=2)
      parameter (mnisle=50, maxipp=5000)
c

c






c
c-----------------------------------------------------------------------
c     END USER INPUT
c-----------------------------------------------------------------------
c                                                                       
c-----------------------------------------------------------------------
c     By default, the MW (memory window) is 2nd order except for the
c     following options which require a 4th order MW 
c
c     for 2nd order schemes, the minimum sized MW is 3 latitude rows
c     for 4th order schemes, the minimum sized MW is 4 latitude rows
c                            (5 if using coarse_grained_parallelism)
c-----------------------------------------------------------------------
c













c
c-----------------------------------------------------------------------
c     set MW (memory window) size "jmw" 
c-----------------------------------------------------------------------
c                                                                       

c
c     for UNI-TASKING: "jmw" is set to the minimum for each option class 
c     "jmw" may be increased up to "jmt" 
c

      parameter (jmw=jmt)


c
c-----------------------------------------------------------------------
c     set first and last calculated row within the MW. other rows
c     are used as buffers
c-----------------------------------------------------------------------
c
c     jsmw   = 1st calculated row within the MW     
c     jemw   = last calculated row within the MW
c
      parameter (jsmw=2, jemw=jmw-1)
c
c
c     jextra = extra buffer rows needed for coarse_grained_parallelism.
c              "jextra" rows are added to the top and bottom of the MW
c              so the MW size increases by 2*jextra       
c

          parameter (jextra = 0)




c
c     nvar   = number of prognostic variables
c     lseg   = maximum number of longitudinal stream function segments
c     nlatpr = maximum number of latitudes for matrix printouts
c              on diagnostic time steps
c     nhreg  = number of regions in the horizontal used for averaging
c              tracers.
c     nvreg  = number of regions in the vertical used for term balance
c              calculations. note "nvreg" isn`t used for tracer averages
c     numreg = total number of regions ( = product of nhreg & nvreg)
c              used for term balance calculations
c
      parameter (lseg=5, nlatpr=10)

      parameter (nhreg=5, nvreg=2, numreg=nhreg*nvreg)

      parameter (nvar=nt+2)
c

c
      parameter (imtm1=imt-1, kmm1=km-1)                                
      parameter (imtp1=imt+1, imtm2=imt-2
     &,          jmtp1=jmt+1, jmtm1=jmt-1, jmtm2=jmt-2

     &,          jscan=jmtm2

     &,          kmp1=km+1, kmp2=km+2
     &,          imtkm=imt*km, nwds=imt*jmt, nkflds=2
     &,          nslab=imt*nvar*km, ntmin2=nt+1/nt)
c
c     include parameter constants
c
c====================== include file "pconst.h" ========================
c
c
c     rules for parameter constants
c
c     use prefix of "c" for whole real numbers (eg: c57 for 57.0)
c     use "m" after prefix to designate negative values (minus sign)
c       (eg: cm7 for -7.0)
c     use prefix of "p" for non repeating fractions (eg: p5 for 0.5)
c     use prefix of "r" for reciprocals (eg: r3 for 1/3.0)
c     combine use of prefix above and "e" for scientific notation, with
c       (eg: c5e4 for 5.0e4, c1em10 for 1.0e-10)
c
      parameter (c0=0.0, c1=1.0, c2=2.0, c3=3.0, c4=4.0, c5=5.0, c7=7.0)
      parameter (c8=8.0)
      parameter (c14=14.0, c16=16.0, c360=360.0)
      parameter (p125=0.125, p25=0.25, p5=0.5, p75=0.75)
      parameter (epsln=1.0e-20)
c
      parameter (c24=24.0, c60=60.0, c1440=1440.0)
      parameter (r24=c1/c24, r60=c1/c60, r1440=c1/c1440)
      parameter (secday=c1/(c60*c1440))
c
c     include standard I/O units
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c
c     ncrows = number of calculated rows within the MW.
c              (the remaining rows are buffer rows). 
c


      parameter (ncrows = jmw - 2)


c====================== include file "csbc.h" ==========================
c
c                    surface boundary conditions (S.B.C.)
c
c
c     numosbc = number of ocean S.B.C..
c
c     numasbc = number of atmospheric S.B.C..
c
c     maxsbc  = maximum number of allowable S.B.C. fields.
c
c     numsbc  = total number of S.B.C. this is the sum of the 
c               atmosphere S.B.C. and ocean S.B.C. fields. it must
c               be less than or equal to "maxsbc".
c
c     sbcocn  = S.B.C. fields on the ocean grid.
c               n=1..numosbc are for the incoming ocean S.B.C.
c               n=numosbc+1..numosbc+numasbc are for the outgoing S.B.C.
c

c
c     ntspos  = number of time steps per ocean segment
c
c     sbcname  = S.B.C. character string names (eg: "SST", "taux", etc)
c               note that these character strings should be changed with
c               care since they are used to identify fields for special
c               treatment
c
c     dunits  = dimensional units for S.B.C. (eg: "deg C")
c
c     mapsbc  = indices for relating how S.B.C. fields are stored
c               within arrays "sbcocn" and "sbcatm"  
c               eg: m = mapsbc(n) where sbcocn(,,m) is S.B.C. "n"
c
c     restrictions on re-arranging S.B.C. fields and "mapsbc":
c
c     1) all ocean S.B.C. (taux, tauy, etc) should be grouped together. 
c        relative ordering within the group is unimportant but the
c        group must preceed the atmos S.B.C. group.
c
c     2) all atmos S.B.C. (sst, ...) should also be grouped together.
c        relative ordering within the group is unimportant.
c
c     the default arrangement is defined as:
c
c             (these five ocean S.B.C. come from the atmos )
c     mapsbc(1) references taux
c     mapsbc(2) references tauy
c     mapsbc(3) references heat flux
c     mapsbc(4) references salt flux
c      if the atmos supplied fresh water flux then it
c      would have to be converted to ...
c      salt flux  = -(P-E+R) * rho * Sref
c      where...
c      P-E+R represents a precipitation minus evaporation
c            plus runoff rate in cm of water/sec
c      rho is the density if water taken to be 1 g/cm**3, and
c      Sref is a reference salinity in units of grams of salt per
c            gram of water (in units of "parts per part" such
c            as 0.035 ... not "parts per thousand")
c      Depending upon the application of interest, users may wish
c      to set Sref to either be a constant over the entire model
c      domain or for it to be the locally predicted salinity of
c      the uppermost model level (S(1)).  If one desires to ensure
c      that a global average P-E+R flux of zero translates to zero
c      trend in the salt content of the ocean, then a constant Sref
c      is needed.      
c     mapsbc(5) references short wave
c
c             (these four atmos S.B.C. come from the ocean)
c     mapsbc(6) references SST
c     mapsbc(7) references SSS
c     mapsbc(8) references surface u
c     mapsbc(9) references surface v
c
c
c     when re-ordering S.B.C., search for "mapsbc"  
c     (eg: grep mapsbc *.F) to insure the new indexing is consistant
c     with the re-ordering. also make changes in "sbcname", "dunits", 
c     "coabc", and "crits" to maintain consistancy.
c
c     example 1: suppose you want only the first six S.B.C...
c                in "csbc.h", set  numosbc=5, numasbc=1
c                this reduces memory requirements.
c                no other changes are necessary
c
c     example 2: suppose you want to remove the short wave boundary
c                condition (to save more memory) from example 1 . 
c                a) in "csbc.h", set numosbc=4, numasbc=1
c                b) grep "mapsbc(5)" *.F to find and remove references
c                c) grep "mapsbc(6)" *.F to change references to 
c                                        mapsbc(5)
c
c     
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c
c
      logical asegs, asege, afirst, alast
      character*10 sbcname
      character*15 dunits
c
      parameter (numosbc=5
     &,          numasbc=4
     &,          maxsbc=numosbc+numasbc, numsbc=maxsbc)
c
      common /csbc/ sbcocn(imt,jmt,numsbc) 
      common /csbc/ dampts(nt), dampdz(nt)
      common /csbc/ coabc(maxsbc), crits(maxsbc)
      common /csbc1/ mapsbc(maxsbc), numpas, iombc, ntspos, ntspas
      common /csbc2/ sbcname(maxsbc), dunits(maxsbc)
      common /csbc3/ asegs, asege, afirst, alast 
c
c====================== include file "switch.h" ========================
c
c     all time dependent decisions are made by time manager "tmngr.F"
c     and communicated elsewhere to the model via logical switches.
c
c     inputs: (defaulted in "blkdta.F", optionally reset via namelist)
c
c
c     runlen  = integration period (see rununits). note "runlen" should
c               be an integral number of density time steps. if not,
c               then "runlen" is automatically adjusted to insure this.
c               fractional days are supported but not fractional months
c               or years.
c     rununits= units of "runlen". may be "days", "months", or "years".
c               tmngr will convert "runlen" which is in "rununits"
c               to "rundays" in units of days.
c
c     segtim  = the integration time "runlen" is broken into a number of
c               segments each of length "segtim" days. updated surface
c               boundary conditions are applied to MOM every "segtim" 
c               days. this is useful when coupling to atmospheric models
c               in which case both models exchange surface boundary
c               conditions every "segtim" days where "segtim"
c               is 1/(coupling frequency). without an atmospheric model,
c               when getting surface boundary conditions from data, 
c               "segtim" is set to the time step (in days) by mom.F. in
c               either case, "runlen" (in days) should be an integral
c               number of "segtim".     
c
c     nmix    = number of time steps between mixing timesteps. used
c               to damp timestep splitting due to centered leapfrog.
c
c     init    = (true,false)  indicates that this run is a
c               (start from initial conditions, restart)
c
c     restrt  = (true,false) = (do,don`t) write a restart at the end
c               of the run
c
c     eb      = (true,false) configures for the use of a 
c               (euler backward,forward) type mixing timestep
c
c-----------------------------------------------------------------------
c     inputs to tmngr.F: diagnostic intervals
c-----------------------------------------------------------------------
c
c     note: switches are used to control the interval between doing
c           diagnostics. units for all switches are in days. 
c           setting a switch < 0.0 disables whatever the switch is 
c           controlling. setting it = 0.0 causes the diagnostic to be 
c           done every time step, and setting it > 0.0 causes the 
c           diagnostic to be done repeatedly on the specified interval. 
c
c     cmixint = number of days between writing estimated mixing coeffs
c               on faces of T cells and U cells
c
c     crossint = number of days between writing diapycnal and isopycnal
c               components of flow
c
c     fctint = number of days between writing difference between 
c              FCT and leapfrog advection
c
c     densityint = number of days between writing density
c
c     exconvint = number of days between writing temperature rate of
c                 change due to explicit convection
c
c     glenint =  number of days between global energetics integrals.
c
c     trmbint =  number of days between momentum and tracer term
c                balances (global and regional).
c
c     itrmb   = (true,false) = (do,don`t) write regional mask info for
c               the term balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     gyreint =  number of days between calculation of tracer northward
c                transport.
c     igyre   = (true,false) = (do,don`t) write regional mask info for
c               the gyre diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     vmsfint =  number of days between calculation of vertical and
c                meridional stream function.
c
c     tyzint  =  number of days between calculation of zonally averaged
c                tracer components.
c
c     prxzint =  number of days between printouts of x-z data.
c
c     extint  =  number of days between printouts of external mode.
c
c     dspint  =  number of days between surface pressure calculation.
c                Note: only when "diagnostic_surface_height" is enabled.
c     dspper  = averaging period for "diagnostic_surface_height"
c
c     tavgint = number of days between regional tracer averages (under
c               horizontal regions).
c
c     itavg   = (true,false) = (do,don`t) write regional mask info for
c               the tracer average diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     tmbint  = number of days over which tracer equation in averaged
c               in depth and longitude to determine the meridional 
c               balance among storage, divergence, dissipation and 
c               forcing.
c     tmbper  = averaging period for "meridional_tracer_balance"
c
c     itmb    = (true,false) = (do,don`t) write "msktmb" for tracer
c               the meridional balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c
c     tsiint  = number of days between printing of time step integrals.
c
c     stabint = number of days between sampling for various stability
c               criteria.
c
c     snapint = number of days between writing instantaneous samples
c               of data from the MOM grid. note: only when "snapshots"
c               is enabled. see "iounit.h" for more details.
c               all data is at time level "tau" so it is one time step
c               before the date shown in "stamp".
c
c     timavgint= interval (days) for writing time mean data from
c               the "averaging" grid (only when "time_averages" is
c               enabled). if "timavgint" is not an integral number of
c               density time steps,"timavgint" is automatically adjusted
c               to insure this. if the number of days to integrate is
c               not an integral number of "timavgint" then the last
c               averaging period will be less than "timavgint" days.this 
c               may lead to one more averaging period than expected. 
c               see "iounit.h" for more details.
c     timavgper= averaging period for "time_averages"
c
c     xbtint  = averaging period (days) for writing XBT data (only when
c               "xbts" is enabled). if "xbtint" is not an integral
c               number of density time steps, "xbtint" is automatically
c               adjusted to insure this. if the number of days to 
c               integrate is not an integral number of "xbtint" then the
c               last averaging period will be less than "xbtint" days.
c               this may lead to one more averaging period than  
c               expected. see "iounit.h" for more details.
c     xbtper  = averaging period for "xbts"
c
c     zmbcint = number of days between calculation of zonal mean
c               surface boundary conditions (and related  quantities)
c
c     trajint = number of days between writing particle trajectories.
c               particle trajectories are always written on the last
c               time step of the run to allow for restarting.
c
c-----------------------------------------------------------------------
c     outputs from tmngr.F: logical switches
c-----------------------------------------------------------------------
c
c     rundays = integration time in days (from "runlen")
c
c     the following are logical counterparts to the above switches are 
c     set within "tmngr" every time step. logical switches control all
c     decisions about when to do things in MOM.
c
c     cmixts  = (false,true) = (don`t, do) do write estimated mixing
c               coefficients on this time step.
c               based on "cmixint".
c
c     crossts  = (false,true) = (don`t, do) write diapycnal and 
c               isopycnal components of flow on this time step.
c               based on "crossint".
c
c     fctts    = (false,true) = (don`t, do) write difference between 
c               FCT and leapfrog advection on this time step.
c               based on "fctint".
c
c     densityts  = (false,true) = (don`t, do) write density on this time
c               step. based on "densityint".
c               
c
c     exconvts  = (false,true) = (don`t, do) do write temperature change
c               due to explicit convection on this time step.
c               based on "exconvint".
c
c     glents  = (false,true) = (don`t, do) do calculation of global
c               energy integrals on this time step. based on "glenint".
c
c     trmbts  = (false,true) = (don`t, do) do calculation of momentum &
c               tracer term balance on this timestep. based on "trmbint"
c
c     gyrets  = (false,true) = (don`t, do) do calculation of tracer
c               northward transport on this timestep. based on "gyreint"
c
c     vmsfts  = (false,true) = (don`t, do) do calculation of vertical
c               and meridional stream function on this time step.
c               based on "vmsfint"
c
c     tyzts   = (false,true) = (don`t, do) do calculation of zonally
c               averaged tracer components on this time step.
c               based on "tyzint"
c
c     prxzts  = (false,true) = (don`t, do) do printouts of x-z data
c               on this time step. based on "prxzint"
c
c     extts  = (false,true) = (don`t, do) do printout of external mode
c               on this time step. based on "extint"
c
c     dspts  = (false,true) = (don`t, do) do calculation of diagnostic 
c              surface pressure on this time step. based on "dspint"
c               
c
c     stabts  = (false,true) = (don`t, do) test for stability on this
c               time step. based on "stabint"
c
c     tavgts  = (false,true) = (don`t do) do tracer averages on this
c               time step. based on "tavgint"
c
c     tmbts   = (false,true) = (don`t, do) write out tracer meridional .
c               balance on this time step. based on "tmbint"
c
c     tsits   = (false,true) = (don`t, do) print time step integrals
c               on this time step. based on "tsiint"
c
c     zmbcts  = (false,true) = (don`t, do) print zonal mean boundary
c               conditions on this time step.  based on "zmbcint"
c
c     trajts  = (false,true) = (don`t, do) print particle trajectories
c               on this time step. based on "trajint"
c
c     snapts  = (false,true) = (don`t, do) save a snapshot of the data
c               on this time step. based on "snapint"
c
c     timats  = (false,true) = (don`t, do) write time mean data
c               on this time step. based on "timavgint"
c                                          
c     xbtts   = (false,true) = (don`t, do) write averaged XBT data on
c               this time step based on "xbtint"
c
c
c     leapfrog= (false,true) on a (mixing, normal leapfrog) time step
c                based on "nmix"
c                                          
c     euler1  = true on the 1st pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     euler2  = true on the 2nd pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     forward = true on a forward time step. otherwise false
c		(applies when "eb" = false)		  
c                                          
c
c     the following logical switches are based on the model time step. 
c    
c     first   = (true,false) =  when it`s (the first, not the first)
c                               time step of a run
c     eots    = end of a time step. always true except for first
c               pass of an euler backward time step
c     eorun   = last time step of a run. always false except during the
c               last time step of the run.
c
c     eoday   = true when within 1/2 time step of the end of a day
c               else ... false
c     eoweek  = true when within 1/2 time step of the end of a 7 day
c               week (referenced to the start of a year) else ...false
c     eo2wks  = true when within 1/2 time step of the end of two weeks
c               (referenced to the start of a year) else ... false
c     midmon  = true when within 1/2 time step of the middle of a month
c               else ... false
c     eomon   = true when within 1/2 time step of the end of a month
c               else ... false
c     eoyear  = true when within 1/2 time step of the end of a year
c               else ... false
c     osegs   = true on the 1st time step of an ocean segment in mom.F
c               otherwise false.
c     osege  =  true on the last time step of an ocean segment in mom.F
c               otherwise false.
c
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c
c
      logical eb, leapfrog, euler1, euler2, forward, eots
      logical init, first, restrt
      logical itavg, itmb, itrmb, igyre
      character *8 rununits
c
      common /switcc/ rununits
      common /switcr/ runlen, rundays
      common /switci/ nmix
      common /switcl/ eb, leapfrog, euler1, euler2, forward, eots
      common /switcl/ init, first, restrt
      common /switcl/ itavg, itmb, itrmb, igyre
c
      logical          eoday, eoweek, eo2wks
      common /switci/ ieoday,ieoweek,ieo2wks
      common /switcl/  eoday, eoweek, eo2wks
c
      logical          eomon, midmon, eoyear, eorun
      common /switci/ ieomon,imidmon,ieoyear,ieorun
      common /switcl/  eomon, midmon, eoyear, eorun
c
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c     each interval switch needs three variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output (e.g,.  glenint)
c         2) a switch (logical) for the interval (e.g.,  glents )
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c         3) an index (integer)                       (e.g., iglenint)
c
c     the user must specify the interval [e.g., glenint] for diagnostic
c     output in units of days. tmngr sets the corresponding logical  
c     switch [e.g., glents] every time step. It is set to true when  
c     within half a time step of the requested interval, otherwise it is
c     false. All decisions relating to the interval [e.g., glenint]
c     are based on the logical switch [e.g., glents].
c           
c     internal time structures
c
c     The switch index [e.g., iglenint] is used to subsrcipt into  
c     internal arrays maintained by tmngr.F. The switch index is
c     allocated on the first call to function "alarm".
c     The array entry [e.g., iinterval(iglenint)] is a time index to the
c     internal representation of the interval [e.g., glenint].
c     The array entry [e.g., ialarm(iglenint)] is a time index to the
c     next time the alarm will be true.
c-----------------------------------------------------------------------
c
      logical           tavgts,    glents,    trmbts,   prxzts
      common /switcr/   tavgint,   glenint,   trmbint,  prxzint
      common /switci/  itavgint,  iglenint,  itrmbint, iprxzint
      common /switcl/   tavgts,    glents,    trmbts,   prxzts
c
      logical          extts,   trajts,   exconvts,   cmixts
      common /switcr/  extint,  trajint,  exconvint,  cmixint
      common /switci/ iextint, itrajint, iexconvint, icmixint
      common /switcl/  extts,   trajts,   exconvts,   cmixts
c
      logical          vmsfts,   gyrets,    tsits,   snapts,   fctts
      common /switcr/  vmsfint,  gyreint,   tsiint,  snapint,  fctint
      common /switci/ ivmsfint, igyreint,  itsiint, isnapint, ifctint
      common /switcl/  vmsfts,   gyrets,    tsits,   snapts,   fctts
c
      logical          tyzts
      common /switcr/  tyzint
      common /switci/ ityzint
      common /switcl/  tyzts
c
      logical          stabts,   zmbcts,   crossts,   densityts
      common /switcr/  stabint,  zmbcint,  crossint,  densityint
      common /switci/ istabint, izmbcint, icrossint, idensityint
      common /switcl/  stabts,   zmbcts,   crossts,   densityts
c
      logical          osegs,  osege
      common /switcr/          segtim
      common /switci/ iosegs, iosege
      common /switcl/  osegs,  osege
c   
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c              A N D   A V E R A G I N G   P E R I O D
c
c     each averaging period switch needs five variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output    (e.g. xbtint  )   
c         2) a switch (logical) for the interval         (e.g. xbtts   )
c         3) an averaging period (real)                  (e.g. xbtper  )   
c         4) a switch (logical) for accumulating         (e.g. xbtperts)
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switches
c
c         5) an index (integer)                         (e.g. ixbtint  )
c
c     The user must specify the interval [e.g., xbtint] for diagnostic
c     output in units of days and the averaging period [e.g., xbtper] 
c     in units of days. The averaging period may be less than or equal
c     to the interval. For example, if the interval is 30.0 days and the
c     averaging period is 5.0 days, results will be averaged over all
c     time steps within days 26, 27, 28, 29, and 30.  An averaging period
c     of 0.0 days averages over the last time step of the interval (as
c     does xbtper = dt), and an averaging period less than zero turns
c     the switches off for all time steps.  
c
c     The logical switch for writing output at the specified interval 
c     [e.g., xbtts] is set to true on the last time step of the 
c     averaging period. The logical switch for accumulating results
c     [e.g., xbtperts] is true for all time steps within the averaging
c     period, otherwise it is false. 
c
c     internal time structures
c
c     The index [e.g., ixbtint] is allocated on the first call to 
c     function "avg_alarm". The array element iperiod(ixbtint) is an
c     index to the time structure for the internal representation of 
c     "xbtper", and ilastsw(ixbtint) is the index of the switch that 
c     flags the last time step of the accumulation period.
c     Depending on use,  ilastsw(ixbtint) may either be the index
c     of another "named" switch or the index of a new switch
c     allocated on the first time step.
c     In the latter case, iinterval(ilastsw(ixbtint)) is the index of
c     the time structure where "xbtint" is stored in internal form,
c     and ialarm(ilastsw(ixbtint)) is the index of the time when an
c     accumulation period will next end.
c     The variable nextts(ixbtint) is true whenever the next
c     time step will begin the accumulation period.
c
c-----------------------------------------------------------------------
c
      logical         xbtts,     dspts,    tmbts,    timavgts
      logical         xbtperts,  dspperts, tmbperts, timavgperts
      common /switcr/ xbtint,    dspint,   tmbint,   timavgint
      common /switcr/ xbtper,    dspper,   tmbper,   timavgper
      common /switci/ixbtint,   idspint,  itmbint,  itimavgint
      common /switcl/ xbtts,     dspts,    tmbts,    timavgts
      common /switcl/ xbtperts,  dspperts, tmbperts, timavgperts
c
c-----------------------------------------------------------------------
c
c                 S W I T C H E S    B A S E D    O N    
c
c         C A L E N D A R   O R    P R E V I O U S    S W I T C H   
c
c               A N D   A V E R A G I N G    P E R I O D
c
c    
c
c     the following logical switches are based on any calendar or 
c     interval switch and an averaging period (in days). The  averaging
c     period must be less than or equal to the interval. The last
c     time step of the averaging period is at the end of the interval.
c     If the averaging period is set to zero, the averaging period
c     consists only of the last time period of the interval.  If
c     the averaging period is less than zero, these switches are always
c     false.
c
c     each averaging period switch needs four variables in common. For
c     example, if the averaging period is before the end of each month
c     then the calendar switch (eomon), and index (ieomon) are presumed
c     to exist in common and need not be added.
c     
c     Additionally, four items are needed.
c
c       1) an averaging period (real)                  (e.g.  testper  )   
c       2) a switch (logical) for accumulating results (e.g.  testperts)
c       3) a switch (logical) for the end of interval  (e.g.  testts   )
c
c     the fourth is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c       4) an index (integer)                          (e.g.  itestper )
c
c     Suppose it is required to produce averages over all time steps
c     during the last 5 days of each month. Then "testper" = 5.0 and 
c     the following will calculate the accumulating switch.
c
c      testts = avg_alarm(itestper, ihalfstep, 0, testper, iref, ieomon)
c      testperts = on(itestper)
c
c     Note the use of "ieomon" to key off the months.  The switch
c     "testts" will be true whenever "eomon" is true.
c     Also note that when an averaging switch is keyed off another
c     switch, the switch inverval argument is not used, but is 
c     retained for consistency with the form of other averaging
c     switches.
c-----------------------------------------------------------------------
c
      logical           testperts
      logical           testts
      common /switcr/   testint
      common /switcr/   testper
      common /switci/  itestper
      common /switcl/   testts
      common /switcl/   testperts

c
      parameter (maxsw=100)
      logical          on, lastts, nextts
      common /switci/  nsw  
      common /switci/  ialarm(maxsw), iinterval(maxsw), iperiod(maxsw)
     &,                ilastsw(maxsw)
      common /switcl/  on(maxsw), lastts(maxsw), nextts(maxsw)
c
c
c
c-----------------------------------------------------------------------
c     do consistency checks before allowing model to continue
c-----------------------------------------------------------------------
c
      errorc = .false.
      write (stdout,*) ' '
      write (stdout,*) '    (checking MOM S.B.C. setup)'
c

      if (dtatm .eq. c0) then
          write (stdout,9000)
     & '==> Error: the atmospheric time step must be set in "setatm"  '
          errorc = .true.
          dtatm = 1.e-6
      endif
c      critv = 1.e-6
      critv = 1.e-4
      if (segtim .ne. c0) then
        r1 = rundays/segtim
      else
        r1 = 0.5
      endif
      r2 = segtim/(dtts*secday)
      r3 = segtim/(dtatm*secday)
      if (segtim .eq. c0) then
          write (stdout,9000)
     & '==> Error: coupling period "segtim" must be specified when    '
     &,'   the "coupled" option is enabled                            '
          errorc = .true.
      elseif (abs(r1-nint(r1)) .gt. critv) then
          write (stdout,9000)
     & '==> Error: there must be an integral number of segments       '
     &,'    "segtim"  within "rundays" (the length of the run)        '
          errorc = .true.
      elseif (abs(r2-nint(r2)) .gt. critv) then
          write (stdout,9000)
     & '==> Error: there must be an integral number of density time   '
     &,'    steps "dtts"  within "segtim" (the segment time)          '
          errorc = .true.
      elseif (abs(r3-nint(r3)) .gt. critv) then
          write (stdout,9000)
     & '==> Error: there must be an integral number of atmos time     '
     &,'    steps "dtatm"  within "segtim" (the segment time)         '
          errorc = .true.
      endif



      if (numsbc .gt. maxsbc) then
        write (stdout,9000) 
     & '==> Error: "numsbc" is greater than "maxsbc" in "csbc.h"      '
        errorc = .true.
      endif
      write (stdout,*) '    (End of MOM S.B.C. checks) '
      write (stdout,*) ' '
      if (errorc) stop '=>chkcpl'
c
9000  format (/,(1x,a80))
      return
      end

      block data blkdta

c===================== include file "embmdata.h" =======================
c
c     blkdta for the energy-moisture balance model
c
c====================== include file "cembm.h" =========================
c
c     parameters for use in the energy balance model (also see atm.h)
c
c     addflux		= logical flag for adding only even mode fluxes
c     nats		= number of atmospheric time steps since mixing
c     namix		= time steps between mixing (set in atmos.in)
c     lf		= time step flag (1=>leapfrog, 2=>forward)
c     pyear		= calendar year (set in atmos.in, -/+ = BC/AD)
c     dtatm 		= time step for atmosphere (set in atmos.in)
c     dts		= time step (2*dtatm=>leapfrog, dtatm=>forward)
c     co2ccn		= CO2 concentration
c     anthro		= radiative forcing by CO2
c     co2ccni		= initial CO2 concentration
c     co2yri		= last year of initial CO2 concentration
c     co2ccnf		= final CO2 concentration
c     co2yrf		= first year of final CO2 concentration
c     solarconst	= solar constant (g/s**3)
c     ssp		= sea surface pressure (g/cm/s**2)
c     cdatm 		= drag coefficient (dimensionless)
c     cpatm		= atmospheric heat capacity (cm**2/s**2/K)
c     ht		= scale height for temperature
c     hq		= scale height for specific humidity
c     rhoatm		= density of air at sea surface (g/cm**3)
c     rhoocn		= representative sea surface density
c     esocn		= ocean emissivity times Stefan's constant 
c     vlocn		= latent heat of vaporization of water
c     socn		= constant ocean salinity
c     cdice 		= drag coefficient (dimensionless)
c     rhoice		= ice density (g/cm**3)
c     esice		= ice emissivity times Stefan's constant 
c     slice		= latent heat of sublimation of ice
c     flice		= latent heat of fusion of ice (cm**2/s**2)
c     condice		= ice conductivity (g*cm/s**3/K)
c     kadv		= time step divider for ice advection
c     ntats		= time step counter for time averaging
c     avetime		= time for averaging fluxes
c     totaltime		= total time for long term averages
c
      logical addflux
c
      common /cembm/ addflux
      common /cembm/ nats, namix, lf, kadv, ntats
      common /cembm/ pyear, dtatm, dts, co2ccn, anthro, co2ccni, co2yri
     &,              co2ccnf, co2yrf, solarconst, ssp, cdatm, cpatm, ht
     &,              hq, rhoatm, rhoocn, esocn, vlocn, socn, cdice
     &,              rhoice, esice, slice, flice, condice, avetime 
     &,              totaltime
c
c=================== include file "insolation.h" =======================
c
c     note: this solution of berger 1978 is valid only for 1,000,000 
c           years centered on present-day. for longer period the 
c           solution 1990 must be used (contact Berger for this)                
c                                                              
c                                                              
c     refer to :                                      
c     Berger A. 1978. a simple algorithm to compute long term
c                     variations of daily or monthly insolation
c                     contr. 18  Inst of Astronomy and Geophysics
c                     Universite Catholique de Louvain
c                     Louvain-la-Neuve  Belgium              
c                                                                 
c     Berger A. 1978. long term variations of daily insolation 
c                     and quaternary climatic changes
c                     J. of Atmospheric Sciences  35  2362-2367
c                              
c     nef  nob  nop have been reduced to  19  18  9  
c 
c     these are the expansion coefficients for minimal efficiency, they 
c     can be increased by referring to Berger, 1978:
c     eccentricity           ecc   table 1
c     obliquity              xob   table 2
c     longitude perihelion   perh  table 3
c                    
      parameter	(nef=19, nob=18, nop=9)
c
      real ae(nef), be(nef), ce(nef), ye(nef), ze(nef)
     &,	   aob(nob), bob(nob), cob(nob), yob(nob), zob(nob)
     &,	   aop(nop), bop(nop), cop(nop), yop(nop), zop(nop)
c
      common /insol/ ae, be, ce, ye, ze, aob, bob, cob, yob, zob
     &,              aop, bop, cop, yop, zop, pir, pirr, step
     &,              test, xod, xop, prm, nd, ecc, perh, pre, xob




c
      data namix 	/15/
      data pyear 	/1997.0/
      data dtatm 	/21600/
      data co2ccn 	/350.0/
      data solarconst 	/1.368e6/
c
      data ssp 		/1.0e6/
      data cdatm 	/1.0e-3/
      data cpatm 	/1.004e7/
      data ht 		/8.4e5/
      data hq 		/1.8e5/
      data rhoatm 	/1.250e-3/
c
      data rhoocn 	/1.035/
      data esocn 	/5.347e-5/
      data vlocn 	/2.501e10/
      data socn 	/34.9e-3/
c
      data cdice 	/5.5e-3/
      data rhoice 	/0.913/
      data esice 	/5.347e-5/
      data slice 	/2.835e10/
      data flice 	/3.34e9/
      data condice 	/2.1656e5/
      data kadv 	/1/
c
c     coefficients for solution of eccentricity
c
      data ae / 0.01860798, 0.01627522, -.01300660,
     &  0.00988829, -.00336700, 0.0033077, -.00235400,
     &  0.00140015, 0.00100700, 0.00085700, 0.00064990,
     &  0.00059900, 0.00037800, -.00033700, 0.00027600,
     &  0.00018200, -.00017400, -.00012400, 0.00001250 /
c
      data ye / 4.2072050, 7.3460910, 17.8572630,
     &  17.2205460, 16.8467330, 5.1990790, 18.2310760,
     &  26.2167580, 6.3591690, 16.2100160, 3.0651810,
     &  16.5838290, 18.4939800, 6.1909530, 18.8677930,
     &  17.4255670, 6.1860010, 18.4174410, 0.6678630 /
c
      data ze / 28.620089, 193.788772, 308.307024,
     &  320.199637, 279.376984, 87.195000, 349.129677,
     &  128.443387, 154.143880, 291.269597, 114.860583,
     &  332.092251, 296.414411, 145.769910, 337.237063,
     &  152.092288, 126.839891, 210.667199, 72.108838 /
c
c     coefficients for solution of obliquity
c
      data aob / -2462.2214466, -857.3232075, -629.3231835,
     &  -414.2804924, -311.7632587, 308.9408604, -162.5533601,
     &  -116.1077911, 101.1189923, -67.6856209, 24.9079067,
     &  22.5811241, -21.1648355, -15.6549876, 15.3936813,
     &  14.6660938, -11.7273029, 10.2742696 /
c
      data yob / 31.609974, 32.620504, 24.172203,
     &  31.983787, 44.828336, 30.973257, 43.668246,
     &  32.246691, 30.599444, 42.681324, 43.836462,
     &  47.439436, 63.219948, 64.230478, 1.010530,
     &  7.437771, 55.782177, 0.373813 /
c
      data zob / 251.9025, 280.8325, 128.3057,
     &  292.7252, 15.3747, 263.7951, 308.4258, 240.0099,
     &  222.9725, 268.7809, 316.7998, 319.6024, 143.8050,
     &  172.7351, 28.9300, 123.5968, 20.2082, 40.8226 /
c
c       coefficients for solution of precession
c
      data aop / 7391.0225890, 2555.1526947, 2022.7629188,
     &  -1973.6517951, 1240.2321818, 953.8679112, -931.7537108,
     &  872.3795383, 606.3544732 /
c
      data yop / 31.609974, 32.620504, 24.172203,
     &  0.636717, 31.983787, 3.138886, 30.973257,
     &  44.828336, 0.991874 /
c
      data zop / 251.9025, 280.8325, 128.3057, 348.1074,
     &  292.7252, 165.1686, 263.7951, 15.3747, 58.5749 /
c
c

      end
      subroutine sumflux
c
c=======================================================================
c     sum fluxes over atmospheric time steps
c     based on code by a.fanning
c
c     author:   m.eby   e-mail: eby@uvic.ca
c=======================================================================
c

c====================== include file "param.h" =========================
c
c     main parameter file which sets ocean characteristics:
c
c     "size.h" sets model size "imt", "jmt", and "km"
c
c====================== include file "size.h" ==========================
c                                                                       
c-----------------------------------------------------------------------
c     USER INPUT: 
c-----------------------------------------------------------------------
c
c     imt    = number of grid points in the longitudinal direction
c              (calculated points are from 2 through imt-1. End points
c               are boundaries)          
c
c     jmt    = number of grid points (latitude rows) in the latitudinal
c              direction (calculated points are from 2 through jmt-1.           
c              End points are boundaries)   
c                                
c     km     = number of grid points in the vertical direction          
c              (calculated points are from 1 through km)
c
c     nt     = number of tracers (temperature, salinity, ...)
c
c     mnisle = maximum number of islands (unconnected land masses)
c
c     maxipp = maximum number of all island perimeter points
c-----------------------------------------------------------------------
c                                                                       
      parameter (imt=  92, jmt=  61, km= 15)
      parameter (nt=2)
      parameter (nat=2)
      parameter (mnisle=50, maxipp=5000)
c

c






c
c-----------------------------------------------------------------------
c     END USER INPUT
c-----------------------------------------------------------------------
c                                                                       
c-----------------------------------------------------------------------
c     By default, the MW (memory window) is 2nd order except for the
c     following options which require a 4th order MW 
c
c     for 2nd order schemes, the minimum sized MW is 3 latitude rows
c     for 4th order schemes, the minimum sized MW is 4 latitude rows
c                            (5 if using coarse_grained_parallelism)
c-----------------------------------------------------------------------
c













c
c-----------------------------------------------------------------------
c     set MW (memory window) size "jmw" 
c-----------------------------------------------------------------------
c                                                                       

c
c     for UNI-TASKING: "jmw" is set to the minimum for each option class 
c     "jmw" may be increased up to "jmt" 
c

      parameter (jmw=jmt)


c
c-----------------------------------------------------------------------
c     set first and last calculated row within the MW. other rows
c     are used as buffers
c-----------------------------------------------------------------------
c
c     jsmw   = 1st calculated row within the MW     
c     jemw   = last calculated row within the MW
c
      parameter (jsmw=2, jemw=jmw-1)
c
c
c     jextra = extra buffer rows needed for coarse_grained_parallelism.
c              "jextra" rows are added to the top and bottom of the MW
c              so the MW size increases by 2*jextra       
c

          parameter (jextra = 0)




c
c     nvar   = number of prognostic variables
c     lseg   = maximum number of longitudinal stream function segments
c     nlatpr = maximum number of latitudes for matrix printouts
c              on diagnostic time steps
c     nhreg  = number of regions in the horizontal used for averaging
c              tracers.
c     nvreg  = number of regions in the vertical used for term balance
c              calculations. note "nvreg" isn`t used for tracer averages
c     numreg = total number of regions ( = product of nhreg & nvreg)
c              used for term balance calculations
c
      parameter (lseg=5, nlatpr=10)

      parameter (nhreg=5, nvreg=2, numreg=nhreg*nvreg)

      parameter (nvar=nt+2)
c

c
      parameter (imtm1=imt-1, kmm1=km-1)                                
      parameter (imtp1=imt+1, imtm2=imt-2
     &,          jmtp1=jmt+1, jmtm1=jmt-1, jmtm2=jmt-2

     &,          jscan=jmtm2

     &,          kmp1=km+1, kmp2=km+2
     &,          imtkm=imt*km, nwds=imt*jmt, nkflds=2
     &,          nslab=imt*nvar*km, ntmin2=nt+1/nt)
c
c     include parameter constants
c
c====================== include file "pconst.h" ========================
c
c
c     rules for parameter constants
c
c     use prefix of "c" for whole real numbers (eg: c57 for 57.0)
c     use "m" after prefix to designate negative values (minus sign)
c       (eg: cm7 for -7.0)
c     use prefix of "p" for non repeating fractions (eg: p5 for 0.5)
c     use prefix of "r" for reciprocals (eg: r3 for 1/3.0)
c     combine use of prefix above and "e" for scientific notation, with
c       (eg: c5e4 for 5.0e4, c1em10 for 1.0e-10)
c
      parameter (c0=0.0, c1=1.0, c2=2.0, c3=3.0, c4=4.0, c5=5.0, c7=7.0)
      parameter (c8=8.0)
      parameter (c14=14.0, c16=16.0, c360=360.0)
      parameter (p125=0.125, p25=0.25, p5=0.5, p75=0.75)
      parameter (epsln=1.0e-20)
c
      parameter (c24=24.0, c60=60.0, c1440=1440.0)
      parameter (r24=c1/c24, r60=c1/c60, r1440=c1/c1440)
      parameter (secday=c1/(c60*c1440))
c
c     include standard I/O units
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c
c     ncrows = number of calculated rows within the MW.
c              (the remaining rows are buffer rows). 
c


      parameter (ncrows = jmw - 2)


c====================== include file "cembm.h" =========================
c
c     parameters for use in the energy balance model (also see atm.h)
c
c     addflux		= logical flag for adding only even mode fluxes
c     nats		= number of atmospheric time steps since mixing
c     namix		= time steps between mixing (set in atmos.in)
c     lf		= time step flag (1=>leapfrog, 2=>forward)
c     pyear		= calendar year (set in atmos.in, -/+ = BC/AD)
c     dtatm 		= time step for atmosphere (set in atmos.in)
c     dts		= time step (2*dtatm=>leapfrog, dtatm=>forward)
c     co2ccn		= CO2 concentration
c     anthro		= radiative forcing by CO2
c     co2ccni		= initial CO2 concentration
c     co2yri		= last year of initial CO2 concentration
c     co2ccnf		= final CO2 concentration
c     co2yrf		= first year of final CO2 concentration
c     solarconst	= solar constant (g/s**3)
c     ssp		= sea surface pressure (g/cm/s**2)
c     cdatm 		= drag coefficient (dimensionless)
c     cpatm		= atmospheric heat capacity (cm**2/s**2/K)
c     ht		= scale height for temperature
c     hq		= scale height for specific humidity
c     rhoatm		= density of air at sea surface (g/cm**3)
c     rhoocn		= representative sea surface density
c     esocn		= ocean emissivity times Stefan's constant 
c     vlocn		= latent heat of vaporization of water
c     socn		= constant ocean salinity
c     cdice 		= drag coefficient (dimensionless)
c     rhoice		= ice density (g/cm**3)
c     esice		= ice emissivity times Stefan's constant 
c     slice		= latent heat of sublimation of ice
c     flice		= latent heat of fusion of ice (cm**2/s**2)
c     condice		= ice conductivity (g*cm/s**3/K)
c     kadv		= time step divider for ice advection
c     ntats		= time step counter for time averaging
c     avetime		= time for averaging fluxes
c     totaltime		= total time for long term averages
c
      logical addflux
c
      common /cembm/ addflux
      common /cembm/ nats, namix, lf, kadv, ntats
      common /cembm/ pyear, dtatm, dts, co2ccn, anthro, co2ccni, co2yri
     &,              co2ccnf, co2yrf, solarconst, ssp, cdatm, cpatm, ht
     &,              hq, rhoatm, rhoocn, esocn, vlocn, socn, cdice
     &,              rhoice, esice, slice, flice, condice, avetime 
     &,              totaltime
c
c====================== include file "atm.h" ===========================
c
c     arrays for the energy-moisture balance model
c
c     note: units for heat flux are in g/cm**2/s**3/cm**2 or (mW/m**2)
c           units for fresh water flux are in cm/s
c           downward is into the surface (ocean, ice or land)
c           upward is into the bottom of the atmosphere
c           outward is out of the top of the atmosphere
c           inward is into the top of the atmosphere
c
c     outlwr(imt,jmt)	 = outgoing atmosphere longwave flux
c     at(imt,jmt,2,nat)	 = tracers (previous and most recent)
c     surf(imt,jmt,nat)	 = surface values (1=temperature, 2=humidity)
c     flux(imt,jmt,nat)	 = downward flux (1=heat, 2=fresh water)
c     precip(imt,jmt)	 = precipitation
c     evap(imt,jmt)	 = evaporation
c     dnswr(imt,jmt)  	 = downward surface shortwave flux
c     uplwr(imt,jmt)  	 = upward surface longwave flux
c     upsens(imt,jmt)	 = upward surface sensible heat flux
c     upltnt(imt,jmt)    = upward surface latent heat flux
c     ssh(imt,jmt) 	 = saturation specific humidity
c     spd(imt,jmt) 	 = wind speed (cm/sec)
c     da(jmt,nat)	 = tracer diffusivity parameterization
c     coalbedo(jmt)	 = planetary coalbedo
c     solins(jmt)	 = solar insolation (units of solarconst)
c     esatm(jmt)	 = atmosphere emissivity times Stefan's constant
c     scatter(jmt)	 = solar scattering into atmosphere





c     cori(jmt,2)	 = Coriolis parameter

c
      real outlwr(imt,jmt), at(imt,jmt,3,nat), surf(imt,jmt,nat)
      real flux(imt,jmt,nat), precip(imt,jmt), evap(imt,jmt)
      real dnswr(imt,jmt), uplwr(imt,jmt), upsens(imt,jmt)
      real upltnt(imt,jmt), ssh(imt,jmt), spd(imt,jmt), da(jmt,nat)
      real coalbedo(jmt), solins(jmt), esatm(jmt), scatter(jmt)





      real cori(jmt,2)
c
      common /atm/ outlwr, at, surf, flux, precip, evap, dnswr, uplwr
     &,            upsens, upltnt, spd, ssh, da, coalbedo, solins
     &,            esatm, scatter





     &,            cori
c
c====================== include file "levind.h" ========================
c
c     vertical level indicators which define model geometry & bottom
c     topography:
c
c     kmt = number of vertical boxes over "t" points
c     kmu = number of vertical boxes over "u,v" points
c
      common /levind/ kmt(imt,jmt), kmu(imt,jmt)
c

      dta = dtatm

      do j = 2,jmtm1
        do i = 2,imtm1
          if (kmt(i,j) .gt. 0) then
            flux(i,j,1) = flux(i,j,1) + dts*(dnswr(i,j) - uplwr(i,j) 
     &                  - upltnt(i,j) - upsens(i,j))
	    flux(i,j,2) = flux(i,j,2) + dts*(precip(i,j) - evap(i,j))
	  endif



	enddo
      enddo
c

      avetime = avetime + dts
c
      return
      end





      subroutine aveflux
c
c=======================================================================
c     calculate the average fluxes for next ocean time step
c     based on code by a.fanning
c
c     author:   m.eby   e-mail: eby@uvic.ca
c=======================================================================
c
c====================== include file "param.h" =========================
c
c     main parameter file which sets ocean characteristics:
c
c     "size.h" sets model size "imt", "jmt", and "km"
c
c====================== include file "size.h" ==========================
c                                                                       
c-----------------------------------------------------------------------
c     USER INPUT: 
c-----------------------------------------------------------------------
c
c     imt    = number of grid points in the longitudinal direction
c              (calculated points are from 2 through imt-1. End points
c               are boundaries)          
c
c     jmt    = number of grid points (latitude rows) in the latitudinal
c              direction (calculated points are from 2 through jmt-1.           
c              End points are boundaries)   
c                                
c     km     = number of grid points in the vertical direction          
c              (calculated points are from 1 through km)
c
c     nt     = number of tracers (temperature, salinity, ...)
c
c     mnisle = maximum number of islands (unconnected land masses)
c
c     maxipp = maximum number of all island perimeter points
c-----------------------------------------------------------------------
c                                                                       
      parameter (imt=  92, jmt=  61, km= 15)
      parameter (nt=2)
      parameter (nat=2)
      parameter (mnisle=50, maxipp=5000)
c

c






c
c-----------------------------------------------------------------------
c     END USER INPUT
c-----------------------------------------------------------------------
c                                                                       
c-----------------------------------------------------------------------
c     By default, the MW (memory window) is 2nd order except for the
c     following options which require a 4th order MW 
c
c     for 2nd order schemes, the minimum sized MW is 3 latitude rows
c     for 4th order schemes, the minimum sized MW is 4 latitude rows
c                            (5 if using coarse_grained_parallelism)
c-----------------------------------------------------------------------
c













c
c-----------------------------------------------------------------------
c     set MW (memory window) size "jmw" 
c-----------------------------------------------------------------------
c                                                                       

c
c     for UNI-TASKING: "jmw" is set to the minimum for each option class 
c     "jmw" may be increased up to "jmt" 
c

      parameter (jmw=jmt)


c
c-----------------------------------------------------------------------
c     set first and last calculated row within the MW. other rows
c     are used as buffers
c-----------------------------------------------------------------------
c
c     jsmw   = 1st calculated row within the MW     
c     jemw   = last calculated row within the MW
c
      parameter (jsmw=2, jemw=jmw-1)
c
c
c     jextra = extra buffer rows needed for coarse_grained_parallelism.
c              "jextra" rows are added to the top and bottom of the MW
c              so the MW size increases by 2*jextra       
c

          parameter (jextra = 0)




c
c     nvar   = number of prognostic variables
c     lseg   = maximum number of longitudinal stream function segments
c     nlatpr = maximum number of latitudes for matrix printouts
c              on diagnostic time steps
c     nhreg  = number of regions in the horizontal used for averaging
c              tracers.
c     nvreg  = number of regions in the vertical used for term balance
c              calculations. note "nvreg" isn`t used for tracer averages
c     numreg = total number of regions ( = product of nhreg & nvreg)
c              used for term balance calculations
c
      parameter (lseg=5, nlatpr=10)

      parameter (nhreg=5, nvreg=2, numreg=nhreg*nvreg)

      parameter (nvar=nt+2)
c

c
      parameter (imtm1=imt-1, kmm1=km-1)                                
      parameter (imtp1=imt+1, imtm2=imt-2
     &,          jmtp1=jmt+1, jmtm1=jmt-1, jmtm2=jmt-2

     &,          jscan=jmtm2

     &,          kmp1=km+1, kmp2=km+2
     &,          imtkm=imt*km, nwds=imt*jmt, nkflds=2
     &,          nslab=imt*nvar*km, ntmin2=nt+1/nt)
c
c     include parameter constants
c
c====================== include file "pconst.h" ========================
c
c
c     rules for parameter constants
c
c     use prefix of "c" for whole real numbers (eg: c57 for 57.0)
c     use "m" after prefix to designate negative values (minus sign)
c       (eg: cm7 for -7.0)
c     use prefix of "p" for non repeating fractions (eg: p5 for 0.5)
c     use prefix of "r" for reciprocals (eg: r3 for 1/3.0)
c     combine use of prefix above and "e" for scientific notation, with
c       (eg: c5e4 for 5.0e4, c1em10 for 1.0e-10)
c
      parameter (c0=0.0, c1=1.0, c2=2.0, c3=3.0, c4=4.0, c5=5.0, c7=7.0)
      parameter (c8=8.0)
      parameter (c14=14.0, c16=16.0, c360=360.0)
      parameter (p125=0.125, p25=0.25, p5=0.5, p75=0.75)
      parameter (epsln=1.0e-20)
c
      parameter (c24=24.0, c60=60.0, c1440=1440.0)
      parameter (r24=c1/c24, r60=c1/c60, r1440=c1/c1440)
      parameter (secday=c1/(c60*c1440))
c
c     include standard I/O units
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c
c     ncrows = number of calculated rows within the MW.
c              (the remaining rows are buffer rows). 
c


      parameter (ncrows = jmw - 2)


c====================== include file "cembm.h" =========================
c
c     parameters for use in the energy balance model (also see atm.h)
c
c     addflux		= logical flag for adding only even mode fluxes
c     nats		= number of atmospheric time steps since mixing
c     namix		= time steps between mixing (set in atmos.in)
c     lf		= time step flag (1=>leapfrog, 2=>forward)
c     pyear		= calendar year (set in atmos.in, -/+ = BC/AD)
c     dtatm 		= time step for atmosphere (set in atmos.in)
c     dts		= time step (2*dtatm=>leapfrog, dtatm=>forward)
c     co2ccn		= CO2 concentration
c     anthro		= radiative forcing by CO2
c     co2ccni		= initial CO2 concentration
c     co2yri		= last year of initial CO2 concentration
c     co2ccnf		= final CO2 concentration
c     co2yrf		= first year of final CO2 concentration
c     solarconst	= solar constant (g/s**3)
c     ssp		= sea surface pressure (g/cm/s**2)
c     cdatm 		= drag coefficient (dimensionless)
c     cpatm		= atmospheric heat capacity (cm**2/s**2/K)
c     ht		= scale height for temperature
c     hq		= scale height for specific humidity
c     rhoatm		= density of air at sea surface (g/cm**3)
c     rhoocn		= representative sea surface density
c     esocn		= ocean emissivity times Stefan's constant 
c     vlocn		= latent heat of vaporization of water
c     socn		= constant ocean salinity
c     cdice 		= drag coefficient (dimensionless)
c     rhoice		= ice density (g/cm**3)
c     esice		= ice emissivity times Stefan's constant 
c     slice		= latent heat of sublimation of ice
c     flice		= latent heat of fusion of ice (cm**2/s**2)
c     condice		= ice conductivity (g*cm/s**3/K)
c     kadv		= time step divider for ice advection
c     ntats		= time step counter for time averaging
c     avetime		= time for averaging fluxes
c     totaltime		= total time for long term averages
c
      logical addflux
c
      common /cembm/ addflux
      common /cembm/ nats, namix, lf, kadv, ntats
      common /cembm/ pyear, dtatm, dts, co2ccn, anthro, co2ccni, co2yri
     &,              co2ccnf, co2yrf, solarconst, ssp, cdatm, cpatm, ht
     &,              hq, rhoatm, rhoocn, esocn, vlocn, socn, cdice
     &,              rhoice, esice, slice, flice, condice, avetime 
     &,              totaltime
c
c====================== include file "atm.h" ===========================
c
c     arrays for the energy-moisture balance model
c
c     note: units for heat flux are in g/cm**2/s**3/cm**2 or (mW/m**2)
c           units for fresh water flux are in cm/s
c           downward is into the surface (ocean, ice or land)
c           upward is into the bottom of the atmosphere
c           outward is out of the top of the atmosphere
c           inward is into the top of the atmosphere
c
c     outlwr(imt,jmt)	 = outgoing atmosphere longwave flux
c     at(imt,jmt,2,nat)	 = tracers (previous and most recent)
c     surf(imt,jmt,nat)	 = surface values (1=temperature, 2=humidity)
c     flux(imt,jmt,nat)	 = downward flux (1=heat, 2=fresh water)
c     precip(imt,jmt)	 = precipitation
c     evap(imt,jmt)	 = evaporation
c     dnswr(imt,jmt)  	 = downward surface shortwave flux
c     uplwr(imt,jmt)  	 = upward surface longwave flux
c     upsens(imt,jmt)	 = upward surface sensible heat flux
c     upltnt(imt,jmt)    = upward surface latent heat flux
c     ssh(imt,jmt) 	 = saturation specific humidity
c     spd(imt,jmt) 	 = wind speed (cm/sec)
c     da(jmt,nat)	 = tracer diffusivity parameterization
c     coalbedo(jmt)	 = planetary coalbedo
c     solins(jmt)	 = solar insolation (units of solarconst)
c     esatm(jmt)	 = atmosphere emissivity times Stefan's constant
c     scatter(jmt)	 = solar scattering into atmosphere





c     cori(jmt,2)	 = Coriolis parameter

c
      real outlwr(imt,jmt), at(imt,jmt,3,nat), surf(imt,jmt,nat)
      real flux(imt,jmt,nat), precip(imt,jmt), evap(imt,jmt)
      real dnswr(imt,jmt), uplwr(imt,jmt), upsens(imt,jmt)
      real upltnt(imt,jmt), ssh(imt,jmt), spd(imt,jmt), da(jmt,nat)
      real coalbedo(jmt), solins(jmt), esatm(jmt), scatter(jmt)





      real cori(jmt,2)
c
      common /atm/ outlwr, at, surf, flux, precip, evap, dnswr, uplwr
     &,            upsens, upltnt, spd, ssh, da, coalbedo, solins
     &,            esatm, scatter





     &,            cori
c
c====================== include file "levind.h" ========================
c
c     vertical level indicators which define model geometry & bottom
c     topography:
c
c     kmt = number of vertical boxes over "t" points
c     kmu = number of vertical boxes over "u,v" points
c
      common /levind/ kmt(imt,jmt), kmu(imt,jmt)
c
c====================== include file "csbc.h" ==========================
c
c                    surface boundary conditions (S.B.C.)
c
c
c     numosbc = number of ocean S.B.C..
c
c     numasbc = number of atmospheric S.B.C..
c
c     maxsbc  = maximum number of allowable S.B.C. fields.
c
c     numsbc  = total number of S.B.C. this is the sum of the 
c               atmosphere S.B.C. and ocean S.B.C. fields. it must
c               be less than or equal to "maxsbc".
c
c     sbcocn  = S.B.C. fields on the ocean grid.
c               n=1..numosbc are for the incoming ocean S.B.C.
c               n=numosbc+1..numosbc+numasbc are for the outgoing S.B.C.
c

c
c     ntspos  = number of time steps per ocean segment
c
c     sbcname  = S.B.C. character string names (eg: "SST", "taux", etc)
c               note that these character strings should be changed with
c               care since they are used to identify fields for special
c               treatment
c
c     dunits  = dimensional units for S.B.C. (eg: "deg C")
c
c     mapsbc  = indices for relating how S.B.C. fields are stored
c               within arrays "sbcocn" and "sbcatm"  
c               eg: m = mapsbc(n) where sbcocn(,,m) is S.B.C. "n"
c
c     restrictions on re-arranging S.B.C. fields and "mapsbc":
c
c     1) all ocean S.B.C. (taux, tauy, etc) should be grouped together. 
c        relative ordering within the group is unimportant but the
c        group must preceed the atmos S.B.C. group.
c
c     2) all atmos S.B.C. (sst, ...) should also be grouped together.
c        relative ordering within the group is unimportant.
c
c     the default arrangement is defined as:
c
c             (these five ocean S.B.C. come from the atmos )
c     mapsbc(1) references taux
c     mapsbc(2) references tauy
c     mapsbc(3) references heat flux
c     mapsbc(4) references salt flux
c      if the atmos supplied fresh water flux then it
c      would have to be converted to ...
c      salt flux  = -(P-E+R) * rho * Sref
c      where...
c      P-E+R represents a precipitation minus evaporation
c            plus runoff rate in cm of water/sec
c      rho is the density if water taken to be 1 g/cm**3, and
c      Sref is a reference salinity in units of grams of salt per
c            gram of water (in units of "parts per part" such
c            as 0.035 ... not "parts per thousand")
c      Depending upon the application of interest, users may wish
c      to set Sref to either be a constant over the entire model
c      domain or for it to be the locally predicted salinity of
c      the uppermost model level (S(1)).  If one desires to ensure
c      that a global average P-E+R flux of zero translates to zero
c      trend in the salt content of the ocean, then a constant Sref
c      is needed.      
c     mapsbc(5) references short wave
c
c             (these four atmos S.B.C. come from the ocean)
c     mapsbc(6) references SST
c     mapsbc(7) references SSS
c     mapsbc(8) references surface u
c     mapsbc(9) references surface v
c
c
c     when re-ordering S.B.C., search for "mapsbc"  
c     (eg: grep mapsbc *.F) to insure the new indexing is consistant
c     with the re-ordering. also make changes in "sbcname", "dunits", 
c     "coabc", and "crits" to maintain consistancy.
c
c     example 1: suppose you want only the first six S.B.C...
c                in "csbc.h", set  numosbc=5, numasbc=1
c                this reduces memory requirements.
c                no other changes are necessary
c
c     example 2: suppose you want to remove the short wave boundary
c                condition (to save more memory) from example 1 . 
c                a) in "csbc.h", set numosbc=4, numasbc=1
c                b) grep "mapsbc(5)" *.F to find and remove references
c                c) grep "mapsbc(6)" *.F to change references to 
c                                        mapsbc(5)
c
c     
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c
c
      logical asegs, asege, afirst, alast
      character*10 sbcname
      character*15 dunits
c
      parameter (numosbc=5
     &,          numasbc=4
     &,          maxsbc=numosbc+numasbc, numsbc=maxsbc)
c
      common /csbc/ sbcocn(imt,jmt,numsbc) 
      common /csbc/ dampts(nt), dampdz(nt)
      common /csbc/ coabc(maxsbc), crits(maxsbc)
      common /csbc1/ mapsbc(maxsbc), numpas, iombc, ntspos, ntspas
      common /csbc2/ sbcname(maxsbc), dunits(maxsbc)
      common /csbc3/ asegs, asege, afirst, alast 
c
c====================== include file "mapsbc.h" ========================
c
c     indicies for surface boundary condition arrays.  names must be
c     unique and are set at the begining of "driver"
c
c     itaux is the x component of wind stress
c     itauy is the y component of wind stress
c     ihflx is heat flux
c     ipme is for precipitation minus evaporation
c     ipsw is for penitrating shortwave (into ocean first layer)
c     isst is the ocean model SST
c     isss is the ocean model SSS
c     isu is the x component of the ocean model first layer velocity
c     isv is the y component of the ocean model first layer velocity
c     it10 is the 10 metre atmopheric temperature
c     iq10 is the 10 metre atmopheric humidity
c     ilwr is incoming longwave radiation
c     iswr is incoming shortwave radiation
c     igu is the x component of the ocean model second layer velocity
c     igv is the y component of the ocean model second layer velocity
c
      common /mapsbc/ itaux, itauy, ihflx, ipme, ipsw, isst, isss
     &,               isu, isv, it10, iq10, ilwr, iswr, igu, igv
c
c
c
c-----------------------------------------------------------------------
c     calculate average net fluxes. convert heat flux to cal/cm**2/s 
c     from kW/m**2 and fresh water flux (cm/s) to an apparent salt 
c     flux (g/cm**2/s) using global ocean average salinity, socn
c-----------------------------------------------------------------------
c
      fa = 2.389e-8/avetime
      fb = -socn*rhoocn/avetime
      num = 0
      do j=2,jmtm1
        do i=2,imtm1
	  if (kmt(i,j) .gt. 0) then

c           check we are not taking more heat than in first layer
c           (for use without an ice model, to prevent freezing sst)
            sbcocn(i,j,ihflx) = max(fa*flux(i,j,1), sbcocn(i,j,ihflx))

            sbcocn(i,j,ipme) = fb*flux(i,j,2)
          endif
	enddo
      enddo	
c martin
c#endif
c
      return
      end

      subroutine embm
c
c=======================================================================
c
c                 UVic Energy-Moisture Balance Model
c                            Version 1.1
c
c
c     A simple atmospheric model developed by researchers at the
c     Climate Research Laboratory, in the School of Earth and Ocean 
c     Sciences, located at the University of Victoria, Victoria, 
c     B.C., Canada.
c                                
c     The model is based primarily on the work of Augustus Fanning.
c
c     Fanning, A.F. and A.J. Weaver, An atmospheric energy-moisture
c       balance model: climatology, interpentadal climate change, 
c       and coupling to an ocean general circulation model, 
c       J. Geophys. Res., 101, 15,111-15,128, 1996
c 
c     Documentation:
c
c     For documentation refer to a postscript manual which may be 
c     ordered by contacting embm@seos.uvic.ca
c
c     Bug reports or questions: 
c
c     Each section of code has a code author. Please direct questions 
c     or problems to these authors at embm@seos.uvic.ca
c        
c     Requirements:
c
c     Standard fortran 77 is used (except for namelist which is 
c     fortran 90 compliant, do enddo, use of "max" function in 
c     parameter statements and variable names > than 6 characters)
c     The preprocessor "cpp" (available on systems using "c" or UNIX)
c
c     Disclaimer:
c
c     The UVic Energy-Moisture Balance Model (EMBM) is a climate 
c     modeling research tool developed at UVic. Others may use it 
c     freely but we assume no responsibility for problems or 
c     incorrect use of EMBM. It is left to the user to satisfy 
c     (him/her)self that a particular configuration is working 
c     correctly.
c       
c     author:   m.eby   e-mail: eby@uvic.ca
c=======================================================================
c
c====================== include file "size.h" ==========================
c                                                                       
c-----------------------------------------------------------------------
c     USER INPUT: 
c-----------------------------------------------------------------------
c
c     imt    = number of grid points in the longitudinal direction
c              (calculated points are from 2 through imt-1. End points
c               are boundaries)          
c
c     jmt    = number of grid points (latitude rows) in the latitudinal
c              direction (calculated points are from 2 through jmt-1.           
c              End points are boundaries)   
c                                
c     km     = number of grid points in the vertical direction          
c              (calculated points are from 1 through km)
c
c     nt     = number of tracers (temperature, salinity, ...)
c
c     mnisle = maximum number of islands (unconnected land masses)
c
c     maxipp = maximum number of all island perimeter points
c-----------------------------------------------------------------------
c                                                                       
      parameter (imt=  92, jmt=  61, km= 15)
      parameter (nt=2)
      parameter (nat=2)
      parameter (mnisle=50, maxipp=5000)
c

c






c
c-----------------------------------------------------------------------
c     END USER INPUT
c-----------------------------------------------------------------------
c                                                                       
c-----------------------------------------------------------------------
c     By default, the MW (memory window) is 2nd order except for the
c     following options which require a 4th order MW 
c
c     for 2nd order schemes, the minimum sized MW is 3 latitude rows
c     for 4th order schemes, the minimum sized MW is 4 latitude rows
c                            (5 if using coarse_grained_parallelism)
c-----------------------------------------------------------------------
c













c
c-----------------------------------------------------------------------
c     set MW (memory window) size "jmw" 
c-----------------------------------------------------------------------
c                                                                       

c
c     for UNI-TASKING: "jmw" is set to the minimum for each option class 
c     "jmw" may be increased up to "jmt" 
c

      parameter (jmw=jmt)


c
c-----------------------------------------------------------------------
c     set first and last calculated row within the MW. other rows
c     are used as buffers
c-----------------------------------------------------------------------
c
c     jsmw   = 1st calculated row within the MW     
c     jemw   = last calculated row within the MW
c
      parameter (jsmw=2, jemw=jmw-1)
c
c
c     jextra = extra buffer rows needed for coarse_grained_parallelism.
c              "jextra" rows are added to the top and bottom of the MW
c              so the MW size increases by 2*jextra       
c

          parameter (jextra = 0)




c====================== include file "cembm.h" =========================
c
c     parameters for use in the energy balance model (also see atm.h)
c
c     addflux		= logical flag for adding only even mode fluxes
c     nats		= number of atmospheric time steps since mixing
c     namix		= time steps between mixing (set in atmos.in)
c     lf		= time step flag (1=>leapfrog, 2=>forward)
c     pyear		= calendar year (set in atmos.in, -/+ = BC/AD)
c     dtatm 		= time step for atmosphere (set in atmos.in)
c     dts		= time step (2*dtatm=>leapfrog, dtatm=>forward)
c     co2ccn		= CO2 concentration
c     anthro		= radiative forcing by CO2
c     co2ccni		= initial CO2 concentration
c     co2yri		= last year of initial CO2 concentration
c     co2ccnf		= final CO2 concentration
c     co2yrf		= first year of final CO2 concentration
c     solarconst	= solar constant (g/s**3)
c     ssp		= sea surface pressure (g/cm/s**2)
c     cdatm 		= drag coefficient (dimensionless)
c     cpatm		= atmospheric heat capacity (cm**2/s**2/K)
c     ht		= scale height for temperature
c     hq		= scale height for specific humidity
c     rhoatm		= density of air at sea surface (g/cm**3)
c     rhoocn		= representative sea surface density
c     esocn		= ocean emissivity times Stefan's constant 
c     vlocn		= latent heat of vaporization of water
c     socn		= constant ocean salinity
c     cdice 		= drag coefficient (dimensionless)
c     rhoice		= ice density (g/cm**3)
c     esice		= ice emissivity times Stefan's constant 
c     slice		= latent heat of sublimation of ice
c     flice		= latent heat of fusion of ice (cm**2/s**2)
c     condice		= ice conductivity (g*cm/s**3/K)
c     kadv		= time step divider for ice advection
c     ntats		= time step counter for time averaging
c     avetime		= time for averaging fluxes
c     totaltime		= total time for long term averages
c
      logical addflux
c
      common /cembm/ addflux
      common /cembm/ nats, namix, lf, kadv, ntats
      common /cembm/ pyear, dtatm, dts, co2ccn, anthro, co2ccni, co2yri
     &,              co2ccnf, co2yrf, solarconst, ssp, cdatm, cpatm, ht
     &,              hq, rhoatm, rhoocn, esocn, vlocn, socn, cdice
     &,              rhoice, esice, slice, flice, condice, avetime 
     &,              totaltime
c
c
c
c-----------------------------------------------------------------------
c     increment counter and set the time step type
c-----------------------------------------------------------------------
c
      nats = nats + 1
      if (nats .gt. namix) then
        lf = 2
        dts = dtatm
        nats = 1
      else
        lf = 1
        dts = 2.0*dtatm
      endif

c
c-----------------------------------------------------------------------
c     calculate fluxes at tau
c-----------------------------------------------------------------------
c

      call fluxes


c
c-----------------------------------------------------------------------
c     calculate new right hand side (forcing) for all tracers
c-----------------------------------------------------------------------
c
      call newrhs
c
c-----------------------------------------------------------------------
c     compute atmospheric tracers at tau+1. start with humidity so that
c     the precipitation flux can be calculated for latent heat 
c-----------------------------------------------------------------------
c
      call solve (2)
      call precipitate
      call solve (1)
      do n=3,nat
        call solve (n)
      enddo
c
c-----------------------------------------------------------------------
c     calculate the total atmospheric fluxes for coupling
c-----------------------------------------------------------------------
c

      call sumflux



c
      return
      end
      subroutine embmbc (data)
c
c=======================================================================
c     set boundary values
c     based on code by a.fanning
c
c     input:
c       data = array to be set
c
c     author:   m.eby   e-mail: eby@uvic.ca
c=======================================================================
c

c====================== include file "param.h" =========================
c
c     main parameter file which sets ocean characteristics:
c
c     "size.h" sets model size "imt", "jmt", and "km"
c
c====================== include file "size.h" ==========================
c                                                                       
c-----------------------------------------------------------------------
c     USER INPUT: 
c-----------------------------------------------------------------------
c
c     imt    = number of grid points in the longitudinal direction
c              (calculated points are from 2 through imt-1. End points
c               are boundaries)          
c
c     jmt    = number of grid points (latitude rows) in the latitudinal
c              direction (calculated points are from 2 through jmt-1.           
c              End points are boundaries)   
c                                
c     km     = number of grid points in the vertical direction          
c              (calculated points are from 1 through km)
c
c     nt     = number of tracers (temperature, salinity, ...)
c
c     mnisle = maximum number of islands (unconnected land masses)
c
c     maxipp = maximum number of all island perimeter points
c-----------------------------------------------------------------------
c                                                                       
      parameter (imt=  92, jmt=  61, km= 15)
      parameter (nt=2)
      parameter (nat=2)
      parameter (mnisle=50, maxipp=5000)
c

c






c
c-----------------------------------------------------------------------
c     END USER INPUT
c-----------------------------------------------------------------------
c                                                                       
c-----------------------------------------------------------------------
c     By default, the MW (memory window) is 2nd order except for the
c     following options which require a 4th order MW 
c
c     for 2nd order schemes, the minimum sized MW is 3 latitude rows
c     for 4th order schemes, the minimum sized MW is 4 latitude rows
c                            (5 if using coarse_grained_parallelism)
c-----------------------------------------------------------------------
c













c
c-----------------------------------------------------------------------
c     set MW (memory window) size "jmw" 
c-----------------------------------------------------------------------
c                                                                       

c
c     for UNI-TASKING: "jmw" is set to the minimum for each option class 
c     "jmw" may be increased up to "jmt" 
c

      parameter (jmw=jmt)


c
c-----------------------------------------------------------------------
c     set first and last calculated row within the MW. other rows
c     are used as buffers
c-----------------------------------------------------------------------
c
c     jsmw   = 1st calculated row within the MW     
c     jemw   = last calculated row within the MW
c
      parameter (jsmw=2, jemw=jmw-1)
c
c
c     jextra = extra buffer rows needed for coarse_grained_parallelism.
c              "jextra" rows are added to the top and bottom of the MW
c              so the MW size increases by 2*jextra       
c

          parameter (jextra = 0)




c
c     nvar   = number of prognostic variables
c     lseg   = maximum number of longitudinal stream function segments
c     nlatpr = maximum number of latitudes for matrix printouts
c              on diagnostic time steps
c     nhreg  = number of regions in the horizontal used for averaging
c              tracers.
c     nvreg  = number of regions in the vertical used for term balance
c              calculations. note "nvreg" isn`t used for tracer averages
c     numreg = total number of regions ( = product of nhreg & nvreg)
c              used for term balance calculations
c
      parameter (lseg=5, nlatpr=10)

      parameter (nhreg=5, nvreg=2, numreg=nhreg*nvreg)

      parameter (nvar=nt+2)
c

c
      parameter (imtm1=imt-1, kmm1=km-1)                                
      parameter (imtp1=imt+1, imtm2=imt-2
     &,          jmtp1=jmt+1, jmtm1=jmt-1, jmtm2=jmt-2

     &,          jscan=jmtm2

     &,          kmp1=km+1, kmp2=km+2
     &,          imtkm=imt*km, nwds=imt*jmt, nkflds=2
     &,          nslab=imt*nvar*km, ntmin2=nt+1/nt)
c
c     include parameter constants
c
c====================== include file "pconst.h" ========================
c
c
c     rules for parameter constants
c
c     use prefix of "c" for whole real numbers (eg: c57 for 57.0)
c     use "m" after prefix to designate negative values (minus sign)
c       (eg: cm7 for -7.0)
c     use prefix of "p" for non repeating fractions (eg: p5 for 0.5)
c     use prefix of "r" for reciprocals (eg: r3 for 1/3.0)
c     combine use of prefix above and "e" for scientific notation, with
c       (eg: c5e4 for 5.0e4, c1em10 for 1.0e-10)
c
      parameter (c0=0.0, c1=1.0, c2=2.0, c3=3.0, c4=4.0, c5=5.0, c7=7.0)
      parameter (c8=8.0)
      parameter (c14=14.0, c16=16.0, c360=360.0)
      parameter (p125=0.125, p25=0.25, p5=0.5, p75=0.75)
      parameter (epsln=1.0e-20)
c
      parameter (c24=24.0, c60=60.0, c1440=1440.0)
      parameter (r24=c1/c24, r60=c1/c60, r1440=c1/c1440)
      parameter (secday=c1/(c60*c1440))
c
c     include standard I/O units
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c
c     ncrows = number of calculated rows within the MW.
c              (the remaining rows are buffer rows). 
c


      parameter (ncrows = jmw - 2)


c
      real data(imt,jmt)
c
c     set cyclic east west
c
      do j=1,jmt
        data(1,j) = data(imtm1,j)
        data(imt,j) = data(2,j)
      enddo
c
c     set closed North South
c
      do i=1,imt
        data(i,1) = data(i,2)
        data(i,jmt) = data(i,jmtm1)
      enddo

c
      return
      end
      subroutine atmdiag
c
c=======================================================================
c     calculate the zonally averaged atmospheric statistics and output
c     based on code by a.fanning
c
c     author:   m.eby   e-mail: eby@uvic.ca
c=======================================================================
c

c====================== include file "param.h" =========================
c
c     main parameter file which sets ocean characteristics:
c
c     "size.h" sets model size "imt", "jmt", and "km"
c
c====================== include file "size.h" ==========================
c                                                                       
c-----------------------------------------------------------------------
c     USER INPUT: 
c-----------------------------------------------------------------------
c
c     imt    = number of grid points in the longitudinal direction
c              (calculated points are from 2 through imt-1. End points
c               are boundaries)          
c
c     jmt    = number of grid points (latitude rows) in the latitudinal
c              direction (calculated points are from 2 through jmt-1.           
c              End points are boundaries)   
c                                
c     km     = number of grid points in the vertical direction          
c              (calculated points are from 1 through km)
c
c     nt     = number of tracers (temperature, salinity, ...)
c
c     mnisle = maximum number of islands (unconnected land masses)
c
c     maxipp = maximum number of all island perimeter points
c-----------------------------------------------------------------------
c                                                                       
      parameter (imt=  92, jmt=  61, km= 15)
      parameter (nt=2)
      parameter (nat=2)
      parameter (mnisle=50, maxipp=5000)
c

c






c
c-----------------------------------------------------------------------
c     END USER INPUT
c-----------------------------------------------------------------------
c                                                                       
c-----------------------------------------------------------------------
c     By default, the MW (memory window) is 2nd order except for the
c     following options which require a 4th order MW 
c
c     for 2nd order schemes, the minimum sized MW is 3 latitude rows
c     for 4th order schemes, the minimum sized MW is 4 latitude rows
c                            (5 if using coarse_grained_parallelism)
c-----------------------------------------------------------------------
c













c
c-----------------------------------------------------------------------
c     set MW (memory window) size "jmw" 
c-----------------------------------------------------------------------
c                                                                       

c
c     for UNI-TASKING: "jmw" is set to the minimum for each option class 
c     "jmw" may be increased up to "jmt" 
c

      parameter (jmw=jmt)


c
c-----------------------------------------------------------------------
c     set first and last calculated row within the MW. other rows
c     are used as buffers
c-----------------------------------------------------------------------
c
c     jsmw   = 1st calculated row within the MW     
c     jemw   = last calculated row within the MW
c
      parameter (jsmw=2, jemw=jmw-1)
c
c
c     jextra = extra buffer rows needed for coarse_grained_parallelism.
c              "jextra" rows are added to the top and bottom of the MW
c              so the MW size increases by 2*jextra       
c

          parameter (jextra = 0)




c
c     nvar   = number of prognostic variables
c     lseg   = maximum number of longitudinal stream function segments
c     nlatpr = maximum number of latitudes for matrix printouts
c              on diagnostic time steps
c     nhreg  = number of regions in the horizontal used for averaging
c              tracers.
c     nvreg  = number of regions in the vertical used for term balance
c              calculations. note "nvreg" isn`t used for tracer averages
c     numreg = total number of regions ( = product of nhreg & nvreg)
c              used for term balance calculations
c
      parameter (lseg=5, nlatpr=10)

      parameter (nhreg=5, nvreg=2, numreg=nhreg*nvreg)

      parameter (nvar=nt+2)
c

c
      parameter (imtm1=imt-1, kmm1=km-1)                                
      parameter (imtp1=imt+1, imtm2=imt-2
     &,          jmtp1=jmt+1, jmtm1=jmt-1, jmtm2=jmt-2

     &,          jscan=jmtm2

     &,          kmp1=km+1, kmp2=km+2
     &,          imtkm=imt*km, nwds=imt*jmt, nkflds=2
     &,          nslab=imt*nvar*km, ntmin2=nt+1/nt)
c
c     include parameter constants
c
c====================== include file "pconst.h" ========================
c
c
c     rules for parameter constants
c
c     use prefix of "c" for whole real numbers (eg: c57 for 57.0)
c     use "m" after prefix to designate negative values (minus sign)
c       (eg: cm7 for -7.0)
c     use prefix of "p" for non repeating fractions (eg: p5 for 0.5)
c     use prefix of "r" for reciprocals (eg: r3 for 1/3.0)
c     combine use of prefix above and "e" for scientific notation, with
c       (eg: c5e4 for 5.0e4, c1em10 for 1.0e-10)
c
      parameter (c0=0.0, c1=1.0, c2=2.0, c3=3.0, c4=4.0, c5=5.0, c7=7.0)
      parameter (c8=8.0)
      parameter (c14=14.0, c16=16.0, c360=360.0)
      parameter (p125=0.125, p25=0.25, p5=0.5, p75=0.75)
      parameter (epsln=1.0e-20)
c
      parameter (c24=24.0, c60=60.0, c1440=1440.0)
      parameter (r24=c1/c24, r60=c1/c60, r1440=c1/c1440)
      parameter (secday=c1/(c60*c1440))
c
c     include standard I/O units
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c
c     ncrows = number of calculated rows within the MW.
c              (the remaining rows are buffer rows). 
c


      parameter (ncrows = jmw - 2)


c====================== include file "coord.h" =========================
c
c                    model grid point coordinates
c
c     grid definition:
c
c     the model uses a staggard arakawa "b" grid which is setup and 
c     generated by the "grids.F" module. 
c
c     xt(i)   = longitude of the ith "t" point in degrees.   i=1..imt
c     xu(i)   = longitude of the ith "u,v" point in degrees. i=1..imt
c     yt(j)   = latitude of the jth "t" point in degrees.    j=1..jmt
c     yu(j)   = latitude of the jth "u,v" point in degrees.  j=1..jmt
c     zt(k)   = distance from surface down to center of level k (in cm)
c               (for depth of "t" and "u,v" grid points: k=1,km)
c     zw(k)   = distance from surface down to bottom of level k (in cm)
c               (for depth of "t" and "u,v" grid points: k=1,km)
c     dxtdeg  = widths for "t" grid cells (degrees)
c     dytdeg  = heights for "t" grid cells (degrees)
c     dxudeg  = widths for "u" grid cells (degrees)
c     dyudeg  = heights for "u" grid cells (degrees)
c     dzt(k)  = vertical resolution of "t" and "u" grid cells (in cm)
c     dzw(k)  = vertical resolution of "w" grid cells (in cm)
c
c     "i" increases in an eastward direction, "j" increases in a
c     northward direction, and "k" increases downward.
c     
      common /coord/ xt(imt), yt(jmt), xu(imt), yu(jmt), zw(km), zt(km)
      common /coord/ dxtdeg(imt), dytdeg(jmt), dzt(km)
      common /coord/ dxudeg(imt), dyudeg(jmt), dzw(0:km)
c
c====================== include file "cembm.h" =========================
c
c     parameters for use in the energy balance model (also see atm.h)
c
c     addflux		= logical flag for adding only even mode fluxes
c     nats		= number of atmospheric time steps since mixing
c     namix		= time steps between mixing (set in atmos.in)
c     lf		= time step flag (1=>leapfrog, 2=>forward)
c     pyear		= calendar year (set in atmos.in, -/+ = BC/AD)
c     dtatm 		= time step for atmosphere (set in atmos.in)
c     dts		= time step (2*dtatm=>leapfrog, dtatm=>forward)
c     co2ccn		= CO2 concentration
c     anthro		= radiative forcing by CO2
c     co2ccni		= initial CO2 concentration
c     co2yri		= last year of initial CO2 concentration
c     co2ccnf		= final CO2 concentration
c     co2yrf		= first year of final CO2 concentration
c     solarconst	= solar constant (g/s**3)
c     ssp		= sea surface pressure (g/cm/s**2)
c     cdatm 		= drag coefficient (dimensionless)
c     cpatm		= atmospheric heat capacity (cm**2/s**2/K)
c     ht		= scale height for temperature
c     hq		= scale height for specific humidity
c     rhoatm		= density of air at sea surface (g/cm**3)
c     rhoocn		= representative sea surface density
c     esocn		= ocean emissivity times Stefan's constant 
c     vlocn		= latent heat of vaporization of water
c     socn		= constant ocean salinity
c     cdice 		= drag coefficient (dimensionless)
c     rhoice		= ice density (g/cm**3)
c     esice		= ice emissivity times Stefan's constant 
c     slice		= latent heat of sublimation of ice
c     flice		= latent heat of fusion of ice (cm**2/s**2)
c     condice		= ice conductivity (g*cm/s**3/K)
c     kadv		= time step divider for ice advection
c     ntats		= time step counter for time averaging
c     avetime		= time for averaging fluxes
c     totaltime		= total time for long term averages
c
      logical addflux
c
      common /cembm/ addflux
      common /cembm/ nats, namix, lf, kadv, ntats
      common /cembm/ pyear, dtatm, dts, co2ccn, anthro, co2ccni, co2yri
     &,              co2ccnf, co2yrf, solarconst, ssp, cdatm, cpatm, ht
     &,              hq, rhoatm, rhoocn, esocn, vlocn, socn, cdice
     &,              rhoice, esice, slice, flice, condice, avetime 
     &,              totaltime
c
c====================== include file "atm.h" ===========================
c
c     arrays for the energy-moisture balance model
c
c     note: units for heat flux are in g/cm**2/s**3/cm**2 or (mW/m**2)
c           units for fresh water flux are in cm/s
c           downward is into the surface (ocean, ice or land)
c           upward is into the bottom of the atmosphere
c           outward is out of the top of the atmosphere
c           inward is into the top of the atmosphere
c
c     outlwr(imt,jmt)	 = outgoing atmosphere longwave flux
c     at(imt,jmt,2,nat)	 = tracers (previous and most recent)
c     surf(imt,jmt,nat)	 = surface values (1=temperature, 2=humidity)
c     flux(imt,jmt,nat)	 = downward flux (1=heat, 2=fresh water)
c     precip(imt,jmt)	 = precipitation
c     evap(imt,jmt)	 = evaporation
c     dnswr(imt,jmt)  	 = downward surface shortwave flux
c     uplwr(imt,jmt)  	 = upward surface longwave flux
c     upsens(imt,jmt)	 = upward surface sensible heat flux
c     upltnt(imt,jmt)    = upward surface latent heat flux
c     ssh(imt,jmt) 	 = saturation specific humidity
c     spd(imt,jmt) 	 = wind speed (cm/sec)
c     da(jmt,nat)	 = tracer diffusivity parameterization
c     coalbedo(jmt)	 = planetary coalbedo
c     solins(jmt)	 = solar insolation (units of solarconst)
c     esatm(jmt)	 = atmosphere emissivity times Stefan's constant
c     scatter(jmt)	 = solar scattering into atmosphere





c     cori(jmt,2)	 = Coriolis parameter

c
      real outlwr(imt,jmt), at(imt,jmt,3,nat), surf(imt,jmt,nat)
      real flux(imt,jmt,nat), precip(imt,jmt), evap(imt,jmt)
      real dnswr(imt,jmt), uplwr(imt,jmt), upsens(imt,jmt)
      real upltnt(imt,jmt), ssh(imt,jmt), spd(imt,jmt), da(jmt,nat)
      real coalbedo(jmt), solins(jmt), esatm(jmt), scatter(jmt)





      real cori(jmt,2)
c
      common /atm/ outlwr, at, surf, flux, precip, evap, dnswr, uplwr
     &,            upsens, upltnt, spd, ssh, da, coalbedo, solins
     &,            esatm, scatter





     &,            cori
c


c

c
      real tz(jmt), qz(jmt), hfluxz(jmt), ffluxz(jmt), tsurfz(jmt)
      real evapz(jmt), precipz(jmt), dnswrz(jmt), upsensz(jmt)
      real upltntz(jmt), uplwrz(jmt), outlwrz(jmt)

c
      fa = 1.0/avetime
      fb = -socn*rhoocn/avetime
c
      write (stdout,*) 
      write (stdout,*) 'Atmospheric Zonal Averages' 
      write (stdout,*) 
c
c-----------------------------------------------------------------------
c     calculate zonal averages
c-----------------------------------------------------------------------
c
c     calculate zonal air temp
      call zonal (at(1,1,2,1), 1, tz)
c
c     calculate zonal specific humidity
      call zonal (at(1,1,2,2), 1, qz)
c
c     calculate zonal oceanic heat flux
      call zonal (flux(1,1,1), 0, hfluxz)
c
c     calculate zonal oceanic freshwater flux
      call zonal (flux(1,1,2), 0, ffluxz)
c
c     calculate zonal surface temp
      call zonal (surf(1,1,1), 0, tsurfz)
c
c     calculate zonal evap
      call zonal (evap, 0, evapz)
c
c     calculate zonal precip
      call zonal (precip, 1, precipz)
c 
c     calculate zonal downward shortwave
      call zonal (dnswr, 1, dnswrz)
c
c     calculate zonal upward sensible heat flux
      call zonal (upsens, 0, upsensz)
c
c     calculate zonal upward latent heat flux
      call zonal (upltnt, 0, upltntz)
c
c     calculate zonal upward longwave heat flux
      call zonal (uplwr, 0, uplwrz)
c
c     calculate zonal outgoing longwave heat flux
      call zonal (outlwr, 1, outlwrz)



c
c-----------------------------------------------------------------------
c     write zonal averages
c-----------------------------------------------------------------------
c
      write(stdout,'(a5,14(a11))')
     &  'lat', 't', 'q', 'hflux', 'sflux', 'tsurf', 'evap', 'precip'
     &, 'dnswr', 'upsens', 'upltnt', 'uplwr', 'outlwr'

c
      do j=jmtm1,2,-1
        write(stdout,'(f7.2,14(1pe11.3))') 
     &    yt(j), tz(j), qz(j), fa*hfluxz(j), fb*ffluxz(j)
     &,   tsurfz(j), evapz(j), precipz(j), dnswrz(j), upsensz(j)
     &,	  upltntz(j), uplwrz(j), outlwrz(j)

      enddo
      write (stdout,*) 

c
      return
      end


      subroutine areatot (data, land, tot)
c
c=======================================================================
c     calculate the area weighted total of data
c     based on code by a.fanning
c
c     input:
c       data = data to be totaled
c       land = flag for land (0=exclude 1=include)
c     output:
c       tot = area weighted total of the data
c
c     author:   m.eby   e-mail: eby@uvic.ca
c=======================================================================
c
c====================== include file "param.h" =========================
c
c     main parameter file which sets ocean characteristics:
c
c     "size.h" sets model size "imt", "jmt", and "km"
c
c====================== include file "size.h" ==========================
c                                                                       
c-----------------------------------------------------------------------
c     USER INPUT: 
c-----------------------------------------------------------------------
c
c     imt    = number of grid points in the longitudinal direction
c              (calculated points are from 2 through imt-1. End points
c               are boundaries)          
c
c     jmt    = number of grid points (latitude rows) in the latitudinal
c              direction (calculated points are from 2 through jmt-1.           
c              End points are boundaries)   
c                                
c     km     = number of grid points in the vertical direction          
c              (calculated points are from 1 through km)
c
c     nt     = number of tracers (temperature, salinity, ...)
c
c     mnisle = maximum number of islands (unconnected land masses)
c
c     maxipp = maximum number of all island perimeter points
c-----------------------------------------------------------------------
c                                                                       
      parameter (imt=  92, jmt=  61, km= 15)
      parameter (nt=2)
      parameter (nat=2)
      parameter (mnisle=50, maxipp=5000)
c

c






c
c-----------------------------------------------------------------------
c     END USER INPUT
c-----------------------------------------------------------------------
c                                                                       
c-----------------------------------------------------------------------
c     By default, the MW (memory window) is 2nd order except for the
c     following options which require a 4th order MW 
c
c     for 2nd order schemes, the minimum sized MW is 3 latitude rows
c     for 4th order schemes, the minimum sized MW is 4 latitude rows
c                            (5 if using coarse_grained_parallelism)
c-----------------------------------------------------------------------
c













c
c-----------------------------------------------------------------------
c     set MW (memory window) size "jmw" 
c-----------------------------------------------------------------------
c                                                                       

c
c     for UNI-TASKING: "jmw" is set to the minimum for each option class 
c     "jmw" may be increased up to "jmt" 
c

      parameter (jmw=jmt)


c
c-----------------------------------------------------------------------
c     set first and last calculated row within the MW. other rows
c     are used as buffers
c-----------------------------------------------------------------------
c
c     jsmw   = 1st calculated row within the MW     
c     jemw   = last calculated row within the MW
c
      parameter (jsmw=2, jemw=jmw-1)
c
c
c     jextra = extra buffer rows needed for coarse_grained_parallelism.
c              "jextra" rows are added to the top and bottom of the MW
c              so the MW size increases by 2*jextra       
c

          parameter (jextra = 0)




c
c     nvar   = number of prognostic variables
c     lseg   = maximum number of longitudinal stream function segments
c     nlatpr = maximum number of latitudes for matrix printouts
c              on diagnostic time steps
c     nhreg  = number of regions in the horizontal used for averaging
c              tracers.
c     nvreg  = number of regions in the vertical used for term balance
c              calculations. note "nvreg" isn`t used for tracer averages
c     numreg = total number of regions ( = product of nhreg & nvreg)
c              used for term balance calculations
c
      parameter (lseg=5, nlatpr=10)

      parameter (nhreg=5, nvreg=2, numreg=nhreg*nvreg)

      parameter (nvar=nt+2)
c

c
      parameter (imtm1=imt-1, kmm1=km-1)                                
      parameter (imtp1=imt+1, imtm2=imt-2
     &,          jmtp1=jmt+1, jmtm1=jmt-1, jmtm2=jmt-2

     &,          jscan=jmtm2

     &,          kmp1=km+1, kmp2=km+2
     &,          imtkm=imt*km, nwds=imt*jmt, nkflds=2
     &,          nslab=imt*nvar*km, ntmin2=nt+1/nt)
c
c     include parameter constants
c
c====================== include file "pconst.h" ========================
c
c
c     rules for parameter constants
c
c     use prefix of "c" for whole real numbers (eg: c57 for 57.0)
c     use "m" after prefix to designate negative values (minus sign)
c       (eg: cm7 for -7.0)
c     use prefix of "p" for non repeating fractions (eg: p5 for 0.5)
c     use prefix of "r" for reciprocals (eg: r3 for 1/3.0)
c     combine use of prefix above and "e" for scientific notation, with
c       (eg: c5e4 for 5.0e4, c1em10 for 1.0e-10)
c
      parameter (c0=0.0, c1=1.0, c2=2.0, c3=3.0, c4=4.0, c5=5.0, c7=7.0)
      parameter (c8=8.0)
      parameter (c14=14.0, c16=16.0, c360=360.0)
      parameter (p125=0.125, p25=0.25, p5=0.5, p75=0.75)
      parameter (epsln=1.0e-20)
c
      parameter (c24=24.0, c60=60.0, c1440=1440.0)
      parameter (r24=c1/c24, r60=c1/c60, r1440=c1/c1440)
      parameter (secday=c1/(c60*c1440))
c
c     include standard I/O units
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c
c     ncrows = number of calculated rows within the MW.
c              (the remaining rows are buffer rows). 
c


      parameter (ncrows = jmw - 2)


c====================== include file "grdvar.h" ========================
c
c     variables which are functions of the grid defined by "coord.h"
c
c     dxt     = longitudinal width of "t" grid box at the 
c               equator (in cm)
c     dxtr    = reciprocal of "dxt"
c     dxt2r   = reciprocal of "2*dxt"
c     dxt4r   = reciprocal of "4*dxt"
c     dxu     = longitudinal width of "u,v" grid box at the 
c               equator (in cm)
c     dxur    = reciprocal of "dxu"
c     dxu2r   = reciprocal of "2*dxu"
c     dxu4r   = reciprocal of "4*dxu"
c     dxmetr  = reciprocal of "(dxt(i)+dxt(i+1))"
c     duw     = xu(i) - xt(i)
c     due     = xt(i+1) - xu(i)
c     dus     = yu(jrow) - yt(jrow)
c     dun     = yt(jrow+1) - yu(jrow)
c
c     dyt     = latitudinal height of "t" grid box (in cm)
c     dytr    = reciprocal of "dyt"
c     dyt2r   = reciprocal of "2*dyt"
c     dyt4r   = reciprocal of "4*dyt"
c     dyu     = latitudinal height of "u,v" grid box (in cm)
c     dyur    = reciprocal of "dyu"
c     dyu2r   = reciprocal of "2*dyu"
c     dyu4r   = reciprocal of "4*dyu"
c
c     csu     = cosine of "u,v" grid point latitude
c     csur    = reciprocal of "csu"
c     cst     = cosine of "t" grid point latitude
c     cstr    = reciprocal of "cst"
c     phi     = latitude of "u,v" grid point in radians
c     phit    = latitude of "t" grid point in radians
c     sine    = sine of "u,v" grid point latitude
c     tng     = tan of "u,v" grid point latitude
c     fcor    = 2*omega*sine(j)
c
c     c2dzt(k)= "2*dzt"
c     dztr(k) = reciprocal of dzt ("t" cell vertical resolution)
c     dzt2r(k)= reciprocal of "2*dzt"
c     dzwr(k) = reciprocal of dzw ("w" cell vertical resolution)
c     dzw2r(k)= reciprocal of "2*dzw"
c     dztur(k)= upper diffusion grid factor = 1.0/(dzw(k-1)*dzt(k))
c     dztlr(k)= lower diffusion grid factor = 1.0/(dzw(k)*dzt(k))
c     dzwur(k)= upper diffusion grid factor = 1.0/(dzt(k)*dzw(k))
c     dzwlr(k)= lower diffusion grid factor = 1.0/(dzt(k+1)*dzw(k))
c     
      common /grdvar/ dxt(imt),  dxtr(imt),  dxt2r(imt), dxu(imt)
      common /grdvar/ dxur(imt), dxu2r(imt), dxu4r(imt), dxt4r(imt)
      common /grdvar/ dyt(jmt),  dytr(jmt),  dyt2r(jmt), dyu(jmt)
      common /grdvar/ dyur(jmt), dyu2r(jmt), dyu4r(jmt), dyt4r(jmt)
      common /grdvar/ csu(jmt),  csur(jmt),  cst(jmt),   cstr(jmt)
      common /grdvar/ cstdytr(jmt), cstdyt2r(jmt)
      common /grdvar/ csudyur(jmt), csudyu2r(jmt)
      common /grdvar/ cst_dytr(jmt), csu_dyur(jmt)
      common /grdvar/ phi(jmt),  phit(jmt),  sine(jmt),  tng(jmt)
      common /grdvar/ fcor(jmt), c2dzt(km),  dztr(km),   dzt2r(km) 
      common /grdvar/ dzwr(0:km), dzw2r(0:km)
      common /grdvar/ dxmetr(imt), duw(imt), due(imt)
      common /grdvar/ dun(jmt), dus(jmt)


c

c====================== include file "levind.h" ========================
c
c     vertical level indicators which define model geometry & bottom
c     topography:
c
c     kmt = number of vertical boxes over "t" points
c     kmu = number of vertical boxes over "u,v" points
c
      common /levind/ kmt(imt,jmt), kmu(imt,jmt)
c
c
      real data(imt,jmt)
c
      tot = 0.0
c
      do j=2,jmtm1
        fx = cst(j)*dyt(j)
	do i = 2,imtm1
          if (kmt(i,j) + land  .gt. 0) then 
            tot = tot + data(i,j)*dxt(i)*fx
          endif
        enddo
      enddo
c
      return
      end


      subroutine areaavg (data, land, avg)
c=======================================================================
c     calculate the area weighted average of data
c     based on code by a.fanning
c
c     input:
c       data = data to be averaged
c       land = flag for land (0=exclude 1=include)
c     output:
c       avg = area weighted average of the data
c
c     author:   m.eby   e-mail: eby@uvic.ca
c=======================================================================
c
c====================== include file "param.h" =========================
c
c     main parameter file which sets ocean characteristics:
c
c     "size.h" sets model size "imt", "jmt", and "km"
c
c====================== include file "size.h" ==========================
c                                                                       
c-----------------------------------------------------------------------
c     USER INPUT: 
c-----------------------------------------------------------------------
c
c     imt    = number of grid points in the longitudinal direction
c              (calculated points are from 2 through imt-1. End points
c               are boundaries)          
c
c     jmt    = number of grid points (latitude rows) in the latitudinal
c              direction (calculated points are from 2 through jmt-1.           
c              End points are boundaries)   
c                                
c     km     = number of grid points in the vertical direction          
c              (calculated points are from 1 through km)
c
c     nt     = number of tracers (temperature, salinity, ...)
c
c     mnisle = maximum number of islands (unconnected land masses)
c
c     maxipp = maximum number of all island perimeter points
c-----------------------------------------------------------------------
c                                                                       
      parameter (imt=  92, jmt=  61, km= 15)
      parameter (nt=2)
      parameter (nat=2)
      parameter (mnisle=50, maxipp=5000)
c

c






c
c-----------------------------------------------------------------------
c     END USER INPUT
c-----------------------------------------------------------------------
c                                                                       
c-----------------------------------------------------------------------
c     By default, the MW (memory window) is 2nd order except for the
c     following options which require a 4th order MW 
c
c     for 2nd order schemes, the minimum sized MW is 3 latitude rows
c     for 4th order schemes, the minimum sized MW is 4 latitude rows
c                            (5 if using coarse_grained_parallelism)
c-----------------------------------------------------------------------
c













c
c-----------------------------------------------------------------------
c     set MW (memory window) size "jmw" 
c-----------------------------------------------------------------------
c                                                                       

c
c     for UNI-TASKING: "jmw" is set to the minimum for each option class 
c     "jmw" may be increased up to "jmt" 
c

      parameter (jmw=jmt)


c
c-----------------------------------------------------------------------
c     set first and last calculated row within the MW. other rows
c     are used as buffers
c-----------------------------------------------------------------------
c
c     jsmw   = 1st calculated row within the MW     
c     jemw   = last calculated row within the MW
c
      parameter (jsmw=2, jemw=jmw-1)
c
c
c     jextra = extra buffer rows needed for coarse_grained_parallelism.
c              "jextra" rows are added to the top and bottom of the MW
c              so the MW size increases by 2*jextra       
c

          parameter (jextra = 0)




c
c     nvar   = number of prognostic variables
c     lseg   = maximum number of longitudinal stream function segments
c     nlatpr = maximum number of latitudes for matrix printouts
c              on diagnostic time steps
c     nhreg  = number of regions in the horizontal used for averaging
c              tracers.
c     nvreg  = number of regions in the vertical used for term balance
c              calculations. note "nvreg" isn`t used for tracer averages
c     numreg = total number of regions ( = product of nhreg & nvreg)
c              used for term balance calculations
c
      parameter (lseg=5, nlatpr=10)

      parameter (nhreg=5, nvreg=2, numreg=nhreg*nvreg)

      parameter (nvar=nt+2)
c

c
      parameter (imtm1=imt-1, kmm1=km-1)                                
      parameter (imtp1=imt+1, imtm2=imt-2
     &,          jmtp1=jmt+1, jmtm1=jmt-1, jmtm2=jmt-2

     &,          jscan=jmtm2

     &,          kmp1=km+1, kmp2=km+2
     &,          imtkm=imt*km, nwds=imt*jmt, nkflds=2
     &,          nslab=imt*nvar*km, ntmin2=nt+1/nt)
c
c     include parameter constants
c
c====================== include file "pconst.h" ========================
c
c
c     rules for parameter constants
c
c     use prefix of "c" for whole real numbers (eg: c57 for 57.0)
c     use "m" after prefix to designate negative values (minus sign)
c       (eg: cm7 for -7.0)
c     use prefix of "p" for non repeating fractions (eg: p5 for 0.5)
c     use prefix of "r" for reciprocals (eg: r3 for 1/3.0)
c     combine use of prefix above and "e" for scientific notation, with
c       (eg: c5e4 for 5.0e4, c1em10 for 1.0e-10)
c
      parameter (c0=0.0, c1=1.0, c2=2.0, c3=3.0, c4=4.0, c5=5.0, c7=7.0)
      parameter (c8=8.0)
      parameter (c14=14.0, c16=16.0, c360=360.0)
      parameter (p125=0.125, p25=0.25, p5=0.5, p75=0.75)
      parameter (epsln=1.0e-20)
c
      parameter (c24=24.0, c60=60.0, c1440=1440.0)
      parameter (r24=c1/c24, r60=c1/c60, r1440=c1/c1440)
      parameter (secday=c1/(c60*c1440))
c
c     include standard I/O units
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c
c     ncrows = number of calculated rows within the MW.
c              (the remaining rows are buffer rows). 
c


      parameter (ncrows = jmw - 2)


c====================== include file "grdvar.h" ========================
c
c     variables which are functions of the grid defined by "coord.h"
c
c     dxt     = longitudinal width of "t" grid box at the 
c               equator (in cm)
c     dxtr    = reciprocal of "dxt"
c     dxt2r   = reciprocal of "2*dxt"
c     dxt4r   = reciprocal of "4*dxt"
c     dxu     = longitudinal width of "u,v" grid box at the 
c               equator (in cm)
c     dxur    = reciprocal of "dxu"
c     dxu2r   = reciprocal of "2*dxu"
c     dxu4r   = reciprocal of "4*dxu"
c     dxmetr  = reciprocal of "(dxt(i)+dxt(i+1))"
c     duw     = xu(i) - xt(i)
c     due     = xt(i+1) - xu(i)
c     dus     = yu(jrow) - yt(jrow)
c     dun     = yt(jrow+1) - yu(jrow)
c
c     dyt     = latitudinal height of "t" grid box (in cm)
c     dytr    = reciprocal of "dyt"
c     dyt2r   = reciprocal of "2*dyt"
c     dyt4r   = reciprocal of "4*dyt"
c     dyu     = latitudinal height of "u,v" grid box (in cm)
c     dyur    = reciprocal of "dyu"
c     dyu2r   = reciprocal of "2*dyu"
c     dyu4r   = reciprocal of "4*dyu"
c
c     csu     = cosine of "u,v" grid point latitude
c     csur    = reciprocal of "csu"
c     cst     = cosine of "t" grid point latitude
c     cstr    = reciprocal of "cst"
c     phi     = latitude of "u,v" grid point in radians
c     phit    = latitude of "t" grid point in radians
c     sine    = sine of "u,v" grid point latitude
c     tng     = tan of "u,v" grid point latitude
c     fcor    = 2*omega*sine(j)
c
c     c2dzt(k)= "2*dzt"
c     dztr(k) = reciprocal of dzt ("t" cell vertical resolution)
c     dzt2r(k)= reciprocal of "2*dzt"
c     dzwr(k) = reciprocal of dzw ("w" cell vertical resolution)
c     dzw2r(k)= reciprocal of "2*dzw"
c     dztur(k)= upper diffusion grid factor = 1.0/(dzw(k-1)*dzt(k))
c     dztlr(k)= lower diffusion grid factor = 1.0/(dzw(k)*dzt(k))
c     dzwur(k)= upper diffusion grid factor = 1.0/(dzt(k)*dzw(k))
c     dzwlr(k)= lower diffusion grid factor = 1.0/(dzt(k+1)*dzw(k))
c     
      common /grdvar/ dxt(imt),  dxtr(imt),  dxt2r(imt), dxu(imt)
      common /grdvar/ dxur(imt), dxu2r(imt), dxu4r(imt), dxt4r(imt)
      common /grdvar/ dyt(jmt),  dytr(jmt),  dyt2r(jmt), dyu(jmt)
      common /grdvar/ dyur(jmt), dyu2r(jmt), dyu4r(jmt), dyt4r(jmt)
      common /grdvar/ csu(jmt),  csur(jmt),  cst(jmt),   cstr(jmt)
      common /grdvar/ cstdytr(jmt), cstdyt2r(jmt)
      common /grdvar/ csudyur(jmt), csudyu2r(jmt)
      common /grdvar/ cst_dytr(jmt), csu_dyur(jmt)
      common /grdvar/ phi(jmt),  phit(jmt),  sine(jmt),  tng(jmt)
      common /grdvar/ fcor(jmt), c2dzt(km),  dztr(km),   dzt2r(km) 
      common /grdvar/ dzwr(0:km), dzw2r(0:km)
      common /grdvar/ dxmetr(imt), duw(imt), due(imt)
      common /grdvar/ dun(jmt), dus(jmt)


c

c====================== include file "levind.h" ========================
c
c     vertical level indicators which define model geometry & bottom
c     topography:
c
c     kmt = number of vertical boxes over "t" points
c     kmu = number of vertical boxes over "u,v" points
c
      common /levind/ kmt(imt,jmt), kmu(imt,jmt)
c
c
      real data(imt,jmt)
c
      tarea = 0.0
      tdata = 0.0
      avg = 0.0
c
      do j=2,jmtm1
        fx = cst(j)*dyt(j)
        do i = 2,imtm1
          if (kmt(i,j) + land  .gt. 0) then
            area = dxt(i)*fx
            tarea = tarea + area
            tdata = tdata + data(i,j)*area
          endif
        enddo
      enddo
      if (tarea .ne. 0.0) avg = tdata/tarea
c
      return
      end


      subroutine zonal (data, land, zavg)
c
c=======================================================================
c     calculate the zonal area integral of data
c     based on code by a.fanning
c
c     input:
c       data = data to be averaged
c       land = flag for land (0=exclude 1=include)
c     output:
c       zavg = zonal average
c
c     author:   m.eby   e-mail: eby@uvic.ca
c=======================================================================
c
c====================== include file "param.h" =========================
c
c     main parameter file which sets ocean characteristics:
c
c     "size.h" sets model size "imt", "jmt", and "km"
c
c====================== include file "size.h" ==========================
c                                                                       
c-----------------------------------------------------------------------
c     USER INPUT: 
c-----------------------------------------------------------------------
c
c     imt    = number of grid points in the longitudinal direction
c              (calculated points are from 2 through imt-1. End points
c               are boundaries)          
c
c     jmt    = number of grid points (latitude rows) in the latitudinal
c              direction (calculated points are from 2 through jmt-1.           
c              End points are boundaries)   
c                                
c     km     = number of grid points in the vertical direction          
c              (calculated points are from 1 through km)
c
c     nt     = number of tracers (temperature, salinity, ...)
c
c     mnisle = maximum number of islands (unconnected land masses)
c
c     maxipp = maximum number of all island perimeter points
c-----------------------------------------------------------------------
c                                                                       
      parameter (imt=  92, jmt=  61, km= 15)
      parameter (nt=2)
      parameter (nat=2)
      parameter (mnisle=50, maxipp=5000)
c

c






c
c-----------------------------------------------------------------------
c     END USER INPUT
c-----------------------------------------------------------------------
c                                                                       
c-----------------------------------------------------------------------
c     By default, the MW (memory window) is 2nd order except for the
c     following options which require a 4th order MW 
c
c     for 2nd order schemes, the minimum sized MW is 3 latitude rows
c     for 4th order schemes, the minimum sized MW is 4 latitude rows
c                            (5 if using coarse_grained_parallelism)
c-----------------------------------------------------------------------
c













c
c-----------------------------------------------------------------------
c     set MW (memory window) size "jmw" 
c-----------------------------------------------------------------------
c                                                                       

c
c     for UNI-TASKING: "jmw" is set to the minimum for each option class 
c     "jmw" may be increased up to "jmt" 
c

      parameter (jmw=jmt)


c
c-----------------------------------------------------------------------
c     set first and last calculated row within the MW. other rows
c     are used as buffers
c-----------------------------------------------------------------------
c
c     jsmw   = 1st calculated row within the MW     
c     jemw   = last calculated row within the MW
c
      parameter (jsmw=2, jemw=jmw-1)
c
c
c     jextra = extra buffer rows needed for coarse_grained_parallelism.
c              "jextra" rows are added to the top and bottom of the MW
c              so the MW size increases by 2*jextra       
c

          parameter (jextra = 0)




c
c     nvar   = number of prognostic variables
c     lseg   = maximum number of longitudinal stream function segments
c     nlatpr = maximum number of latitudes for matrix printouts
c              on diagnostic time steps
c     nhreg  = number of regions in the horizontal used for averaging
c              tracers.
c     nvreg  = number of regions in the vertical used for term balance
c              calculations. note "nvreg" isn`t used for tracer averages
c     numreg = total number of regions ( = product of nhreg & nvreg)
c              used for term balance calculations
c
      parameter (lseg=5, nlatpr=10)

      parameter (nhreg=5, nvreg=2, numreg=nhreg*nvreg)

      parameter (nvar=nt+2)
c

c
      parameter (imtm1=imt-1, kmm1=km-1)                                
      parameter (imtp1=imt+1, imtm2=imt-2
     &,          jmtp1=jmt+1, jmtm1=jmt-1, jmtm2=jmt-2

     &,          jscan=jmtm2

     &,          kmp1=km+1, kmp2=km+2
     &,          imtkm=imt*km, nwds=imt*jmt, nkflds=2
     &,          nslab=imt*nvar*km, ntmin2=nt+1/nt)
c
c     include parameter constants
c
c====================== include file "pconst.h" ========================
c
c
c     rules for parameter constants
c
c     use prefix of "c" for whole real numbers (eg: c57 for 57.0)
c     use "m" after prefix to designate negative values (minus sign)
c       (eg: cm7 for -7.0)
c     use prefix of "p" for non repeating fractions (eg: p5 for 0.5)
c     use prefix of "r" for reciprocals (eg: r3 for 1/3.0)
c     combine use of prefix above and "e" for scientific notation, with
c       (eg: c5e4 for 5.0e4, c1em10 for 1.0e-10)
c
      parameter (c0=0.0, c1=1.0, c2=2.0, c3=3.0, c4=4.0, c5=5.0, c7=7.0)
      parameter (c8=8.0)
      parameter (c14=14.0, c16=16.0, c360=360.0)
      parameter (p125=0.125, p25=0.25, p5=0.5, p75=0.75)
      parameter (epsln=1.0e-20)
c
      parameter (c24=24.0, c60=60.0, c1440=1440.0)
      parameter (r24=c1/c24, r60=c1/c60, r1440=c1/c1440)
      parameter (secday=c1/(c60*c1440))
c
c     include standard I/O units
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c
c     ncrows = number of calculated rows within the MW.
c              (the remaining rows are buffer rows). 
c


      parameter (ncrows = jmw - 2)


c====================== include file "grdvar.h" ========================
c
c     variables which are functions of the grid defined by "coord.h"
c
c     dxt     = longitudinal width of "t" grid box at the 
c               equator (in cm)
c     dxtr    = reciprocal of "dxt"
c     dxt2r   = reciprocal of "2*dxt"
c     dxt4r   = reciprocal of "4*dxt"
c     dxu     = longitudinal width of "u,v" grid box at the 
c               equator (in cm)
c     dxur    = reciprocal of "dxu"
c     dxu2r   = reciprocal of "2*dxu"
c     dxu4r   = reciprocal of "4*dxu"
c     dxmetr  = reciprocal of "(dxt(i)+dxt(i+1))"
c     duw     = xu(i) - xt(i)
c     due     = xt(i+1) - xu(i)
c     dus     = yu(jrow) - yt(jrow)
c     dun     = yt(jrow+1) - yu(jrow)
c
c     dyt     = latitudinal height of "t" grid box (in cm)
c     dytr    = reciprocal of "dyt"
c     dyt2r   = reciprocal of "2*dyt"
c     dyt4r   = reciprocal of "4*dyt"
c     dyu     = latitudinal height of "u,v" grid box (in cm)
c     dyur    = reciprocal of "dyu"
c     dyu2r   = reciprocal of "2*dyu"
c     dyu4r   = reciprocal of "4*dyu"
c
c     csu     = cosine of "u,v" grid point latitude
c     csur    = reciprocal of "csu"
c     cst     = cosine of "t" grid point latitude
c     cstr    = reciprocal of "cst"
c     phi     = latitude of "u,v" grid point in radians
c     phit    = latitude of "t" grid point in radians
c     sine    = sine of "u,v" grid point latitude
c     tng     = tan of "u,v" grid point latitude
c     fcor    = 2*omega*sine(j)
c
c     c2dzt(k)= "2*dzt"
c     dztr(k) = reciprocal of dzt ("t" cell vertical resolution)
c     dzt2r(k)= reciprocal of "2*dzt"
c     dzwr(k) = reciprocal of dzw ("w" cell vertical resolution)
c     dzw2r(k)= reciprocal of "2*dzw"
c     dztur(k)= upper diffusion grid factor = 1.0/(dzw(k-1)*dzt(k))
c     dztlr(k)= lower diffusion grid factor = 1.0/(dzw(k)*dzt(k))
c     dzwur(k)= upper diffusion grid factor = 1.0/(dzt(k)*dzw(k))
c     dzwlr(k)= lower diffusion grid factor = 1.0/(dzt(k+1)*dzw(k))
c     
      common /grdvar/ dxt(imt),  dxtr(imt),  dxt2r(imt), dxu(imt)
      common /grdvar/ dxur(imt), dxu2r(imt), dxu4r(imt), dxt4r(imt)
      common /grdvar/ dyt(jmt),  dytr(jmt),  dyt2r(jmt), dyu(jmt)
      common /grdvar/ dyur(jmt), dyu2r(jmt), dyu4r(jmt), dyt4r(jmt)
      common /grdvar/ csu(jmt),  csur(jmt),  cst(jmt),   cstr(jmt)
      common /grdvar/ cstdytr(jmt), cstdyt2r(jmt)
      common /grdvar/ csudyur(jmt), csudyu2r(jmt)
      common /grdvar/ cst_dytr(jmt), csu_dyur(jmt)
      common /grdvar/ phi(jmt),  phit(jmt),  sine(jmt),  tng(jmt)
      common /grdvar/ fcor(jmt), c2dzt(km),  dztr(km),   dzt2r(km) 
      common /grdvar/ dzwr(0:km), dzw2r(0:km)
      common /grdvar/ dxmetr(imt), duw(imt), due(imt)
      common /grdvar/ dun(jmt), dus(jmt)


c

c====================== include file "levind.h" ========================
c
c     vertical level indicators which define model geometry & bottom
c     topography:
c
c     kmt = number of vertical boxes over "t" points
c     kmu = number of vertical boxes over "u,v" points
c
      common /levind/ kmt(imt,jmt), kmu(imt,jmt)
c
c
      real data(imt,jmt), zavg(jmt)
c
c
      do j = 2,jmtm1
        tarea = 0.0
        tdata = 0.0
        area = 0.0
        zavg(j) = 0.0
        fx = cst(j)*dyt(j)
        do i = 2,imtm1
          if (kmt(i,j) + land .gt. 0) then 
            area = dxt(i)*fx
            tdata = tdata + data(i,j)*area
            tarea = tarea + area
          endif
        enddo
        if (tarea .ne. 0.0) zavg(j) = tdata/tarea
      enddo

c
      return
      end
      subroutine embmout
c
c=======================================================================
c     output routine for energy-moisture balance model
c     based on code by a.fanning
c
c     author:   m.eby   e-mail: eby@uvic.ca
c=======================================================================
c

c====================== include file "param.h" =========================
c
c     main parameter file which sets ocean characteristics:
c
c     "size.h" sets model size "imt", "jmt", and "km"
c
c====================== include file "size.h" ==========================
c                                                                       
c-----------------------------------------------------------------------
c     USER INPUT: 
c-----------------------------------------------------------------------
c
c     imt    = number of grid points in the longitudinal direction
c              (calculated points are from 2 through imt-1. End points
c               are boundaries)          
c
c     jmt    = number of grid points (latitude rows) in the latitudinal
c              direction (calculated points are from 2 through jmt-1.           
c              End points are boundaries)   
c                                
c     km     = number of grid points in the vertical direction          
c              (calculated points are from 1 through km)
c
c     nt     = number of tracers (temperature, salinity, ...)
c
c     mnisle = maximum number of islands (unconnected land masses)
c
c     maxipp = maximum number of all island perimeter points
c-----------------------------------------------------------------------
c                                                                       
      parameter (imt=  92, jmt=  61, km= 15)
      parameter (nt=2)
      parameter (nat=2)
      parameter (mnisle=50, maxipp=5000)
c

c






c
c-----------------------------------------------------------------------
c     END USER INPUT
c-----------------------------------------------------------------------
c                                                                       
c-----------------------------------------------------------------------
c     By default, the MW (memory window) is 2nd order except for the
c     following options which require a 4th order MW 
c
c     for 2nd order schemes, the minimum sized MW is 3 latitude rows
c     for 4th order schemes, the minimum sized MW is 4 latitude rows
c                            (5 if using coarse_grained_parallelism)
c-----------------------------------------------------------------------
c













c
c-----------------------------------------------------------------------
c     set MW (memory window) size "jmw" 
c-----------------------------------------------------------------------
c                                                                       

c
c     for UNI-TASKING: "jmw" is set to the minimum for each option class 
c     "jmw" may be increased up to "jmt" 
c

      parameter (jmw=jmt)


c
c-----------------------------------------------------------------------
c     set first and last calculated row within the MW. other rows
c     are used as buffers
c-----------------------------------------------------------------------
c
c     jsmw   = 1st calculated row within the MW     
c     jemw   = last calculated row within the MW
c
      parameter (jsmw=2, jemw=jmw-1)
c
c
c     jextra = extra buffer rows needed for coarse_grained_parallelism.
c              "jextra" rows are added to the top and bottom of the MW
c              so the MW size increases by 2*jextra       
c

          parameter (jextra = 0)




c
c     nvar   = number of prognostic variables
c     lseg   = maximum number of longitudinal stream function segments
c     nlatpr = maximum number of latitudes for matrix printouts
c              on diagnostic time steps
c     nhreg  = number of regions in the horizontal used for averaging
c              tracers.
c     nvreg  = number of regions in the vertical used for term balance
c              calculations. note "nvreg" isn`t used for tracer averages
c     numreg = total number of regions ( = product of nhreg & nvreg)
c              used for term balance calculations
c
      parameter (lseg=5, nlatpr=10)

      parameter (nhreg=5, nvreg=2, numreg=nhreg*nvreg)

      parameter (nvar=nt+2)
c

c
      parameter (imtm1=imt-1, kmm1=km-1)                                
      parameter (imtp1=imt+1, imtm2=imt-2
     &,          jmtp1=jmt+1, jmtm1=jmt-1, jmtm2=jmt-2

     &,          jscan=jmtm2

     &,          kmp1=km+1, kmp2=km+2
     &,          imtkm=imt*km, nwds=imt*jmt, nkflds=2
     &,          nslab=imt*nvar*km, ntmin2=nt+1/nt)
c
c     include parameter constants
c
c====================== include file "pconst.h" ========================
c
c
c     rules for parameter constants
c
c     use prefix of "c" for whole real numbers (eg: c57 for 57.0)
c     use "m" after prefix to designate negative values (minus sign)
c       (eg: cm7 for -7.0)
c     use prefix of "p" for non repeating fractions (eg: p5 for 0.5)
c     use prefix of "r" for reciprocals (eg: r3 for 1/3.0)
c     combine use of prefix above and "e" for scientific notation, with
c       (eg: c5e4 for 5.0e4, c1em10 for 1.0e-10)
c
      parameter (c0=0.0, c1=1.0, c2=2.0, c3=3.0, c4=4.0, c5=5.0, c7=7.0)
      parameter (c8=8.0)
      parameter (c14=14.0, c16=16.0, c360=360.0)
      parameter (p125=0.125, p25=0.25, p5=0.5, p75=0.75)
      parameter (epsln=1.0e-20)
c
      parameter (c24=24.0, c60=60.0, c1440=1440.0)
      parameter (r24=c1/c24, r60=c1/c60, r1440=c1/c1440)
      parameter (secday=c1/(c60*c1440))
c
c     include standard I/O units
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c
c     ncrows = number of calculated rows within the MW.
c              (the remaining rows are buffer rows). 
c


      parameter (ncrows = jmw - 2)


c====================== include file "csbc.h" ==========================
c
c                    surface boundary conditions (S.B.C.)
c
c
c     numosbc = number of ocean S.B.C..
c
c     numasbc = number of atmospheric S.B.C..
c
c     maxsbc  = maximum number of allowable S.B.C. fields.
c
c     numsbc  = total number of S.B.C. this is the sum of the 
c               atmosphere S.B.C. and ocean S.B.C. fields. it must
c               be less than or equal to "maxsbc".
c
c     sbcocn  = S.B.C. fields on the ocean grid.
c               n=1..numosbc are for the incoming ocean S.B.C.
c               n=numosbc+1..numosbc+numasbc are for the outgoing S.B.C.
c

c
c     ntspos  = number of time steps per ocean segment
c
c     sbcname  = S.B.C. character string names (eg: "SST", "taux", etc)
c               note that these character strings should be changed with
c               care since they are used to identify fields for special
c               treatment
c
c     dunits  = dimensional units for S.B.C. (eg: "deg C")
c
c     mapsbc  = indices for relating how S.B.C. fields are stored
c               within arrays "sbcocn" and "sbcatm"  
c               eg: m = mapsbc(n) where sbcocn(,,m) is S.B.C. "n"
c
c     restrictions on re-arranging S.B.C. fields and "mapsbc":
c
c     1) all ocean S.B.C. (taux, tauy, etc) should be grouped together. 
c        relative ordering within the group is unimportant but the
c        group must preceed the atmos S.B.C. group.
c
c     2) all atmos S.B.C. (sst, ...) should also be grouped together.
c        relative ordering within the group is unimportant.
c
c     the default arrangement is defined as:
c
c             (these five ocean S.B.C. come from the atmos )
c     mapsbc(1) references taux
c     mapsbc(2) references tauy
c     mapsbc(3) references heat flux
c     mapsbc(4) references salt flux
c      if the atmos supplied fresh water flux then it
c      would have to be converted to ...
c      salt flux  = -(P-E+R) * rho * Sref
c      where...
c      P-E+R represents a precipitation minus evaporation
c            plus runoff rate in cm of water/sec
c      rho is the density if water taken to be 1 g/cm**3, and
c      Sref is a reference salinity in units of grams of salt per
c            gram of water (in units of "parts per part" such
c            as 0.035 ... not "parts per thousand")
c      Depending upon the application of interest, users may wish
c      to set Sref to either be a constant over the entire model
c      domain or for it to be the locally predicted salinity of
c      the uppermost model level (S(1)).  If one desires to ensure
c      that a global average P-E+R flux of zero translates to zero
c      trend in the salt content of the ocean, then a constant Sref
c      is needed.      
c     mapsbc(5) references short wave
c
c             (these four atmos S.B.C. come from the ocean)
c     mapsbc(6) references SST
c     mapsbc(7) references SSS
c     mapsbc(8) references surface u
c     mapsbc(9) references surface v
c
c
c     when re-ordering S.B.C., search for "mapsbc"  
c     (eg: grep mapsbc *.F) to insure the new indexing is consistant
c     with the re-ordering. also make changes in "sbcname", "dunits", 
c     "coabc", and "crits" to maintain consistancy.
c
c     example 1: suppose you want only the first six S.B.C...
c                in "csbc.h", set  numosbc=5, numasbc=1
c                this reduces memory requirements.
c                no other changes are necessary
c
c     example 2: suppose you want to remove the short wave boundary
c                condition (to save more memory) from example 1 . 
c                a) in "csbc.h", set numosbc=4, numasbc=1
c                b) grep "mapsbc(5)" *.F to find and remove references
c                c) grep "mapsbc(6)" *.F to change references to 
c                                        mapsbc(5)
c
c     
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c
c
      logical asegs, asege, afirst, alast
      character*10 sbcname
      character*15 dunits
c
      parameter (numosbc=5
     &,          numasbc=4
     &,          maxsbc=numosbc+numasbc, numsbc=maxsbc)
c
      common /csbc/ sbcocn(imt,jmt,numsbc) 
      common /csbc/ dampts(nt), dampdz(nt)
      common /csbc/ coabc(maxsbc), crits(maxsbc)
      common /csbc1/ mapsbc(maxsbc), numpas, iombc, ntspos, ntspas
      common /csbc2/ sbcname(maxsbc), dunits(maxsbc)
      common /csbc3/ asegs, asege, afirst, alast 
c
c====================== include file "mapsbc.h" ========================
c
c     indicies for surface boundary condition arrays.  names must be
c     unique and are set at the begining of "driver"
c
c     itaux is the x component of wind stress
c     itauy is the y component of wind stress
c     ihflx is heat flux
c     ipme is for precipitation minus evaporation
c     ipsw is for penitrating shortwave (into ocean first layer)
c     isst is the ocean model SST
c     isss is the ocean model SSS
c     isu is the x component of the ocean model first layer velocity
c     isv is the y component of the ocean model first layer velocity
c     it10 is the 10 metre atmopheric temperature
c     iq10 is the 10 metre atmopheric humidity
c     ilwr is incoming longwave radiation
c     iswr is incoming shortwave radiation
c     igu is the x component of the ocean model second layer velocity
c     igv is the y component of the ocean model second layer velocity
c
      common /mapsbc/ itaux, itauy, ihflx, ipme, ipsw, isst, isss
     &,               isu, isv, it10, iq10, ilwr, iswr, igu, igv
c
c====================== include file "atm.h" ===========================
c
c     arrays for the energy-moisture balance model
c
c     note: units for heat flux are in g/cm**2/s**3/cm**2 or (mW/m**2)
c           units for fresh water flux are in cm/s
c           downward is into the surface (ocean, ice or land)
c           upward is into the bottom of the atmosphere
c           outward is out of the top of the atmosphere
c           inward is into the top of the atmosphere
c
c     outlwr(imt,jmt)	 = outgoing atmosphere longwave flux
c     at(imt,jmt,2,nat)	 = tracers (previous and most recent)
c     surf(imt,jmt,nat)	 = surface values (1=temperature, 2=humidity)
c     flux(imt,jmt,nat)	 = downward flux (1=heat, 2=fresh water)
c     precip(imt,jmt)	 = precipitation
c     evap(imt,jmt)	 = evaporation
c     dnswr(imt,jmt)  	 = downward surface shortwave flux
c     uplwr(imt,jmt)  	 = upward surface longwave flux
c     upsens(imt,jmt)	 = upward surface sensible heat flux
c     upltnt(imt,jmt)    = upward surface latent heat flux
c     ssh(imt,jmt) 	 = saturation specific humidity
c     spd(imt,jmt) 	 = wind speed (cm/sec)
c     da(jmt,nat)	 = tracer diffusivity parameterization
c     coalbedo(jmt)	 = planetary coalbedo
c     solins(jmt)	 = solar insolation (units of solarconst)
c     esatm(jmt)	 = atmosphere emissivity times Stefan's constant
c     scatter(jmt)	 = solar scattering into atmosphere





c     cori(jmt,2)	 = Coriolis parameter

c
      real outlwr(imt,jmt), at(imt,jmt,3,nat), surf(imt,jmt,nat)
      real flux(imt,jmt,nat), precip(imt,jmt), evap(imt,jmt)
      real dnswr(imt,jmt), uplwr(imt,jmt), upsens(imt,jmt)
      real upltnt(imt,jmt), ssh(imt,jmt), spd(imt,jmt), da(jmt,nat)
      real coalbedo(jmt), solins(jmt), esatm(jmt), scatter(jmt)





      real cori(jmt,2)
c
      common /atm/ outlwr, at, surf, flux, precip, evap, dnswr, uplwr
     &,            upsens, upltnt, spd, ssh, da, coalbedo, solins
     &,            esatm, scatter





     &,            cori
c
c====================== include file "coord.h" =========================
c
c                    model grid point coordinates
c
c     grid definition:
c
c     the model uses a staggard arakawa "b" grid which is setup and 
c     generated by the "grids.F" module. 
c
c     xt(i)   = longitude of the ith "t" point in degrees.   i=1..imt
c     xu(i)   = longitude of the ith "u,v" point in degrees. i=1..imt
c     yt(j)   = latitude of the jth "t" point in degrees.    j=1..jmt
c     yu(j)   = latitude of the jth "u,v" point in degrees.  j=1..jmt
c     zt(k)   = distance from surface down to center of level k (in cm)
c               (for depth of "t" and "u,v" grid points: k=1,km)
c     zw(k)   = distance from surface down to bottom of level k (in cm)
c               (for depth of "t" and "u,v" grid points: k=1,km)
c     dxtdeg  = widths for "t" grid cells (degrees)
c     dytdeg  = heights for "t" grid cells (degrees)
c     dxudeg  = widths for "u" grid cells (degrees)
c     dyudeg  = heights for "u" grid cells (degrees)
c     dzt(k)  = vertical resolution of "t" and "u" grid cells (in cm)
c     dzw(k)  = vertical resolution of "w" grid cells (in cm)
c
c     "i" increases in an eastward direction, "j" increases in a
c     northward direction, and "k" increases downward.
c     
      common /coord/ xt(imt), yt(jmt), xu(imt), yu(jmt), zw(km), zt(km)
      common /coord/ dxtdeg(imt), dytdeg(jmt), dzt(km)
      common /coord/ dxudeg(imt), dyudeg(jmt), dzw(0:km)
c

c====================== include file "cembm.h" =========================
c
c     parameters for use in the energy balance model (also see atm.h)
c
c     addflux		= logical flag for adding only even mode fluxes
c     nats		= number of atmospheric time steps since mixing
c     namix		= time steps between mixing (set in atmos.in)
c     lf		= time step flag (1=>leapfrog, 2=>forward)
c     pyear		= calendar year (set in atmos.in, -/+ = BC/AD)
c     dtatm 		= time step for atmosphere (set in atmos.in)
c     dts		= time step (2*dtatm=>leapfrog, dtatm=>forward)
c     co2ccn		= CO2 concentration
c     anthro		= radiative forcing by CO2
c     co2ccni		= initial CO2 concentration
c     co2yri		= last year of initial CO2 concentration
c     co2ccnf		= final CO2 concentration
c     co2yrf		= first year of final CO2 concentration
c     solarconst	= solar constant (g/s**3)
c     ssp		= sea surface pressure (g/cm/s**2)
c     cdatm 		= drag coefficient (dimensionless)
c     cpatm		= atmospheric heat capacity (cm**2/s**2/K)
c     ht		= scale height for temperature
c     hq		= scale height for specific humidity
c     rhoatm		= density of air at sea surface (g/cm**3)
c     rhoocn		= representative sea surface density
c     esocn		= ocean emissivity times Stefan's constant 
c     vlocn		= latent heat of vaporization of water
c     socn		= constant ocean salinity
c     cdice 		= drag coefficient (dimensionless)
c     rhoice		= ice density (g/cm**3)
c     esice		= ice emissivity times Stefan's constant 
c     slice		= latent heat of sublimation of ice
c     flice		= latent heat of fusion of ice (cm**2/s**2)
c     condice		= ice conductivity (g*cm/s**3/K)
c     kadv		= time step divider for ice advection
c     ntats		= time step counter for time averaging
c     avetime		= time for averaging fluxes
c     totaltime		= total time for long term averages
c
      logical addflux
c
      common /cembm/ addflux
      common /cembm/ nats, namix, lf, kadv, ntats
      common /cembm/ pyear, dtatm, dts, co2ccn, anthro, co2ccni, co2yri
     &,              co2ccnf, co2yrf, solarconst, ssp, cdatm, cpatm, ht
     &,              hq, rhoatm, rhoocn, esocn, vlocn, socn, cdice
     &,              rhoice, esice, slice, flice, condice, avetime 
     &,              totaltime
c
c====================== include file "cfile.h" =========================
c
c     file parameters and names
c
c     "ocean.in", "ice.in", "atmos.in" and "files.in" must be in the 
c     directory in which the model is running
c     paths and file names can be set through these namelist files
c
c     if additional file names are required, they should be added to 
c     the common block below,  defined in "setocn.F" or "setice.F" 
c     or "setatm.F" and added to the namelists defined in subroutine
c     "pathfile" (in util.F)
c
c     nsfc    = number of snapshot files counter 
c     nwsfc   = number of writes to a snapshot file counter 
c     ntafc   = number of tracer average files counter 
c     mxnsf   = maximum number snapshot files before resetting counter
c     mxnwsf  = maximum number of writes to a snapshot before renaming
c
c     focean  = namelist file for ocean parameters (ocean.in)
c     flat    = latitude data file name
c     fgrid   = flexible grid data file name
c     fcurv   = curvilinear grid data file name
c     fkmt    = levels data file name
c     ftemp   = initial temperature data file name
c     fsalt   = initial salinity data file name
c     ftaux   = x component of wind stress data file name
c     ftauy   = y component of wind stress data file name
c     fhflx   = surface heat flux data file name
c     fsflx   = surface salt flux data file name
c     fsst    = surface temperature data file name
c     fsss    = surface salinity data file name
c     fsnapo  = snapshot file name for the ocean
c     ftavgo  = time average file name for the ocean
c     fresto  = restart file name for the ocean
c     pocnin  = path for ocean input files
c     pocnout = path for ocean output files
c
c     fice    = namelist file for ice parameters (ice.in)
c     ft10    = atmospheric temperature at 10 m
c     fq10    = atmospheric humidity at 10 m
c     fswr    = incoming shortwave radiation
c     flwr    = incoming longwave radiation
c     fsnapi  = snapshot file name for the ice
c     fresti  = restart file name for the ice
c     picein  = path for ice input files
c     piceout = path for ice output files
c
c     fatmos  = namelist file for atmospheric parameters (atmos.in)
c     friver  = river file for atmospheric model
c     fwspd   = wind speed for atmospheric model
c     ftbar   = average air temperature for atmospheric model
c     fqbar   = average specific humidity for atmospheric model
c     frtbar  = run average air temperature for atmospheric model
c     frqbar  = run average specific humidity for atmospheric model
c     felev   = land elevations for modifying saturation humidity 
c     fsnapa  = snapshot file name for the atmosphere
c     ftavga  = time average file name for the atmosphere
c     fresta  = restart file name for the atmosphere
c     patmin  = path for atmosphere input files
c     patmout = path for atmosphere output files
c
c     ffiles  = namelist file of file names
c     pf      = path + file name
c
      character*15 focean, flat, fgrid, fcurv, fkmt 
     &,            ftemp, fsalt, ftaux, ftauy, fhflx, fsflx
     &,            fsst, fsss, fsnapo, ftavgo, fresto
     &,            fice, ft10, fq10, fswr, flwr, fsnapi, fresti
     &,            fatmos, friver, fwspd, ftbar, fqbar, felev
     &,            frtbar, frqbar, fsnapa, ftavga, fresta
     &,            ffiles
c
      character*45 pocnin, pocnout, picein, piceout, patmin, patmout
      character*60 pf
c
      common /cfile/ nsfc, nwsfc, ntafc, mxnsf, mxnwsf
c
      common /cfile/ focean, flat, fgrid, fcurv, fkmt 
     &,              ftemp, fsalt, ftaux, ftauy, fhflx, fsflx
     &,              fsst, fsss, fsnapo, ftavgo, fresto
     &,              fice, ft10, fq10, fswr, flwr, fsnapi, fresti
     &,              fatmos, friver, fwspd, ftbar, fqbar, felev
     &,              frtbar, frqbar, fsnapa, ftavga, fresta
     &,              ffiles
     &,              pocnin, pocnout, picein, piceout, patmin, patmout
c====================== include file "levind.h" ========================
c
c     vertical level indicators which define model geometry & bottom
c     topography:
c
c     kmt = number of vertical boxes over "t" points
c     kmu = number of vertical boxes over "u,v" points
c
      common /levind/ kmt(imt,jmt), kmu(imt,jmt)
c
c====================== include file "switch.h" ========================
c
c     all time dependent decisions are made by time manager "tmngr.F"
c     and communicated elsewhere to the model via logical switches.
c
c     inputs: (defaulted in "blkdta.F", optionally reset via namelist)
c
c
c     runlen  = integration period (see rununits). note "runlen" should
c               be an integral number of density time steps. if not,
c               then "runlen" is automatically adjusted to insure this.
c               fractional days are supported but not fractional months
c               or years.
c     rununits= units of "runlen". may be "days", "months", or "years".
c               tmngr will convert "runlen" which is in "rununits"
c               to "rundays" in units of days.
c
c     segtim  = the integration time "runlen" is broken into a number of
c               segments each of length "segtim" days. updated surface
c               boundary conditions are applied to MOM every "segtim" 
c               days. this is useful when coupling to atmospheric models
c               in which case both models exchange surface boundary
c               conditions every "segtim" days where "segtim"
c               is 1/(coupling frequency). without an atmospheric model,
c               when getting surface boundary conditions from data, 
c               "segtim" is set to the time step (in days) by mom.F. in
c               either case, "runlen" (in days) should be an integral
c               number of "segtim".     
c
c     nmix    = number of time steps between mixing timesteps. used
c               to damp timestep splitting due to centered leapfrog.
c
c     init    = (true,false)  indicates that this run is a
c               (start from initial conditions, restart)
c
c     restrt  = (true,false) = (do,don`t) write a restart at the end
c               of the run
c
c     eb      = (true,false) configures for the use of a 
c               (euler backward,forward) type mixing timestep
c
c-----------------------------------------------------------------------
c     inputs to tmngr.F: diagnostic intervals
c-----------------------------------------------------------------------
c
c     note: switches are used to control the interval between doing
c           diagnostics. units for all switches are in days. 
c           setting a switch < 0.0 disables whatever the switch is 
c           controlling. setting it = 0.0 causes the diagnostic to be 
c           done every time step, and setting it > 0.0 causes the 
c           diagnostic to be done repeatedly on the specified interval. 
c
c     cmixint = number of days between writing estimated mixing coeffs
c               on faces of T cells and U cells
c
c     crossint = number of days between writing diapycnal and isopycnal
c               components of flow
c
c     fctint = number of days between writing difference between 
c              FCT and leapfrog advection
c
c     densityint = number of days between writing density
c
c     exconvint = number of days between writing temperature rate of
c                 change due to explicit convection
c
c     glenint =  number of days between global energetics integrals.
c
c     trmbint =  number of days between momentum and tracer term
c                balances (global and regional).
c
c     itrmb   = (true,false) = (do,don`t) write regional mask info for
c               the term balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     gyreint =  number of days between calculation of tracer northward
c                transport.
c     igyre   = (true,false) = (do,don`t) write regional mask info for
c               the gyre diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     vmsfint =  number of days between calculation of vertical and
c                meridional stream function.
c
c     tyzint  =  number of days between calculation of zonally averaged
c                tracer components.
c
c     prxzint =  number of days between printouts of x-z data.
c
c     extint  =  number of days between printouts of external mode.
c
c     dspint  =  number of days between surface pressure calculation.
c                Note: only when "diagnostic_surface_height" is enabled.
c     dspper  = averaging period for "diagnostic_surface_height"
c
c     tavgint = number of days between regional tracer averages (under
c               horizontal regions).
c
c     itavg   = (true,false) = (do,don`t) write regional mask info for
c               the tracer average diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     tmbint  = number of days over which tracer equation in averaged
c               in depth and longitude to determine the meridional 
c               balance among storage, divergence, dissipation and 
c               forcing.
c     tmbper  = averaging period for "meridional_tracer_balance"
c
c     itmb    = (true,false) = (do,don`t) write "msktmb" for tracer
c               the meridional balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c
c     tsiint  = number of days between printing of time step integrals.
c
c     stabint = number of days between sampling for various stability
c               criteria.
c
c     snapint = number of days between writing instantaneous samples
c               of data from the MOM grid. note: only when "snapshots"
c               is enabled. see "iounit.h" for more details.
c               all data is at time level "tau" so it is one time step
c               before the date shown in "stamp".
c
c     timavgint= interval (days) for writing time mean data from
c               the "averaging" grid (only when "time_averages" is
c               enabled). if "timavgint" is not an integral number of
c               density time steps,"timavgint" is automatically adjusted
c               to insure this. if the number of days to integrate is
c               not an integral number of "timavgint" then the last
c               averaging period will be less than "timavgint" days.this 
c               may lead to one more averaging period than expected. 
c               see "iounit.h" for more details.
c     timavgper= averaging period for "time_averages"
c
c     xbtint  = averaging period (days) for writing XBT data (only when
c               "xbts" is enabled). if "xbtint" is not an integral
c               number of density time steps, "xbtint" is automatically
c               adjusted to insure this. if the number of days to 
c               integrate is not an integral number of "xbtint" then the
c               last averaging period will be less than "xbtint" days.
c               this may lead to one more averaging period than  
c               expected. see "iounit.h" for more details.
c     xbtper  = averaging period for "xbts"
c
c     zmbcint = number of days between calculation of zonal mean
c               surface boundary conditions (and related  quantities)
c
c     trajint = number of days between writing particle trajectories.
c               particle trajectories are always written on the last
c               time step of the run to allow for restarting.
c
c-----------------------------------------------------------------------
c     outputs from tmngr.F: logical switches
c-----------------------------------------------------------------------
c
c     rundays = integration time in days (from "runlen")
c
c     the following are logical counterparts to the above switches are 
c     set within "tmngr" every time step. logical switches control all
c     decisions about when to do things in MOM.
c
c     cmixts  = (false,true) = (don`t, do) do write estimated mixing
c               coefficients on this time step.
c               based on "cmixint".
c
c     crossts  = (false,true) = (don`t, do) write diapycnal and 
c               isopycnal components of flow on this time step.
c               based on "crossint".
c
c     fctts    = (false,true) = (don`t, do) write difference between 
c               FCT and leapfrog advection on this time step.
c               based on "fctint".
c
c     densityts  = (false,true) = (don`t, do) write density on this time
c               step. based on "densityint".
c               
c
c     exconvts  = (false,true) = (don`t, do) do write temperature change
c               due to explicit convection on this time step.
c               based on "exconvint".
c
c     glents  = (false,true) = (don`t, do) do calculation of global
c               energy integrals on this time step. based on "glenint".
c
c     trmbts  = (false,true) = (don`t, do) do calculation of momentum &
c               tracer term balance on this timestep. based on "trmbint"
c
c     gyrets  = (false,true) = (don`t, do) do calculation of tracer
c               northward transport on this timestep. based on "gyreint"
c
c     vmsfts  = (false,true) = (don`t, do) do calculation of vertical
c               and meridional stream function on this time step.
c               based on "vmsfint"
c
c     tyzts   = (false,true) = (don`t, do) do calculation of zonally
c               averaged tracer components on this time step.
c               based on "tyzint"
c
c     prxzts  = (false,true) = (don`t, do) do printouts of x-z data
c               on this time step. based on "prxzint"
c
c     extts  = (false,true) = (don`t, do) do printout of external mode
c               on this time step. based on "extint"
c
c     dspts  = (false,true) = (don`t, do) do calculation of diagnostic 
c              surface pressure on this time step. based on "dspint"
c               
c
c     stabts  = (false,true) = (don`t, do) test for stability on this
c               time step. based on "stabint"
c
c     tavgts  = (false,true) = (don`t do) do tracer averages on this
c               time step. based on "tavgint"
c
c     tmbts   = (false,true) = (don`t, do) write out tracer meridional .
c               balance on this time step. based on "tmbint"
c
c     tsits   = (false,true) = (don`t, do) print time step integrals
c               on this time step. based on "tsiint"
c
c     zmbcts  = (false,true) = (don`t, do) print zonal mean boundary
c               conditions on this time step.  based on "zmbcint"
c
c     trajts  = (false,true) = (don`t, do) print particle trajectories
c               on this time step. based on "trajint"
c
c     snapts  = (false,true) = (don`t, do) save a snapshot of the data
c               on this time step. based on "snapint"
c
c     timats  = (false,true) = (don`t, do) write time mean data
c               on this time step. based on "timavgint"
c                                          
c     xbtts   = (false,true) = (don`t, do) write averaged XBT data on
c               this time step based on "xbtint"
c
c
c     leapfrog= (false,true) on a (mixing, normal leapfrog) time step
c                based on "nmix"
c                                          
c     euler1  = true on the 1st pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     euler2  = true on the 2nd pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     forward = true on a forward time step. otherwise false
c		(applies when "eb" = false)		  
c                                          
c
c     the following logical switches are based on the model time step. 
c    
c     first   = (true,false) =  when it`s (the first, not the first)
c                               time step of a run
c     eots    = end of a time step. always true except for first
c               pass of an euler backward time step
c     eorun   = last time step of a run. always false except during the
c               last time step of the run.
c
c     eoday   = true when within 1/2 time step of the end of a day
c               else ... false
c     eoweek  = true when within 1/2 time step of the end of a 7 day
c               week (referenced to the start of a year) else ...false
c     eo2wks  = true when within 1/2 time step of the end of two weeks
c               (referenced to the start of a year) else ... false
c     midmon  = true when within 1/2 time step of the middle of a month
c               else ... false
c     eomon   = true when within 1/2 time step of the end of a month
c               else ... false
c     eoyear  = true when within 1/2 time step of the end of a year
c               else ... false
c     osegs   = true on the 1st time step of an ocean segment in mom.F
c               otherwise false.
c     osege  =  true on the last time step of an ocean segment in mom.F
c               otherwise false.
c
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c
c
      logical eb, leapfrog, euler1, euler2, forward, eots
      logical init, first, restrt
      logical itavg, itmb, itrmb, igyre
      character *8 rununits
c
      common /switcc/ rununits
      common /switcr/ runlen, rundays
      common /switci/ nmix
      common /switcl/ eb, leapfrog, euler1, euler2, forward, eots
      common /switcl/ init, first, restrt
      common /switcl/ itavg, itmb, itrmb, igyre
c
      logical          eoday, eoweek, eo2wks
      common /switci/ ieoday,ieoweek,ieo2wks
      common /switcl/  eoday, eoweek, eo2wks
c
      logical          eomon, midmon, eoyear, eorun
      common /switci/ ieomon,imidmon,ieoyear,ieorun
      common /switcl/  eomon, midmon, eoyear, eorun
c
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c     each interval switch needs three variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output (e.g,.  glenint)
c         2) a switch (logical) for the interval (e.g.,  glents )
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c         3) an index (integer)                       (e.g., iglenint)
c
c     the user must specify the interval [e.g., glenint] for diagnostic
c     output in units of days. tmngr sets the corresponding logical  
c     switch [e.g., glents] every time step. It is set to true when  
c     within half a time step of the requested interval, otherwise it is
c     false. All decisions relating to the interval [e.g., glenint]
c     are based on the logical switch [e.g., glents].
c           
c     internal time structures
c
c     The switch index [e.g., iglenint] is used to subsrcipt into  
c     internal arrays maintained by tmngr.F. The switch index is
c     allocated on the first call to function "alarm".
c     The array entry [e.g., iinterval(iglenint)] is a time index to the
c     internal representation of the interval [e.g., glenint].
c     The array entry [e.g., ialarm(iglenint)] is a time index to the
c     next time the alarm will be true.
c-----------------------------------------------------------------------
c
      logical           tavgts,    glents,    trmbts,   prxzts
      common /switcr/   tavgint,   glenint,   trmbint,  prxzint
      common /switci/  itavgint,  iglenint,  itrmbint, iprxzint
      common /switcl/   tavgts,    glents,    trmbts,   prxzts
c
      logical          extts,   trajts,   exconvts,   cmixts
      common /switcr/  extint,  trajint,  exconvint,  cmixint
      common /switci/ iextint, itrajint, iexconvint, icmixint
      common /switcl/  extts,   trajts,   exconvts,   cmixts
c
      logical          vmsfts,   gyrets,    tsits,   snapts,   fctts
      common /switcr/  vmsfint,  gyreint,   tsiint,  snapint,  fctint
      common /switci/ ivmsfint, igyreint,  itsiint, isnapint, ifctint
      common /switcl/  vmsfts,   gyrets,    tsits,   snapts,   fctts
c
      logical          tyzts
      common /switcr/  tyzint
      common /switci/ ityzint
      common /switcl/  tyzts
c
      logical          stabts,   zmbcts,   crossts,   densityts
      common /switcr/  stabint,  zmbcint,  crossint,  densityint
      common /switci/ istabint, izmbcint, icrossint, idensityint
      common /switcl/  stabts,   zmbcts,   crossts,   densityts
c
      logical          osegs,  osege
      common /switcr/          segtim
      common /switci/ iosegs, iosege
      common /switcl/  osegs,  osege
c   
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c              A N D   A V E R A G I N G   P E R I O D
c
c     each averaging period switch needs five variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output    (e.g. xbtint  )   
c         2) a switch (logical) for the interval         (e.g. xbtts   )
c         3) an averaging period (real)                  (e.g. xbtper  )   
c         4) a switch (logical) for accumulating         (e.g. xbtperts)
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switches
c
c         5) an index (integer)                         (e.g. ixbtint  )
c
c     The user must specify the interval [e.g., xbtint] for diagnostic
c     output in units of days and the averaging period [e.g., xbtper] 
c     in units of days. The averaging period may be less than or equal
c     to the interval. For example, if the interval is 30.0 days and the
c     averaging period is 5.0 days, results will be averaged over all
c     time steps within days 26, 27, 28, 29, and 30.  An averaging period
c     of 0.0 days averages over the last time step of the interval (as
c     does xbtper = dt), and an averaging period less than zero turns
c     the switches off for all time steps.  
c
c     The logical switch for writing output at the specified interval 
c     [e.g., xbtts] is set to true on the last time step of the 
c     averaging period. The logical switch for accumulating results
c     [e.g., xbtperts] is true for all time steps within the averaging
c     period, otherwise it is false. 
c
c     internal time structures
c
c     The index [e.g., ixbtint] is allocated on the first call to 
c     function "avg_alarm". The array element iperiod(ixbtint) is an
c     index to the time structure for the internal representation of 
c     "xbtper", and ilastsw(ixbtint) is the index of the switch that 
c     flags the last time step of the accumulation period.
c     Depending on use,  ilastsw(ixbtint) may either be the index
c     of another "named" switch or the index of a new switch
c     allocated on the first time step.
c     In the latter case, iinterval(ilastsw(ixbtint)) is the index of
c     the time structure where "xbtint" is stored in internal form,
c     and ialarm(ilastsw(ixbtint)) is the index of the time when an
c     accumulation period will next end.
c     The variable nextts(ixbtint) is true whenever the next
c     time step will begin the accumulation period.
c
c-----------------------------------------------------------------------
c
      logical         xbtts,     dspts,    tmbts,    timavgts
      logical         xbtperts,  dspperts, tmbperts, timavgperts
      common /switcr/ xbtint,    dspint,   tmbint,   timavgint
      common /switcr/ xbtper,    dspper,   tmbper,   timavgper
      common /switci/ixbtint,   idspint,  itmbint,  itimavgint
      common /switcl/ xbtts,     dspts,    tmbts,    timavgts
      common /switcl/ xbtperts,  dspperts, tmbperts, timavgperts
c
c-----------------------------------------------------------------------
c
c                 S W I T C H E S    B A S E D    O N    
c
c         C A L E N D A R   O R    P R E V I O U S    S W I T C H   
c
c               A N D   A V E R A G I N G    P E R I O D
c
c    
c
c     the following logical switches are based on any calendar or 
c     interval switch and an averaging period (in days). The  averaging
c     period must be less than or equal to the interval. The last
c     time step of the averaging period is at the end of the interval.
c     If the averaging period is set to zero, the averaging period
c     consists only of the last time period of the interval.  If
c     the averaging period is less than zero, these switches are always
c     false.
c
c     each averaging period switch needs four variables in common. For
c     example, if the averaging period is before the end of each month
c     then the calendar switch (eomon), and index (ieomon) are presumed
c     to exist in common and need not be added.
c     
c     Additionally, four items are needed.
c
c       1) an averaging period (real)                  (e.g.  testper  )   
c       2) a switch (logical) for accumulating results (e.g.  testperts)
c       3) a switch (logical) for the end of interval  (e.g.  testts   )
c
c     the fourth is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c       4) an index (integer)                          (e.g.  itestper )
c
c     Suppose it is required to produce averages over all time steps
c     during the last 5 days of each month. Then "testper" = 5.0 and 
c     the following will calculate the accumulating switch.
c
c      testts = avg_alarm(itestper, ihalfstep, 0, testper, iref, ieomon)
c      testperts = on(itestper)
c
c     Note the use of "ieomon" to key off the months.  The switch
c     "testts" will be true whenever "eomon" is true.
c     Also note that when an averaging switch is keyed off another
c     switch, the switch inverval argument is not used, but is 
c     retained for consistency with the form of other averaging
c     switches.
c-----------------------------------------------------------------------
c
      logical           testperts
      logical           testts
      common /switcr/   testint
      common /switcr/   testper
      common /switci/  itestper
      common /switcl/   testts
      common /switcl/   testperts

c
      parameter (maxsw=100)
      logical          on, lastts, nextts
      common /switci/  nsw  
      common /switci/  ialarm(maxsw), iinterval(maxsw), iperiod(maxsw)
     &,                ilastsw(maxsw)
      common /switcl/  on(maxsw), lastts(maxsw), nextts(maxsw)
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c


c



      character*3 a3
c


c-----------------------------------------------------------------------
c     write atmospheric diagnostics
c-----------------------------------------------------------------------
c
      if (tavgts) call atmdiag
c      
      if (tsits) then
        call areaavg (at(1,1,2,1), 1, tat1)
        call areaavg (at(1,1,2,2), 1, tat2)
        call areaavg (flux(1,1,1), 0, tfl1)
        call areaavg (flux(1,1,2), 0, tfl2)
        fa = 1.0/avetime
        fb = -socn*rhoocn/avetime

        write (*,'(1x, a, i7, 1x, a32, 4(a,1pe13.6))') 
     &    'ts=', itt, stamp, ' TAbar=', tat1, ' QAbar=', tat2
     &,   ' HFbar=', fa*tfl1, ' SFbar=', fb*tfl2


      endif

c
      if (snapts) then
c
c-----------------------------------------------------------------------
c       write atmospheric snapshot
c-----------------------------------------------------------------------
c
        do j=1,jmt
          do i=1,imt


          enddo
        enddo

c
c       set boundary conditions for output
c
        do n=1,nat
          call embmbc (at(1,1,2,n))
        enddo
        call embmbc (precip)
        call embmbc (evap)
        call embmbc (outlwr)
        call embmbc (uplwr)
        call embmbc (upsens)
        call embmbc (dnswr)
        call embmbc (upltnt)






        call embmbc (sbcocn(1,1,isst))
        call embmbc (sbcocn(1,1,isss))
        call embmbc (sbcocn(1,1,ihflx))
        call embmbc (sbcocn(1,1,ipme))
        call embmbc (sbcocn(1,1,itaux))
        call embmbc (sbcocn(1,1,itauy))
c
c       update counter
        nwsfc = nwsfc + 1
        if (nwsfc .gt. mxnwsf) then
c       reset writes counter and update snapshot counter
          nwsfc = 1
          nsfc = nsfc + 1
        endif
        if (nsfc .gt. mxnsf) then
c       reset snapshot counter
          nsfc = 1
        endif

c
c       create a new snapshot file name
c
        write(a3,'(i3)') nsfc
        fsnapa(6:8)  = '000'
        fsnapa(8:8) = a3(3:3)
        if (nsfc .ge. 10) fsnapa(7:8) = a3(2:3)
        if (nsfc .ge. 100) fsnapa(6:8) = a3(1:3)
c
c       write snapshot
c
        nfields = 11

     &          + 2


     &          + 4



     &          + 6

c
        write (*,'(a,a,a,i10,1x,a)') 
     &    ' ==>  Writing a snapshot of atmospheric data to file '
     &,   pf(1:len_trim(pf)), ' on ts=', itt, stamp
        write (ios) nfields
        write (ios) 'grid      '
        write (ios)  imt, jmt, nat, xt, xu, yt, yu
        write (ios) 'stamp     '
        write (ios)  stamp
        write (ios) 'kmt       '
        write (ios)  kmt
        write (ios) 'atm tracer'
        write (ios)  (((at(i,j,2,n),i=1,imt),j=1,jmt),n=1,nat)
        write (ios) 'precip    '
        write (ios)  precip
        write (ios) 'evap      '
        write (ios)  evap
        write (ios) 'outlwr    '
        write (ios)  outlwr
        write (ios) 'uplwr     '
        write (ios)  uplwr
        write (ios) 'dnswr     '
        write (ios)  dnswr
        write (ios) 'upsens    '
        write (ios)  upsens
        write (ios) 'upltnt    '
        write (ios)  upltnt





        write (ios) 'sst       '
        write (ios)  ((sbcocn(i,j,isst),i=1,imt),j=1,jmt)
        write (ios) 'sss       '
        write (ios)  ((sbcocn(i,j,isst),i=1,imt),j=1,jmt)
        write (ios) 'heat flux '
        write (ios)  ((sbcocn(i,j,ihflx),i=1,imt),j=1,jmt)
        write (ios) 'salt flux '
        write (ios)  ((sbcocn(i,j,ipme),i=1,imt),j=1,jmt)
        write (ios) 'ocn taux  '
        write (ios)  ((sbcocn(i,j,itaux),i=1,imt),j=1,jmt)
        write (ios) 'ocn tauy  '
        write (ios)  ((sbcocn(i,j,itauy),i=1,imt),j=1,jmt)

c
	if (restrt) call savatmos
      else
	if (eorun .and. restrt) call savatmos
      endif
c
      return
      end


      subroutine initatmos
c
c=======================================================================
c     initialize variables for the energy-moisture balance model
c     based on code by a.fanning
c
c     author:   m.eby   e-mail: eby@uvic.ca
c=======================================================================
c
c====================== include file "param.h" =========================
c
c     main parameter file which sets ocean characteristics:
c
c     "size.h" sets model size "imt", "jmt", and "km"
c
c====================== include file "size.h" ==========================
c                                                                       
c-----------------------------------------------------------------------
c     USER INPUT: 
c-----------------------------------------------------------------------
c
c     imt    = number of grid points in the longitudinal direction
c              (calculated points are from 2 through imt-1. End points
c               are boundaries)          
c
c     jmt    = number of grid points (latitude rows) in the latitudinal
c              direction (calculated points are from 2 through jmt-1.           
c              End points are boundaries)   
c                                
c     km     = number of grid points in the vertical direction          
c              (calculated points are from 1 through km)
c
c     nt     = number of tracers (temperature, salinity, ...)
c
c     mnisle = maximum number of islands (unconnected land masses)
c
c     maxipp = maximum number of all island perimeter points
c-----------------------------------------------------------------------
c                                                                       
      parameter (imt=  92, jmt=  61, km= 15)
      parameter (nt=2)
      parameter (nat=2)
      parameter (mnisle=50, maxipp=5000)
c

c






c
c-----------------------------------------------------------------------
c     END USER INPUT
c-----------------------------------------------------------------------
c                                                                       
c-----------------------------------------------------------------------
c     By default, the MW (memory window) is 2nd order except for the
c     following options which require a 4th order MW 
c
c     for 2nd order schemes, the minimum sized MW is 3 latitude rows
c     for 4th order schemes, the minimum sized MW is 4 latitude rows
c                            (5 if using coarse_grained_parallelism)
c-----------------------------------------------------------------------
c













c
c-----------------------------------------------------------------------
c     set MW (memory window) size "jmw" 
c-----------------------------------------------------------------------
c                                                                       

c
c     for UNI-TASKING: "jmw" is set to the minimum for each option class 
c     "jmw" may be increased up to "jmt" 
c

      parameter (jmw=jmt)


c
c-----------------------------------------------------------------------
c     set first and last calculated row within the MW. other rows
c     are used as buffers
c-----------------------------------------------------------------------
c
c     jsmw   = 1st calculated row within the MW     
c     jemw   = last calculated row within the MW
c
      parameter (jsmw=2, jemw=jmw-1)
c
c
c     jextra = extra buffer rows needed for coarse_grained_parallelism.
c              "jextra" rows are added to the top and bottom of the MW
c              so the MW size increases by 2*jextra       
c

          parameter (jextra = 0)




c
c     nvar   = number of prognostic variables
c     lseg   = maximum number of longitudinal stream function segments
c     nlatpr = maximum number of latitudes for matrix printouts
c              on diagnostic time steps
c     nhreg  = number of regions in the horizontal used for averaging
c              tracers.
c     nvreg  = number of regions in the vertical used for term balance
c              calculations. note "nvreg" isn`t used for tracer averages
c     numreg = total number of regions ( = product of nhreg & nvreg)
c              used for term balance calculations
c
      parameter (lseg=5, nlatpr=10)

      parameter (nhreg=5, nvreg=2, numreg=nhreg*nvreg)

      parameter (nvar=nt+2)
c

c
      parameter (imtm1=imt-1, kmm1=km-1)                                
      parameter (imtp1=imt+1, imtm2=imt-2
     &,          jmtp1=jmt+1, jmtm1=jmt-1, jmtm2=jmt-2

     &,          jscan=jmtm2

     &,          kmp1=km+1, kmp2=km+2
     &,          imtkm=imt*km, nwds=imt*jmt, nkflds=2
     &,          nslab=imt*nvar*km, ntmin2=nt+1/nt)
c
c     include parameter constants
c
c====================== include file "pconst.h" ========================
c
c
c     rules for parameter constants
c
c     use prefix of "c" for whole real numbers (eg: c57 for 57.0)
c     use "m" after prefix to designate negative values (minus sign)
c       (eg: cm7 for -7.0)
c     use prefix of "p" for non repeating fractions (eg: p5 for 0.5)
c     use prefix of "r" for reciprocals (eg: r3 for 1/3.0)
c     combine use of prefix above and "e" for scientific notation, with
c       (eg: c5e4 for 5.0e4, c1em10 for 1.0e-10)
c
      parameter (c0=0.0, c1=1.0, c2=2.0, c3=3.0, c4=4.0, c5=5.0, c7=7.0)
      parameter (c8=8.0)
      parameter (c14=14.0, c16=16.0, c360=360.0)
      parameter (p125=0.125, p25=0.25, p5=0.5, p75=0.75)
      parameter (epsln=1.0e-20)
c
      parameter (c24=24.0, c60=60.0, c1440=1440.0)
      parameter (r24=c1/c24, r60=c1/c60, r1440=c1/c1440)
      parameter (secday=c1/(c60*c1440))
c
c     include standard I/O units
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c
c     ncrows = number of calculated rows within the MW.
c              (the remaining rows are buffer rows). 
c


      parameter (ncrows = jmw - 2)


c====================== include file "slap.h" ==========================
c
c     variables needed for the energy balance model solution technique
c
c     5-point stencil
c     max number non-zeros: total, upper and lower triangles (with diag)
c
      parameter  (maxnelt = (jmt+2)*(3*imt) + 2*(imt+2)*(jmt+1))
      parameter  (maxneltu = 3*(jmt+2)*(imt+2) - imt - jmt)
      parameter  (maxneltl = maxneltu)
c
c     number direction vectors to orthogonalize against
c
      parameter  (nsave = 10)
c
c     work space
c
      parameter  (lenw = 1 + (imt)*(jmt)*(nsave+7) + 
     &	         nsave*(nsave+3) + maxneltu + maxneltl)
      parameter  (leniw =  (imt)*(jmt)*4+maxneltu + maxneltl + 32)
      real       rwork(lenw)
      integer    iwork(leniw)
c
c     the tracer matrix
c
      integer    slapia(maxnelt,2,nat), slapja(maxnelt,2,nat)
      integer    nelt, orda
c
      real       slapam(maxnelt,2,nat), slaprhs(imt*jmt,nat)
      real       slaplhs(imt*jmt,nat), sltol(nat)
c
      common /slapmats/ slapia, slapja, nelt, orda
     &,	                slapam, slaprhs, slaplhs, sltol
c
c     index maps
c
      integer    indexgrid(imt,jmt), gridrow(imt*jmt)
      integer    gridcol(imt*jmt)
c
      common /slapmaps/ indexgrid, gridrow, gridcol
c
c====================== include file "atm.h" ===========================
c
c     arrays for the energy-moisture balance model
c
c     note: units for heat flux are in g/cm**2/s**3/cm**2 or (mW/m**2)
c           units for fresh water flux are in cm/s
c           downward is into the surface (ocean, ice or land)
c           upward is into the bottom of the atmosphere
c           outward is out of the top of the atmosphere
c           inward is into the top of the atmosphere
c
c     outlwr(imt,jmt)	 = outgoing atmosphere longwave flux
c     at(imt,jmt,2,nat)	 = tracers (previous and most recent)
c     surf(imt,jmt,nat)	 = surface values (1=temperature, 2=humidity)
c     flux(imt,jmt,nat)	 = downward flux (1=heat, 2=fresh water)
c     precip(imt,jmt)	 = precipitation
c     evap(imt,jmt)	 = evaporation
c     dnswr(imt,jmt)  	 = downward surface shortwave flux
c     uplwr(imt,jmt)  	 = upward surface longwave flux
c     upsens(imt,jmt)	 = upward surface sensible heat flux
c     upltnt(imt,jmt)    = upward surface latent heat flux
c     ssh(imt,jmt) 	 = saturation specific humidity
c     spd(imt,jmt) 	 = wind speed (cm/sec)
c     da(jmt,nat)	 = tracer diffusivity parameterization
c     coalbedo(jmt)	 = planetary coalbedo
c     solins(jmt)	 = solar insolation (units of solarconst)
c     esatm(jmt)	 = atmosphere emissivity times Stefan's constant
c     scatter(jmt)	 = solar scattering into atmosphere





c     cori(jmt,2)	 = Coriolis parameter

c
      real outlwr(imt,jmt), at(imt,jmt,3,nat), surf(imt,jmt,nat)
      real flux(imt,jmt,nat), precip(imt,jmt), evap(imt,jmt)
      real dnswr(imt,jmt), uplwr(imt,jmt), upsens(imt,jmt)
      real upltnt(imt,jmt), ssh(imt,jmt), spd(imt,jmt), da(jmt,nat)
      real coalbedo(jmt), solins(jmt), esatm(jmt), scatter(jmt)





      real cori(jmt,2)
c
      common /atm/ outlwr, at, surf, flux, precip, evap, dnswr, uplwr
     &,            upsens, upltnt, spd, ssh, da, coalbedo, solins
     &,            esatm, scatter





     &,            cori
c

c====================== include file "cembm.h" =========================
c
c     parameters for use in the energy balance model (also see atm.h)
c
c     addflux		= logical flag for adding only even mode fluxes
c     nats		= number of atmospheric time steps since mixing
c     namix		= time steps between mixing (set in atmos.in)
c     lf		= time step flag (1=>leapfrog, 2=>forward)
c     pyear		= calendar year (set in atmos.in, -/+ = BC/AD)
c     dtatm 		= time step for atmosphere (set in atmos.in)
c     dts		= time step (2*dtatm=>leapfrog, dtatm=>forward)
c     co2ccn		= CO2 concentration
c     anthro		= radiative forcing by CO2
c     co2ccni		= initial CO2 concentration
c     co2yri		= last year of initial CO2 concentration
c     co2ccnf		= final CO2 concentration
c     co2yrf		= first year of final CO2 concentration
c     solarconst	= solar constant (g/s**3)
c     ssp		= sea surface pressure (g/cm/s**2)
c     cdatm 		= drag coefficient (dimensionless)
c     cpatm		= atmospheric heat capacity (cm**2/s**2/K)
c     ht		= scale height for temperature
c     hq		= scale height for specific humidity
c     rhoatm		= density of air at sea surface (g/cm**3)
c     rhoocn		= representative sea surface density
c     esocn		= ocean emissivity times Stefan's constant 
c     vlocn		= latent heat of vaporization of water
c     socn		= constant ocean salinity
c     cdice 		= drag coefficient (dimensionless)
c     rhoice		= ice density (g/cm**3)
c     esice		= ice emissivity times Stefan's constant 
c     slice		= latent heat of sublimation of ice
c     flice		= latent heat of fusion of ice (cm**2/s**2)
c     condice		= ice conductivity (g*cm/s**3/K)
c     kadv		= time step divider for ice advection
c     ntats		= time step counter for time averaging
c     avetime		= time for averaging fluxes
c     totaltime		= total time for long term averages
c
      logical addflux
c
      common /cembm/ addflux
      common /cembm/ nats, namix, lf, kadv, ntats
      common /cembm/ pyear, dtatm, dts, co2ccn, anthro, co2ccni, co2yri
     &,              co2ccnf, co2yrf, solarconst, ssp, cdatm, cpatm, ht
     &,              hq, rhoatm, rhoocn, esocn, vlocn, socn, cdice
     &,              rhoice, esice, slice, flice, condice, avetime 
     &,              totaltime
c
c====================== include file "cfile.h" =========================
c
c     file parameters and names
c
c     "ocean.in", "ice.in", "atmos.in" and "files.in" must be in the 
c     directory in which the model is running
c     paths and file names can be set through these namelist files
c
c     if additional file names are required, they should be added to 
c     the common block below,  defined in "setocn.F" or "setice.F" 
c     or "setatm.F" and added to the namelists defined in subroutine
c     "pathfile" (in util.F)
c
c     nsfc    = number of snapshot files counter 
c     nwsfc   = number of writes to a snapshot file counter 
c     ntafc   = number of tracer average files counter 
c     mxnsf   = maximum number snapshot files before resetting counter
c     mxnwsf  = maximum number of writes to a snapshot before renaming
c
c     focean  = namelist file for ocean parameters (ocean.in)
c     flat    = latitude data file name
c     fgrid   = flexible grid data file name
c     fcurv   = curvilinear grid data file name
c     fkmt    = levels data file name
c     ftemp   = initial temperature data file name
c     fsalt   = initial salinity data file name
c     ftaux   = x component of wind stress data file name
c     ftauy   = y component of wind stress data file name
c     fhflx   = surface heat flux data file name
c     fsflx   = surface salt flux data file name
c     fsst    = surface temperature data file name
c     fsss    = surface salinity data file name
c     fsnapo  = snapshot file name for the ocean
c     ftavgo  = time average file name for the ocean
c     fresto  = restart file name for the ocean
c     pocnin  = path for ocean input files
c     pocnout = path for ocean output files
c
c     fice    = namelist file for ice parameters (ice.in)
c     ft10    = atmospheric temperature at 10 m
c     fq10    = atmospheric humidity at 10 m
c     fswr    = incoming shortwave radiation
c     flwr    = incoming longwave radiation
c     fsnapi  = snapshot file name for the ice
c     fresti  = restart file name for the ice
c     picein  = path for ice input files
c     piceout = path for ice output files
c
c     fatmos  = namelist file for atmospheric parameters (atmos.in)
c     friver  = river file for atmospheric model
c     fwspd   = wind speed for atmospheric model
c     ftbar   = average air temperature for atmospheric model
c     fqbar   = average specific humidity for atmospheric model
c     frtbar  = run average air temperature for atmospheric model
c     frqbar  = run average specific humidity for atmospheric model
c     felev   = land elevations for modifying saturation humidity 
c     fsnapa  = snapshot file name for the atmosphere
c     ftavga  = time average file name for the atmosphere
c     fresta  = restart file name for the atmosphere
c     patmin  = path for atmosphere input files
c     patmout = path for atmosphere output files
c
c     ffiles  = namelist file of file names
c     pf      = path + file name
c
      character*15 focean, flat, fgrid, fcurv, fkmt 
     &,            ftemp, fsalt, ftaux, ftauy, fhflx, fsflx
     &,            fsst, fsss, fsnapo, ftavgo, fresto
     &,            fice, ft10, fq10, fswr, flwr, fsnapi, fresti
     &,            fatmos, friver, fwspd, ftbar, fqbar, felev
     &,            frtbar, frqbar, fsnapa, ftavga, fresta
     &,            ffiles
c
      character*45 pocnin, pocnout, picein, piceout, patmin, patmout
      character*60 pf
c
      common /cfile/ nsfc, nwsfc, ntafc, mxnsf, mxnwsf
c
      common /cfile/ focean, flat, fgrid, fcurv, fkmt 
     &,              ftemp, fsalt, ftaux, ftauy, fhflx, fsflx
     &,              fsst, fsss, fsnapo, ftavgo, fresto
     &,              fice, ft10, fq10, fswr, flwr, fsnapi, fresti
     &,              fatmos, friver, fwspd, ftbar, fqbar, felev
     &,              frtbar, frqbar, fsnapa, ftavga, fresta
     &,              ffiles
     &,              pocnin, pocnout, picein, piceout, patmin, patmout
c====================== include file "csbc.h" ==========================
c
c                    surface boundary conditions (S.B.C.)
c
c
c     numosbc = number of ocean S.B.C..
c
c     numasbc = number of atmospheric S.B.C..
c
c     maxsbc  = maximum number of allowable S.B.C. fields.
c
c     numsbc  = total number of S.B.C. this is the sum of the 
c               atmosphere S.B.C. and ocean S.B.C. fields. it must
c               be less than or equal to "maxsbc".
c
c     sbcocn  = S.B.C. fields on the ocean grid.
c               n=1..numosbc are for the incoming ocean S.B.C.
c               n=numosbc+1..numosbc+numasbc are for the outgoing S.B.C.
c

c
c     ntspos  = number of time steps per ocean segment
c
c     sbcname  = S.B.C. character string names (eg: "SST", "taux", etc)
c               note that these character strings should be changed with
c               care since they are used to identify fields for special
c               treatment
c
c     dunits  = dimensional units for S.B.C. (eg: "deg C")
c
c     mapsbc  = indices for relating how S.B.C. fields are stored
c               within arrays "sbcocn" and "sbcatm"  
c               eg: m = mapsbc(n) where sbcocn(,,m) is S.B.C. "n"
c
c     restrictions on re-arranging S.B.C. fields and "mapsbc":
c
c     1) all ocean S.B.C. (taux, tauy, etc) should be grouped together. 
c        relative ordering within the group is unimportant but the
c        group must preceed the atmos S.B.C. group.
c
c     2) all atmos S.B.C. (sst, ...) should also be grouped together.
c        relative ordering within the group is unimportant.
c
c     the default arrangement is defined as:
c
c             (these five ocean S.B.C. come from the atmos )
c     mapsbc(1) references taux
c     mapsbc(2) references tauy
c     mapsbc(3) references heat flux
c     mapsbc(4) references salt flux
c      if the atmos supplied fresh water flux then it
c      would have to be converted to ...
c      salt flux  = -(P-E+R) * rho * Sref
c      where...
c      P-E+R represents a precipitation minus evaporation
c            plus runoff rate in cm of water/sec
c      rho is the density if water taken to be 1 g/cm**3, and
c      Sref is a reference salinity in units of grams of salt per
c            gram of water (in units of "parts per part" such
c            as 0.035 ... not "parts per thousand")
c      Depending upon the application of interest, users may wish
c      to set Sref to either be a constant over the entire model
c      domain or for it to be the locally predicted salinity of
c      the uppermost model level (S(1)).  If one desires to ensure
c      that a global average P-E+R flux of zero translates to zero
c      trend in the salt content of the ocean, then a constant Sref
c      is needed.      
c     mapsbc(5) references short wave
c
c             (these four atmos S.B.C. come from the ocean)
c     mapsbc(6) references SST
c     mapsbc(7) references SSS
c     mapsbc(8) references surface u
c     mapsbc(9) references surface v
c
c
c     when re-ordering S.B.C., search for "mapsbc"  
c     (eg: grep mapsbc *.F) to insure the new indexing is consistant
c     with the re-ordering. also make changes in "sbcname", "dunits", 
c     "coabc", and "crits" to maintain consistancy.
c
c     example 1: suppose you want only the first six S.B.C...
c                in "csbc.h", set  numosbc=5, numasbc=1
c                this reduces memory requirements.
c                no other changes are necessary
c
c     example 2: suppose you want to remove the short wave boundary
c                condition (to save more memory) from example 1 . 
c                a) in "csbc.h", set numosbc=4, numasbc=1
c                b) grep "mapsbc(5)" *.F to find and remove references
c                c) grep "mapsbc(6)" *.F to change references to 
c                                        mapsbc(5)
c
c     
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c
c
      logical asegs, asege, afirst, alast
      character*10 sbcname
      character*15 dunits
c
      parameter (numosbc=5
     &,          numasbc=4
     &,          maxsbc=numosbc+numasbc, numsbc=maxsbc)
c
      common /csbc/ sbcocn(imt,jmt,numsbc) 
      common /csbc/ dampts(nt), dampdz(nt)
      common /csbc/ coabc(maxsbc), crits(maxsbc)
      common /csbc1/ mapsbc(maxsbc), numpas, iombc, ntspos, ntspas
      common /csbc2/ sbcname(maxsbc), dunits(maxsbc)
      common /csbc3/ asegs, asege, afirst, alast 
c
c====================== include file "levind.h" ========================
c
c     vertical level indicators which define model geometry & bottom
c     topography:
c
c     kmt = number of vertical boxes over "t" points
c     kmu = number of vertical boxes over "u,v" points
c
      common /levind/ kmt(imt,jmt), kmu(imt,jmt)
c
c====================== include file "mapsbc.h" ========================
c
c     indicies for surface boundary condition arrays.  names must be
c     unique and are set at the begining of "driver"
c
c     itaux is the x component of wind stress
c     itauy is the y component of wind stress
c     ihflx is heat flux
c     ipme is for precipitation minus evaporation
c     ipsw is for penitrating shortwave (into ocean first layer)
c     isst is the ocean model SST
c     isss is the ocean model SSS
c     isu is the x component of the ocean model first layer velocity
c     isv is the y component of the ocean model first layer velocity
c     it10 is the 10 metre atmopheric temperature
c     iq10 is the 10 metre atmopheric humidity
c     ilwr is incoming longwave radiation
c     iswr is incoming shortwave radiation
c     igu is the x component of the ocean model second layer velocity
c     igv is the y component of the ocean model second layer velocity
c
      common /mapsbc/ itaux, itauy, ihflx, ipme, ipsw, isst, isss
     &,               isu, isv, it10, iq10, ilwr, iswr, igu, igv
c
c====================== include file "switch.h" ========================
c
c     all time dependent decisions are made by time manager "tmngr.F"
c     and communicated elsewhere to the model via logical switches.
c
c     inputs: (defaulted in "blkdta.F", optionally reset via namelist)
c
c
c     runlen  = integration period (see rununits). note "runlen" should
c               be an integral number of density time steps. if not,
c               then "runlen" is automatically adjusted to insure this.
c               fractional days are supported but not fractional months
c               or years.
c     rununits= units of "runlen". may be "days", "months", or "years".
c               tmngr will convert "runlen" which is in "rununits"
c               to "rundays" in units of days.
c
c     segtim  = the integration time "runlen" is broken into a number of
c               segments each of length "segtim" days. updated surface
c               boundary conditions are applied to MOM every "segtim" 
c               days. this is useful when coupling to atmospheric models
c               in which case both models exchange surface boundary
c               conditions every "segtim" days where "segtim"
c               is 1/(coupling frequency). without an atmospheric model,
c               when getting surface boundary conditions from data, 
c               "segtim" is set to the time step (in days) by mom.F. in
c               either case, "runlen" (in days) should be an integral
c               number of "segtim".     
c
c     nmix    = number of time steps between mixing timesteps. used
c               to damp timestep splitting due to centered leapfrog.
c
c     init    = (true,false)  indicates that this run is a
c               (start from initial conditions, restart)
c
c     restrt  = (true,false) = (do,don`t) write a restart at the end
c               of the run
c
c     eb      = (true,false) configures for the use of a 
c               (euler backward,forward) type mixing timestep
c
c-----------------------------------------------------------------------
c     inputs to tmngr.F: diagnostic intervals
c-----------------------------------------------------------------------
c
c     note: switches are used to control the interval between doing
c           diagnostics. units for all switches are in days. 
c           setting a switch < 0.0 disables whatever the switch is 
c           controlling. setting it = 0.0 causes the diagnostic to be 
c           done every time step, and setting it > 0.0 causes the 
c           diagnostic to be done repeatedly on the specified interval. 
c
c     cmixint = number of days between writing estimated mixing coeffs
c               on faces of T cells and U cells
c
c     crossint = number of days between writing diapycnal and isopycnal
c               components of flow
c
c     fctint = number of days between writing difference between 
c              FCT and leapfrog advection
c
c     densityint = number of days between writing density
c
c     exconvint = number of days between writing temperature rate of
c                 change due to explicit convection
c
c     glenint =  number of days between global energetics integrals.
c
c     trmbint =  number of days between momentum and tracer term
c                balances (global and regional).
c
c     itrmb   = (true,false) = (do,don`t) write regional mask info for
c               the term balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     gyreint =  number of days between calculation of tracer northward
c                transport.
c     igyre   = (true,false) = (do,don`t) write regional mask info for
c               the gyre diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     vmsfint =  number of days between calculation of vertical and
c                meridional stream function.
c
c     tyzint  =  number of days between calculation of zonally averaged
c                tracer components.
c
c     prxzint =  number of days between printouts of x-z data.
c
c     extint  =  number of days between printouts of external mode.
c
c     dspint  =  number of days between surface pressure calculation.
c                Note: only when "diagnostic_surface_height" is enabled.
c     dspper  = averaging period for "diagnostic_surface_height"
c
c     tavgint = number of days between regional tracer averages (under
c               horizontal regions).
c
c     itavg   = (true,false) = (do,don`t) write regional mask info for
c               the tracer average diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     tmbint  = number of days over which tracer equation in averaged
c               in depth and longitude to determine the meridional 
c               balance among storage, divergence, dissipation and 
c               forcing.
c     tmbper  = averaging period for "meridional_tracer_balance"
c
c     itmb    = (true,false) = (do,don`t) write "msktmb" for tracer
c               the meridional balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c
c     tsiint  = number of days between printing of time step integrals.
c
c     stabint = number of days between sampling for various stability
c               criteria.
c
c     snapint = number of days between writing instantaneous samples
c               of data from the MOM grid. note: only when "snapshots"
c               is enabled. see "iounit.h" for more details.
c               all data is at time level "tau" so it is one time step
c               before the date shown in "stamp".
c
c     timavgint= interval (days) for writing time mean data from
c               the "averaging" grid (only when "time_averages" is
c               enabled). if "timavgint" is not an integral number of
c               density time steps,"timavgint" is automatically adjusted
c               to insure this. if the number of days to integrate is
c               not an integral number of "timavgint" then the last
c               averaging period will be less than "timavgint" days.this 
c               may lead to one more averaging period than expected. 
c               see "iounit.h" for more details.
c     timavgper= averaging period for "time_averages"
c
c     xbtint  = averaging period (days) for writing XBT data (only when
c               "xbts" is enabled). if "xbtint" is not an integral
c               number of density time steps, "xbtint" is automatically
c               adjusted to insure this. if the number of days to 
c               integrate is not an integral number of "xbtint" then the
c               last averaging period will be less than "xbtint" days.
c               this may lead to one more averaging period than  
c               expected. see "iounit.h" for more details.
c     xbtper  = averaging period for "xbts"
c
c     zmbcint = number of days between calculation of zonal mean
c               surface boundary conditions (and related  quantities)
c
c     trajint = number of days between writing particle trajectories.
c               particle trajectories are always written on the last
c               time step of the run to allow for restarting.
c
c-----------------------------------------------------------------------
c     outputs from tmngr.F: logical switches
c-----------------------------------------------------------------------
c
c     rundays = integration time in days (from "runlen")
c
c     the following are logical counterparts to the above switches are 
c     set within "tmngr" every time step. logical switches control all
c     decisions about when to do things in MOM.
c
c     cmixts  = (false,true) = (don`t, do) do write estimated mixing
c               coefficients on this time step.
c               based on "cmixint".
c
c     crossts  = (false,true) = (don`t, do) write diapycnal and 
c               isopycnal components of flow on this time step.
c               based on "crossint".
c
c     fctts    = (false,true) = (don`t, do) write difference between 
c               FCT and leapfrog advection on this time step.
c               based on "fctint".
c
c     densityts  = (false,true) = (don`t, do) write density on this time
c               step. based on "densityint".
c               
c
c     exconvts  = (false,true) = (don`t, do) do write temperature change
c               due to explicit convection on this time step.
c               based on "exconvint".
c
c     glents  = (false,true) = (don`t, do) do calculation of global
c               energy integrals on this time step. based on "glenint".
c
c     trmbts  = (false,true) = (don`t, do) do calculation of momentum &
c               tracer term balance on this timestep. based on "trmbint"
c
c     gyrets  = (false,true) = (don`t, do) do calculation of tracer
c               northward transport on this timestep. based on "gyreint"
c
c     vmsfts  = (false,true) = (don`t, do) do calculation of vertical
c               and meridional stream function on this time step.
c               based on "vmsfint"
c
c     tyzts   = (false,true) = (don`t, do) do calculation of zonally
c               averaged tracer components on this time step.
c               based on "tyzint"
c
c     prxzts  = (false,true) = (don`t, do) do printouts of x-z data
c               on this time step. based on "prxzint"
c
c     extts  = (false,true) = (don`t, do) do printout of external mode
c               on this time step. based on "extint"
c
c     dspts  = (false,true) = (don`t, do) do calculation of diagnostic 
c              surface pressure on this time step. based on "dspint"
c               
c
c     stabts  = (false,true) = (don`t, do) test for stability on this
c               time step. based on "stabint"
c
c     tavgts  = (false,true) = (don`t do) do tracer averages on this
c               time step. based on "tavgint"
c
c     tmbts   = (false,true) = (don`t, do) write out tracer meridional .
c               balance on this time step. based on "tmbint"
c
c     tsits   = (false,true) = (don`t, do) print time step integrals
c               on this time step. based on "tsiint"
c
c     zmbcts  = (false,true) = (don`t, do) print zonal mean boundary
c               conditions on this time step.  based on "zmbcint"
c
c     trajts  = (false,true) = (don`t, do) print particle trajectories
c               on this time step. based on "trajint"
c
c     snapts  = (false,true) = (don`t, do) save a snapshot of the data
c               on this time step. based on "snapint"
c
c     timats  = (false,true) = (don`t, do) write time mean data
c               on this time step. based on "timavgint"
c                                          
c     xbtts   = (false,true) = (don`t, do) write averaged XBT data on
c               this time step based on "xbtint"
c
c
c     leapfrog= (false,true) on a (mixing, normal leapfrog) time step
c                based on "nmix"
c                                          
c     euler1  = true on the 1st pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     euler2  = true on the 2nd pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     forward = true on a forward time step. otherwise false
c		(applies when "eb" = false)		  
c                                          
c
c     the following logical switches are based on the model time step. 
c    
c     first   = (true,false) =  when it`s (the first, not the first)
c                               time step of a run
c     eots    = end of a time step. always true except for first
c               pass of an euler backward time step
c     eorun   = last time step of a run. always false except during the
c               last time step of the run.
c
c     eoday   = true when within 1/2 time step of the end of a day
c               else ... false
c     eoweek  = true when within 1/2 time step of the end of a 7 day
c               week (referenced to the start of a year) else ...false
c     eo2wks  = true when within 1/2 time step of the end of two weeks
c               (referenced to the start of a year) else ... false
c     midmon  = true when within 1/2 time step of the middle of a month
c               else ... false
c     eomon   = true when within 1/2 time step of the end of a month
c               else ... false
c     eoyear  = true when within 1/2 time step of the end of a year
c               else ... false
c     osegs   = true on the 1st time step of an ocean segment in mom.F
c               otherwise false.
c     osege  =  true on the last time step of an ocean segment in mom.F
c               otherwise false.
c
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c
c
      logical eb, leapfrog, euler1, euler2, forward, eots
      logical init, first, restrt
      logical itavg, itmb, itrmb, igyre
      character *8 rununits
c
      common /switcc/ rununits
      common /switcr/ runlen, rundays
      common /switci/ nmix
      common /switcl/ eb, leapfrog, euler1, euler2, forward, eots
      common /switcl/ init, first, restrt
      common /switcl/ itavg, itmb, itrmb, igyre
c
      logical          eoday, eoweek, eo2wks
      common /switci/ ieoday,ieoweek,ieo2wks
      common /switcl/  eoday, eoweek, eo2wks
c
      logical          eomon, midmon, eoyear, eorun
      common /switci/ ieomon,imidmon,ieoyear,ieorun
      common /switcl/  eomon, midmon, eoyear, eorun
c
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c     each interval switch needs three variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output (e.g,.  glenint)
c         2) a switch (logical) for the interval (e.g.,  glents )
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c         3) an index (integer)                       (e.g., iglenint)
c
c     the user must specify the interval [e.g., glenint] for diagnostic
c     output in units of days. tmngr sets the corresponding logical  
c     switch [e.g., glents] every time step. It is set to true when  
c     within half a time step of the requested interval, otherwise it is
c     false. All decisions relating to the interval [e.g., glenint]
c     are based on the logical switch [e.g., glents].
c           
c     internal time structures
c
c     The switch index [e.g., iglenint] is used to subsrcipt into  
c     internal arrays maintained by tmngr.F. The switch index is
c     allocated on the first call to function "alarm".
c     The array entry [e.g., iinterval(iglenint)] is a time index to the
c     internal representation of the interval [e.g., glenint].
c     The array entry [e.g., ialarm(iglenint)] is a time index to the
c     next time the alarm will be true.
c-----------------------------------------------------------------------
c
      logical           tavgts,    glents,    trmbts,   prxzts
      common /switcr/   tavgint,   glenint,   trmbint,  prxzint
      common /switci/  itavgint,  iglenint,  itrmbint, iprxzint
      common /switcl/   tavgts,    glents,    trmbts,   prxzts
c
      logical          extts,   trajts,   exconvts,   cmixts
      common /switcr/  extint,  trajint,  exconvint,  cmixint
      common /switci/ iextint, itrajint, iexconvint, icmixint
      common /switcl/  extts,   trajts,   exconvts,   cmixts
c
      logical          vmsfts,   gyrets,    tsits,   snapts,   fctts
      common /switcr/  vmsfint,  gyreint,   tsiint,  snapint,  fctint
      common /switci/ ivmsfint, igyreint,  itsiint, isnapint, ifctint
      common /switcl/  vmsfts,   gyrets,    tsits,   snapts,   fctts
c
      logical          tyzts
      common /switcr/  tyzint
      common /switci/ ityzint
      common /switcl/  tyzts
c
      logical          stabts,   zmbcts,   crossts,   densityts
      common /switcr/  stabint,  zmbcint,  crossint,  densityint
      common /switci/ istabint, izmbcint, icrossint, idensityint
      common /switcl/  stabts,   zmbcts,   crossts,   densityts
c
      logical          osegs,  osege
      common /switcr/          segtim
      common /switci/ iosegs, iosege
      common /switcl/  osegs,  osege
c   
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c              A N D   A V E R A G I N G   P E R I O D
c
c     each averaging period switch needs five variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output    (e.g. xbtint  )   
c         2) a switch (logical) for the interval         (e.g. xbtts   )
c         3) an averaging period (real)                  (e.g. xbtper  )   
c         4) a switch (logical) for accumulating         (e.g. xbtperts)
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switches
c
c         5) an index (integer)                         (e.g. ixbtint  )
c
c     The user must specify the interval [e.g., xbtint] for diagnostic
c     output in units of days and the averaging period [e.g., xbtper] 
c     in units of days. The averaging period may be less than or equal
c     to the interval. For example, if the interval is 30.0 days and the
c     averaging period is 5.0 days, results will be averaged over all
c     time steps within days 26, 27, 28, 29, and 30.  An averaging period
c     of 0.0 days averages over the last time step of the interval (as
c     does xbtper = dt), and an averaging period less than zero turns
c     the switches off for all time steps.  
c
c     The logical switch for writing output at the specified interval 
c     [e.g., xbtts] is set to true on the last time step of the 
c     averaging period. The logical switch for accumulating results
c     [e.g., xbtperts] is true for all time steps within the averaging
c     period, otherwise it is false. 
c
c     internal time structures
c
c     The index [e.g., ixbtint] is allocated on the first call to 
c     function "avg_alarm". The array element iperiod(ixbtint) is an
c     index to the time structure for the internal representation of 
c     "xbtper", and ilastsw(ixbtint) is the index of the switch that 
c     flags the last time step of the accumulation period.
c     Depending on use,  ilastsw(ixbtint) may either be the index
c     of another "named" switch or the index of a new switch
c     allocated on the first time step.
c     In the latter case, iinterval(ilastsw(ixbtint)) is the index of
c     the time structure where "xbtint" is stored in internal form,
c     and ialarm(ilastsw(ixbtint)) is the index of the time when an
c     accumulation period will next end.
c     The variable nextts(ixbtint) is true whenever the next
c     time step will begin the accumulation period.
c
c-----------------------------------------------------------------------
c
      logical         xbtts,     dspts,    tmbts,    timavgts
      logical         xbtperts,  dspperts, tmbperts, timavgperts
      common /switcr/ xbtint,    dspint,   tmbint,   timavgint
      common /switcr/ xbtper,    dspper,   tmbper,   timavgper
      common /switci/ixbtint,   idspint,  itmbint,  itimavgint
      common /switcl/ xbtts,     dspts,    tmbts,    timavgts
      common /switcl/ xbtperts,  dspperts, tmbperts, timavgperts
c
c-----------------------------------------------------------------------
c
c                 S W I T C H E S    B A S E D    O N    
c
c         C A L E N D A R   O R    P R E V I O U S    S W I T C H   
c
c               A N D   A V E R A G I N G    P E R I O D
c
c    
c
c     the following logical switches are based on any calendar or 
c     interval switch and an averaging period (in days). The  averaging
c     period must be less than or equal to the interval. The last
c     time step of the averaging period is at the end of the interval.
c     If the averaging period is set to zero, the averaging period
c     consists only of the last time period of the interval.  If
c     the averaging period is less than zero, these switches are always
c     false.
c
c     each averaging period switch needs four variables in common. For
c     example, if the averaging period is before the end of each month
c     then the calendar switch (eomon), and index (ieomon) are presumed
c     to exist in common and need not be added.
c     
c     Additionally, four items are needed.
c
c       1) an averaging period (real)                  (e.g.  testper  )   
c       2) a switch (logical) for accumulating results (e.g.  testperts)
c       3) a switch (logical) for the end of interval  (e.g.  testts   )
c
c     the fourth is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c       4) an index (integer)                          (e.g.  itestper )
c
c     Suppose it is required to produce averages over all time steps
c     during the last 5 days of each month. Then "testper" = 5.0 and 
c     the following will calculate the accumulating switch.
c
c      testts = avg_alarm(itestper, ihalfstep, 0, testper, iref, ieomon)
c      testperts = on(itestper)
c
c     Note the use of "ieomon" to key off the months.  The switch
c     "testts" will be true whenever "eomon" is true.
c     Also note that when an averaging switch is keyed off another
c     switch, the switch inverval argument is not used, but is 
c     retained for consistency with the form of other averaging
c     switches.
c-----------------------------------------------------------------------
c
      logical           testperts
      logical           testts
      common /switcr/   testint
      common /switcr/   testper
      common /switci/  itestper
      common /switcl/   testts
      common /switcl/   testperts

c
      parameter (maxsw=100)
      logical          on, lastts, nextts
      common /switci/  nsw  
      common /switci/  ialarm(maxsw), iinterval(maxsw), iperiod(maxsw)
     &,                ilastsw(maxsw)
      common /switcl/  on(maxsw), lastts(maxsw), nextts(maxsw)
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c

c


      character*10 field
c
c-----------------------------------------------------------------------
c     set initial or default restart conditions
c-----------------------------------------------------------------------
c
      nats = namix
      irstdy = 0
      msrsdy = 0
      do j=1,jmt
        do i=1,imt
          do n=1,nat
            val = 0.0
            if (n .eq. 1) val = 10.0
            if (n .eq. 2) val = 0.01
            at(i,j,1,n) = val
            at(i,j,2,n) = val
	  enddo

   	enddo
      enddo
      if (.not. init) then
c
c-----------------------------------------------------------------------
c       if starting from a restart file
c-----------------------------------------------------------------------
c
c martin
c        call pathfile (patmout, fresta, pf)
        call getunit (nu, pf, 'u s r ieee')
c
        read (nu) i, j, nats, dayoyr
        read (nu) nfields
c       check that restart matches this setup
        if (j .ne. jmt .or. i .ne. imt ) then
          write (stdout,*) '==> Warning: atmospheric restart'
     &,     ' is the wrong size '
          write (stdout,'(4(a6, i4))')
     &     ' i= ', i, ' imt= ', imt, ' j= ', j, ' jmt= ', jmt
        endif
c
c-----------------------------------------------------------------------
c       read in the fields defined in the restart
c-----------------------------------------------------------------------
c
        do nf=1,nfields
          read (nu) field
          if (field .eq. 'time      ') 
     &      read (nu) itt, irstdy, msrsdy, stamp
          if (field .eq. 'at        ')
     &      read (nu) ((((at(i,j,l,n),i=1,imt),j=1,jmt),l=1,2),n=1,nat)
          if (field .eq. 'sst       ')
     &      read (nu) ((sbcocn(i,j,isst),i=1,imt),j=1,jmt)
          if (field .eq. 'sss       ')
     &      read (nu) ((sbcocn(i,j,isss),i=1,imt),j=1,jmt)


        enddo
c
        call release_all
c
        write (*,'(a,a,a,i10,1x,a)') 
     &    ' ==>  Reading an atmospheric restart from file '
     &,   pf(1:len_trim(pf)), ' on ts=', itt, stamp
c
      endif

c
c-----------------------------------------------------------------------
c     initialize the time manager with specified initial conditions
c     time, user reference time, model time, and how long to integrate.
c-----------------------------------------------------------------------
c
      call tmngri (year0, month0, day0, hour0, min0, sec0
     &,              ryear, rmonth, rday, rhour, rmin, rsec
     &,              irstdy, msrsdy
     &,              runlen, rununits, rundays, dtts)

c
c-----------------------------------------------------------------------
c     zero initial flux accumulators
c-----------------------------------------------------------------------
c
      do n=1,nat
        do j=1,jmt
          do i=1,imt
            flux(i,j,n) = 0.0
          enddo
        enddo
      enddo          
c
c-----------------------------------------------------------------------
c     set initial approximation for vector of unknowns
c-----------------------------------------------------------------------
c
      do n=1,nat
	do index=1,orda
	  slaplhs(index,n) = at(gridcol(index),gridrow(index),2,n)
	enddo
 	call embmbc (at(1,1,3,n))
      enddo
c
      return
      end 


      subroutine savatmos
c
c=======================================================================
c     write restart for energy-moisture balance model
c     based on code by a.fanning
c
c     author:   m.eby   e-mail: eby@uvic.ca
c=======================================================================
c
c====================== include file "param.h" =========================
c
c     main parameter file which sets ocean characteristics:
c
c     "size.h" sets model size "imt", "jmt", and "km"
c
c====================== include file "size.h" ==========================
c                                                                       
c-----------------------------------------------------------------------
c     USER INPUT: 
c-----------------------------------------------------------------------
c
c     imt    = number of grid points in the longitudinal direction
c              (calculated points are from 2 through imt-1. End points
c               are boundaries)          
c
c     jmt    = number of grid points (latitude rows) in the latitudinal
c              direction (calculated points are from 2 through jmt-1.           
c              End points are boundaries)   
c                                
c     km     = number of grid points in the vertical direction          
c              (calculated points are from 1 through km)
c
c     nt     = number of tracers (temperature, salinity, ...)
c
c     mnisle = maximum number of islands (unconnected land masses)
c
c     maxipp = maximum number of all island perimeter points
c-----------------------------------------------------------------------
c                                                                       
      parameter (imt=  92, jmt=  61, km= 15)
      parameter (nt=2)
      parameter (nat=2)
      parameter (mnisle=50, maxipp=5000)
c

c






c
c-----------------------------------------------------------------------
c     END USER INPUT
c-----------------------------------------------------------------------
c                                                                       
c-----------------------------------------------------------------------
c     By default, the MW (memory window) is 2nd order except for the
c     following options which require a 4th order MW 
c
c     for 2nd order schemes, the minimum sized MW is 3 latitude rows
c     for 4th order schemes, the minimum sized MW is 4 latitude rows
c                            (5 if using coarse_grained_parallelism)
c-----------------------------------------------------------------------
c













c
c-----------------------------------------------------------------------
c     set MW (memory window) size "jmw" 
c-----------------------------------------------------------------------
c                                                                       

c
c     for UNI-TASKING: "jmw" is set to the minimum for each option class 
c     "jmw" may be increased up to "jmt" 
c

      parameter (jmw=jmt)


c
c-----------------------------------------------------------------------
c     set first and last calculated row within the MW. other rows
c     are used as buffers
c-----------------------------------------------------------------------
c
c     jsmw   = 1st calculated row within the MW     
c     jemw   = last calculated row within the MW
c
      parameter (jsmw=2, jemw=jmw-1)
c
c
c     jextra = extra buffer rows needed for coarse_grained_parallelism.
c              "jextra" rows are added to the top and bottom of the MW
c              so the MW size increases by 2*jextra       
c

          parameter (jextra = 0)




c
c     nvar   = number of prognostic variables
c     lseg   = maximum number of longitudinal stream function segments
c     nlatpr = maximum number of latitudes for matrix printouts
c              on diagnostic time steps
c     nhreg  = number of regions in the horizontal used for averaging
c              tracers.
c     nvreg  = number of regions in the vertical used for term balance
c              calculations. note "nvreg" isn`t used for tracer averages
c     numreg = total number of regions ( = product of nhreg & nvreg)
c              used for term balance calculations
c
      parameter (lseg=5, nlatpr=10)

      parameter (nhreg=5, nvreg=2, numreg=nhreg*nvreg)

      parameter (nvar=nt+2)
c

c
      parameter (imtm1=imt-1, kmm1=km-1)                                
      parameter (imtp1=imt+1, imtm2=imt-2
     &,          jmtp1=jmt+1, jmtm1=jmt-1, jmtm2=jmt-2

     &,          jscan=jmtm2

     &,          kmp1=km+1, kmp2=km+2
     &,          imtkm=imt*km, nwds=imt*jmt, nkflds=2
     &,          nslab=imt*nvar*km, ntmin2=nt+1/nt)
c
c     include parameter constants
c
c====================== include file "pconst.h" ========================
c
c
c     rules for parameter constants
c
c     use prefix of "c" for whole real numbers (eg: c57 for 57.0)
c     use "m" after prefix to designate negative values (minus sign)
c       (eg: cm7 for -7.0)
c     use prefix of "p" for non repeating fractions (eg: p5 for 0.5)
c     use prefix of "r" for reciprocals (eg: r3 for 1/3.0)
c     combine use of prefix above and "e" for scientific notation, with
c       (eg: c5e4 for 5.0e4, c1em10 for 1.0e-10)
c
      parameter (c0=0.0, c1=1.0, c2=2.0, c3=3.0, c4=4.0, c5=5.0, c7=7.0)
      parameter (c8=8.0)
      parameter (c14=14.0, c16=16.0, c360=360.0)
      parameter (p125=0.125, p25=0.25, p5=0.5, p75=0.75)
      parameter (epsln=1.0e-20)
c
      parameter (c24=24.0, c60=60.0, c1440=1440.0)
      parameter (r24=c1/c24, r60=c1/c60, r1440=c1/c1440)
      parameter (secday=c1/(c60*c1440))
c
c     include standard I/O units
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c
c     ncrows = number of calculated rows within the MW.
c              (the remaining rows are buffer rows). 
c


      parameter (ncrows = jmw - 2)


c====================== include file "atm.h" ===========================
c
c     arrays for the energy-moisture balance model
c
c     note: units for heat flux are in g/cm**2/s**3/cm**2 or (mW/m**2)
c           units for fresh water flux are in cm/s
c           downward is into the surface (ocean, ice or land)
c           upward is into the bottom of the atmosphere
c           outward is out of the top of the atmosphere
c           inward is into the top of the atmosphere
c
c     outlwr(imt,jmt)	 = outgoing atmosphere longwave flux
c     at(imt,jmt,2,nat)	 = tracers (previous and most recent)
c     surf(imt,jmt,nat)	 = surface values (1=temperature, 2=humidity)
c     flux(imt,jmt,nat)	 = downward flux (1=heat, 2=fresh water)
c     precip(imt,jmt)	 = precipitation
c     evap(imt,jmt)	 = evaporation
c     dnswr(imt,jmt)  	 = downward surface shortwave flux
c     uplwr(imt,jmt)  	 = upward surface longwave flux
c     upsens(imt,jmt)	 = upward surface sensible heat flux
c     upltnt(imt,jmt)    = upward surface latent heat flux
c     ssh(imt,jmt) 	 = saturation specific humidity
c     spd(imt,jmt) 	 = wind speed (cm/sec)
c     da(jmt,nat)	 = tracer diffusivity parameterization
c     coalbedo(jmt)	 = planetary coalbedo
c     solins(jmt)	 = solar insolation (units of solarconst)
c     esatm(jmt)	 = atmosphere emissivity times Stefan's constant
c     scatter(jmt)	 = solar scattering into atmosphere





c     cori(jmt,2)	 = Coriolis parameter

c
      real outlwr(imt,jmt), at(imt,jmt,3,nat), surf(imt,jmt,nat)
      real flux(imt,jmt,nat), precip(imt,jmt), evap(imt,jmt)
      real dnswr(imt,jmt), uplwr(imt,jmt), upsens(imt,jmt)
      real upltnt(imt,jmt), ssh(imt,jmt), spd(imt,jmt), da(jmt,nat)
      real coalbedo(jmt), solins(jmt), esatm(jmt), scatter(jmt)





      real cori(jmt,2)
c
      common /atm/ outlwr, at, surf, flux, precip, evap, dnswr, uplwr
     &,            upsens, upltnt, spd, ssh, da, coalbedo, solins
     &,            esatm, scatter





     &,            cori
c

c====================== include file "cembm.h" =========================
c
c     parameters for use in the energy balance model (also see atm.h)
c
c     addflux		= logical flag for adding only even mode fluxes
c     nats		= number of atmospheric time steps since mixing
c     namix		= time steps between mixing (set in atmos.in)
c     lf		= time step flag (1=>leapfrog, 2=>forward)
c     pyear		= calendar year (set in atmos.in, -/+ = BC/AD)
c     dtatm 		= time step for atmosphere (set in atmos.in)
c     dts		= time step (2*dtatm=>leapfrog, dtatm=>forward)
c     co2ccn		= CO2 concentration
c     anthro		= radiative forcing by CO2
c     co2ccni		= initial CO2 concentration
c     co2yri		= last year of initial CO2 concentration
c     co2ccnf		= final CO2 concentration
c     co2yrf		= first year of final CO2 concentration
c     solarconst	= solar constant (g/s**3)
c     ssp		= sea surface pressure (g/cm/s**2)
c     cdatm 		= drag coefficient (dimensionless)
c     cpatm		= atmospheric heat capacity (cm**2/s**2/K)
c     ht		= scale height for temperature
c     hq		= scale height for specific humidity
c     rhoatm		= density of air at sea surface (g/cm**3)
c     rhoocn		= representative sea surface density
c     esocn		= ocean emissivity times Stefan's constant 
c     vlocn		= latent heat of vaporization of water
c     socn		= constant ocean salinity
c     cdice 		= drag coefficient (dimensionless)
c     rhoice		= ice density (g/cm**3)
c     esice		= ice emissivity times Stefan's constant 
c     slice		= latent heat of sublimation of ice
c     flice		= latent heat of fusion of ice (cm**2/s**2)
c     condice		= ice conductivity (g*cm/s**3/K)
c     kadv		= time step divider for ice advection
c     ntats		= time step counter for time averaging
c     avetime		= time for averaging fluxes
c     totaltime		= total time for long term averages
c
      logical addflux
c
      common /cembm/ addflux
      common /cembm/ nats, namix, lf, kadv, ntats
      common /cembm/ pyear, dtatm, dts, co2ccn, anthro, co2ccni, co2yri
     &,              co2ccnf, co2yrf, solarconst, ssp, cdatm, cpatm, ht
     &,              hq, rhoatm, rhoocn, esocn, vlocn, socn, cdice
     &,              rhoice, esice, slice, flice, condice, avetime 
     &,              totaltime
c
c====================== include file "cfile.h" =========================
c
c     file parameters and names
c
c     "ocean.in", "ice.in", "atmos.in" and "files.in" must be in the 
c     directory in which the model is running
c     paths and file names can be set through these namelist files
c
c     if additional file names are required, they should be added to 
c     the common block below,  defined in "setocn.F" or "setice.F" 
c     or "setatm.F" and added to the namelists defined in subroutine
c     "pathfile" (in util.F)
c
c     nsfc    = number of snapshot files counter 
c     nwsfc   = number of writes to a snapshot file counter 
c     ntafc   = number of tracer average files counter 
c     mxnsf   = maximum number snapshot files before resetting counter
c     mxnwsf  = maximum number of writes to a snapshot before renaming
c
c     focean  = namelist file for ocean parameters (ocean.in)
c     flat    = latitude data file name
c     fgrid   = flexible grid data file name
c     fcurv   = curvilinear grid data file name
c     fkmt    = levels data file name
c     ftemp   = initial temperature data file name
c     fsalt   = initial salinity data file name
c     ftaux   = x component of wind stress data file name
c     ftauy   = y component of wind stress data file name
c     fhflx   = surface heat flux data file name
c     fsflx   = surface salt flux data file name
c     fsst    = surface temperature data file name
c     fsss    = surface salinity data file name
c     fsnapo  = snapshot file name for the ocean
c     ftavgo  = time average file name for the ocean
c     fresto  = restart file name for the ocean
c     pocnin  = path for ocean input files
c     pocnout = path for ocean output files
c
c     fice    = namelist file for ice parameters (ice.in)
c     ft10    = atmospheric temperature at 10 m
c     fq10    = atmospheric humidity at 10 m
c     fswr    = incoming shortwave radiation
c     flwr    = incoming longwave radiation
c     fsnapi  = snapshot file name for the ice
c     fresti  = restart file name for the ice
c     picein  = path for ice input files
c     piceout = path for ice output files
c
c     fatmos  = namelist file for atmospheric parameters (atmos.in)
c     friver  = river file for atmospheric model
c     fwspd   = wind speed for atmospheric model
c     ftbar   = average air temperature for atmospheric model
c     fqbar   = average specific humidity for atmospheric model
c     frtbar  = run average air temperature for atmospheric model
c     frqbar  = run average specific humidity for atmospheric model
c     felev   = land elevations for modifying saturation humidity 
c     fsnapa  = snapshot file name for the atmosphere
c     ftavga  = time average file name for the atmosphere
c     fresta  = restart file name for the atmosphere
c     patmin  = path for atmosphere input files
c     patmout = path for atmosphere output files
c
c     ffiles  = namelist file of file names
c     pf      = path + file name
c
      character*15 focean, flat, fgrid, fcurv, fkmt 
     &,            ftemp, fsalt, ftaux, ftauy, fhflx, fsflx
     &,            fsst, fsss, fsnapo, ftavgo, fresto
     &,            fice, ft10, fq10, fswr, flwr, fsnapi, fresti
     &,            fatmos, friver, fwspd, ftbar, fqbar, felev
     &,            frtbar, frqbar, fsnapa, ftavga, fresta
     &,            ffiles
c
      character*45 pocnin, pocnout, picein, piceout, patmin, patmout
      character*60 pf
c
      common /cfile/ nsfc, nwsfc, ntafc, mxnsf, mxnwsf
c
      common /cfile/ focean, flat, fgrid, fcurv, fkmt 
     &,              ftemp, fsalt, ftaux, ftauy, fhflx, fsflx
     &,              fsst, fsss, fsnapo, ftavgo, fresto
     &,              fice, ft10, fq10, fswr, flwr, fsnapi, fresti
     &,              fatmos, friver, fwspd, ftbar, fqbar, felev
     &,              frtbar, frqbar, fsnapa, ftavga, fresta
     &,              ffiles
     &,              pocnin, pocnout, picein, piceout, patmin, patmout
c====================== include file "csbc.h" ==========================
c
c                    surface boundary conditions (S.B.C.)
c
c
c     numosbc = number of ocean S.B.C..
c
c     numasbc = number of atmospheric S.B.C..
c
c     maxsbc  = maximum number of allowable S.B.C. fields.
c
c     numsbc  = total number of S.B.C. this is the sum of the 
c               atmosphere S.B.C. and ocean S.B.C. fields. it must
c               be less than or equal to "maxsbc".
c
c     sbcocn  = S.B.C. fields on the ocean grid.
c               n=1..numosbc are for the incoming ocean S.B.C.
c               n=numosbc+1..numosbc+numasbc are for the outgoing S.B.C.
c

c
c     ntspos  = number of time steps per ocean segment
c
c     sbcname  = S.B.C. character string names (eg: "SST", "taux", etc)
c               note that these character strings should be changed with
c               care since they are used to identify fields for special
c               treatment
c
c     dunits  = dimensional units for S.B.C. (eg: "deg C")
c
c     mapsbc  = indices for relating how S.B.C. fields are stored
c               within arrays "sbcocn" and "sbcatm"  
c               eg: m = mapsbc(n) where sbcocn(,,m) is S.B.C. "n"
c
c     restrictions on re-arranging S.B.C. fields and "mapsbc":
c
c     1) all ocean S.B.C. (taux, tauy, etc) should be grouped together. 
c        relative ordering within the group is unimportant but the
c        group must preceed the atmos S.B.C. group.
c
c     2) all atmos S.B.C. (sst, ...) should also be grouped together.
c        relative ordering within the group is unimportant.
c
c     the default arrangement is defined as:
c
c             (these five ocean S.B.C. come from the atmos )
c     mapsbc(1) references taux
c     mapsbc(2) references tauy
c     mapsbc(3) references heat flux
c     mapsbc(4) references salt flux
c      if the atmos supplied fresh water flux then it
c      would have to be converted to ...
c      salt flux  = -(P-E+R) * rho * Sref
c      where...
c      P-E+R represents a precipitation minus evaporation
c            plus runoff rate in cm of water/sec
c      rho is the density if water taken to be 1 g/cm**3, and
c      Sref is a reference salinity in units of grams of salt per
c            gram of water (in units of "parts per part" such
c            as 0.035 ... not "parts per thousand")
c      Depending upon the application of interest, users may wish
c      to set Sref to either be a constant over the entire model
c      domain or for it to be the locally predicted salinity of
c      the uppermost model level (S(1)).  If one desires to ensure
c      that a global average P-E+R flux of zero translates to zero
c      trend in the salt content of the ocean, then a constant Sref
c      is needed.      
c     mapsbc(5) references short wave
c
c             (these four atmos S.B.C. come from the ocean)
c     mapsbc(6) references SST
c     mapsbc(7) references SSS
c     mapsbc(8) references surface u
c     mapsbc(9) references surface v
c
c
c     when re-ordering S.B.C., search for "mapsbc"  
c     (eg: grep mapsbc *.F) to insure the new indexing is consistant
c     with the re-ordering. also make changes in "sbcname", "dunits", 
c     "coabc", and "crits" to maintain consistancy.
c
c     example 1: suppose you want only the first six S.B.C...
c                in "csbc.h", set  numosbc=5, numasbc=1
c                this reduces memory requirements.
c                no other changes are necessary
c
c     example 2: suppose you want to remove the short wave boundary
c                condition (to save more memory) from example 1 . 
c                a) in "csbc.h", set numosbc=4, numasbc=1
c                b) grep "mapsbc(5)" *.F to find and remove references
c                c) grep "mapsbc(6)" *.F to change references to 
c                                        mapsbc(5)
c
c     
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c
c
      logical asegs, asege, afirst, alast
      character*10 sbcname
      character*15 dunits
c
      parameter (numosbc=5
     &,          numasbc=4
     &,          maxsbc=numosbc+numasbc, numsbc=maxsbc)
c
      common /csbc/ sbcocn(imt,jmt,numsbc) 
      common /csbc/ dampts(nt), dampdz(nt)
      common /csbc/ coabc(maxsbc), crits(maxsbc)
      common /csbc1/ mapsbc(maxsbc), numpas, iombc, ntspos, ntspas
      common /csbc2/ sbcname(maxsbc), dunits(maxsbc)
      common /csbc3/ asegs, asege, afirst, alast 
c
c====================== include file "levind.h" ========================
c
c     vertical level indicators which define model geometry & bottom
c     topography:
c
c     kmt = number of vertical boxes over "t" points
c     kmu = number of vertical boxes over "u,v" points
c
      common /levind/ kmt(imt,jmt), kmu(imt,jmt)
c
c====================== include file "mapsbc.h" ========================
c
c     indicies for surface boundary condition arrays.  names must be
c     unique and are set at the begining of "driver"
c
c     itaux is the x component of wind stress
c     itauy is the y component of wind stress
c     ihflx is heat flux
c     ipme is for precipitation minus evaporation
c     ipsw is for penitrating shortwave (into ocean first layer)
c     isst is the ocean model SST
c     isss is the ocean model SSS
c     isu is the x component of the ocean model first layer velocity
c     isv is the y component of the ocean model first layer velocity
c     it10 is the 10 metre atmopheric temperature
c     iq10 is the 10 metre atmopheric humidity
c     ilwr is incoming longwave radiation
c     iswr is incoming shortwave radiation
c     igu is the x component of the ocean model second layer velocity
c     igv is the y component of the ocean model second layer velocity
c
      common /mapsbc/ itaux, itauy, ihflx, ipme, ipsw, isst, isss
     &,               isu, isv, it10, iq10, ilwr, iswr, igu, igv
c
c====================== include file "switch.h" ========================
c
c     all time dependent decisions are made by time manager "tmngr.F"
c     and communicated elsewhere to the model via logical switches.
c
c     inputs: (defaulted in "blkdta.F", optionally reset via namelist)
c
c
c     runlen  = integration period (see rununits). note "runlen" should
c               be an integral number of density time steps. if not,
c               then "runlen" is automatically adjusted to insure this.
c               fractional days are supported but not fractional months
c               or years.
c     rununits= units of "runlen". may be "days", "months", or "years".
c               tmngr will convert "runlen" which is in "rununits"
c               to "rundays" in units of days.
c
c     segtim  = the integration time "runlen" is broken into a number of
c               segments each of length "segtim" days. updated surface
c               boundary conditions are applied to MOM every "segtim" 
c               days. this is useful when coupling to atmospheric models
c               in which case both models exchange surface boundary
c               conditions every "segtim" days where "segtim"
c               is 1/(coupling frequency). without an atmospheric model,
c               when getting surface boundary conditions from data, 
c               "segtim" is set to the time step (in days) by mom.F. in
c               either case, "runlen" (in days) should be an integral
c               number of "segtim".     
c
c     nmix    = number of time steps between mixing timesteps. used
c               to damp timestep splitting due to centered leapfrog.
c
c     init    = (true,false)  indicates that this run is a
c               (start from initial conditions, restart)
c
c     restrt  = (true,false) = (do,don`t) write a restart at the end
c               of the run
c
c     eb      = (true,false) configures for the use of a 
c               (euler backward,forward) type mixing timestep
c
c-----------------------------------------------------------------------
c     inputs to tmngr.F: diagnostic intervals
c-----------------------------------------------------------------------
c
c     note: switches are used to control the interval between doing
c           diagnostics. units for all switches are in days. 
c           setting a switch < 0.0 disables whatever the switch is 
c           controlling. setting it = 0.0 causes the diagnostic to be 
c           done every time step, and setting it > 0.0 causes the 
c           diagnostic to be done repeatedly on the specified interval. 
c
c     cmixint = number of days between writing estimated mixing coeffs
c               on faces of T cells and U cells
c
c     crossint = number of days between writing diapycnal and isopycnal
c               components of flow
c
c     fctint = number of days between writing difference between 
c              FCT and leapfrog advection
c
c     densityint = number of days between writing density
c
c     exconvint = number of days between writing temperature rate of
c                 change due to explicit convection
c
c     glenint =  number of days between global energetics integrals.
c
c     trmbint =  number of days between momentum and tracer term
c                balances (global and regional).
c
c     itrmb   = (true,false) = (do,don`t) write regional mask info for
c               the term balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     gyreint =  number of days between calculation of tracer northward
c                transport.
c     igyre   = (true,false) = (do,don`t) write regional mask info for
c               the gyre diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     vmsfint =  number of days between calculation of vertical and
c                meridional stream function.
c
c     tyzint  =  number of days between calculation of zonally averaged
c                tracer components.
c
c     prxzint =  number of days between printouts of x-z data.
c
c     extint  =  number of days between printouts of external mode.
c
c     dspint  =  number of days between surface pressure calculation.
c                Note: only when "diagnostic_surface_height" is enabled.
c     dspper  = averaging period for "diagnostic_surface_height"
c
c     tavgint = number of days between regional tracer averages (under
c               horizontal regions).
c
c     itavg   = (true,false) = (do,don`t) write regional mask info for
c               the tracer average diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     tmbint  = number of days over which tracer equation in averaged
c               in depth and longitude to determine the meridional 
c               balance among storage, divergence, dissipation and 
c               forcing.
c     tmbper  = averaging period for "meridional_tracer_balance"
c
c     itmb    = (true,false) = (do,don`t) write "msktmb" for tracer
c               the meridional balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c
c     tsiint  = number of days between printing of time step integrals.
c
c     stabint = number of days between sampling for various stability
c               criteria.
c
c     snapint = number of days between writing instantaneous samples
c               of data from the MOM grid. note: only when "snapshots"
c               is enabled. see "iounit.h" for more details.
c               all data is at time level "tau" so it is one time step
c               before the date shown in "stamp".
c
c     timavgint= interval (days) for writing time mean data from
c               the "averaging" grid (only when "time_averages" is
c               enabled). if "timavgint" is not an integral number of
c               density time steps,"timavgint" is automatically adjusted
c               to insure this. if the number of days to integrate is
c               not an integral number of "timavgint" then the last
c               averaging period will be less than "timavgint" days.this 
c               may lead to one more averaging period than expected. 
c               see "iounit.h" for more details.
c     timavgper= averaging period for "time_averages"
c
c     xbtint  = averaging period (days) for writing XBT data (only when
c               "xbts" is enabled). if "xbtint" is not an integral
c               number of density time steps, "xbtint" is automatically
c               adjusted to insure this. if the number of days to 
c               integrate is not an integral number of "xbtint" then the
c               last averaging period will be less than "xbtint" days.
c               this may lead to one more averaging period than  
c               expected. see "iounit.h" for more details.
c     xbtper  = averaging period for "xbts"
c
c     zmbcint = number of days between calculation of zonal mean
c               surface boundary conditions (and related  quantities)
c
c     trajint = number of days between writing particle trajectories.
c               particle trajectories are always written on the last
c               time step of the run to allow for restarting.
c
c-----------------------------------------------------------------------
c     outputs from tmngr.F: logical switches
c-----------------------------------------------------------------------
c
c     rundays = integration time in days (from "runlen")
c
c     the following are logical counterparts to the above switches are 
c     set within "tmngr" every time step. logical switches control all
c     decisions about when to do things in MOM.
c
c     cmixts  = (false,true) = (don`t, do) do write estimated mixing
c               coefficients on this time step.
c               based on "cmixint".
c
c     crossts  = (false,true) = (don`t, do) write diapycnal and 
c               isopycnal components of flow on this time step.
c               based on "crossint".
c
c     fctts    = (false,true) = (don`t, do) write difference between 
c               FCT and leapfrog advection on this time step.
c               based on "fctint".
c
c     densityts  = (false,true) = (don`t, do) write density on this time
c               step. based on "densityint".
c               
c
c     exconvts  = (false,true) = (don`t, do) do write temperature change
c               due to explicit convection on this time step.
c               based on "exconvint".
c
c     glents  = (false,true) = (don`t, do) do calculation of global
c               energy integrals on this time step. based on "glenint".
c
c     trmbts  = (false,true) = (don`t, do) do calculation of momentum &
c               tracer term balance on this timestep. based on "trmbint"
c
c     gyrets  = (false,true) = (don`t, do) do calculation of tracer
c               northward transport on this timestep. based on "gyreint"
c
c     vmsfts  = (false,true) = (don`t, do) do calculation of vertical
c               and meridional stream function on this time step.
c               based on "vmsfint"
c
c     tyzts   = (false,true) = (don`t, do) do calculation of zonally
c               averaged tracer components on this time step.
c               based on "tyzint"
c
c     prxzts  = (false,true) = (don`t, do) do printouts of x-z data
c               on this time step. based on "prxzint"
c
c     extts  = (false,true) = (don`t, do) do printout of external mode
c               on this time step. based on "extint"
c
c     dspts  = (false,true) = (don`t, do) do calculation of diagnostic 
c              surface pressure on this time step. based on "dspint"
c               
c
c     stabts  = (false,true) = (don`t, do) test for stability on this
c               time step. based on "stabint"
c
c     tavgts  = (false,true) = (don`t do) do tracer averages on this
c               time step. based on "tavgint"
c
c     tmbts   = (false,true) = (don`t, do) write out tracer meridional .
c               balance on this time step. based on "tmbint"
c
c     tsits   = (false,true) = (don`t, do) print time step integrals
c               on this time step. based on "tsiint"
c
c     zmbcts  = (false,true) = (don`t, do) print zonal mean boundary
c               conditions on this time step.  based on "zmbcint"
c
c     trajts  = (false,true) = (don`t, do) print particle trajectories
c               on this time step. based on "trajint"
c
c     snapts  = (false,true) = (don`t, do) save a snapshot of the data
c               on this time step. based on "snapint"
c
c     timats  = (false,true) = (don`t, do) write time mean data
c               on this time step. based on "timavgint"
c                                          
c     xbtts   = (false,true) = (don`t, do) write averaged XBT data on
c               this time step based on "xbtint"
c
c
c     leapfrog= (false,true) on a (mixing, normal leapfrog) time step
c                based on "nmix"
c                                          
c     euler1  = true on the 1st pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     euler2  = true on the 2nd pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     forward = true on a forward time step. otherwise false
c		(applies when "eb" = false)		  
c                                          
c
c     the following logical switches are based on the model time step. 
c    
c     first   = (true,false) =  when it`s (the first, not the first)
c                               time step of a run
c     eots    = end of a time step. always true except for first
c               pass of an euler backward time step
c     eorun   = last time step of a run. always false except during the
c               last time step of the run.
c
c     eoday   = true when within 1/2 time step of the end of a day
c               else ... false
c     eoweek  = true when within 1/2 time step of the end of a 7 day
c               week (referenced to the start of a year) else ...false
c     eo2wks  = true when within 1/2 time step of the end of two weeks
c               (referenced to the start of a year) else ... false
c     midmon  = true when within 1/2 time step of the middle of a month
c               else ... false
c     eomon   = true when within 1/2 time step of the end of a month
c               else ... false
c     eoyear  = true when within 1/2 time step of the end of a year
c               else ... false
c     osegs   = true on the 1st time step of an ocean segment in mom.F
c               otherwise false.
c     osege  =  true on the last time step of an ocean segment in mom.F
c               otherwise false.
c
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c
c
      logical eb, leapfrog, euler1, euler2, forward, eots
      logical init, first, restrt
      logical itavg, itmb, itrmb, igyre
      character *8 rununits
c
      common /switcc/ rununits
      common /switcr/ runlen, rundays
      common /switci/ nmix
      common /switcl/ eb, leapfrog, euler1, euler2, forward, eots
      common /switcl/ init, first, restrt
      common /switcl/ itavg, itmb, itrmb, igyre
c
      logical          eoday, eoweek, eo2wks
      common /switci/ ieoday,ieoweek,ieo2wks
      common /switcl/  eoday, eoweek, eo2wks
c
      logical          eomon, midmon, eoyear, eorun
      common /switci/ ieomon,imidmon,ieoyear,ieorun
      common /switcl/  eomon, midmon, eoyear, eorun
c
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c     each interval switch needs three variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output (e.g,.  glenint)
c         2) a switch (logical) for the interval (e.g.,  glents )
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c         3) an index (integer)                       (e.g., iglenint)
c
c     the user must specify the interval [e.g., glenint] for diagnostic
c     output in units of days. tmngr sets the corresponding logical  
c     switch [e.g., glents] every time step. It is set to true when  
c     within half a time step of the requested interval, otherwise it is
c     false. All decisions relating to the interval [e.g., glenint]
c     are based on the logical switch [e.g., glents].
c           
c     internal time structures
c
c     The switch index [e.g., iglenint] is used to subsrcipt into  
c     internal arrays maintained by tmngr.F. The switch index is
c     allocated on the first call to function "alarm".
c     The array entry [e.g., iinterval(iglenint)] is a time index to the
c     internal representation of the interval [e.g., glenint].
c     The array entry [e.g., ialarm(iglenint)] is a time index to the
c     next time the alarm will be true.
c-----------------------------------------------------------------------
c
      logical           tavgts,    glents,    trmbts,   prxzts
      common /switcr/   tavgint,   glenint,   trmbint,  prxzint
      common /switci/  itavgint,  iglenint,  itrmbint, iprxzint
      common /switcl/   tavgts,    glents,    trmbts,   prxzts
c
      logical          extts,   trajts,   exconvts,   cmixts
      common /switcr/  extint,  trajint,  exconvint,  cmixint
      common /switci/ iextint, itrajint, iexconvint, icmixint
      common /switcl/  extts,   trajts,   exconvts,   cmixts
c
      logical          vmsfts,   gyrets,    tsits,   snapts,   fctts
      common /switcr/  vmsfint,  gyreint,   tsiint,  snapint,  fctint
      common /switci/ ivmsfint, igyreint,  itsiint, isnapint, ifctint
      common /switcl/  vmsfts,   gyrets,    tsits,   snapts,   fctts
c
      logical          tyzts
      common /switcr/  tyzint
      common /switci/ ityzint
      common /switcl/  tyzts
c
      logical          stabts,   zmbcts,   crossts,   densityts
      common /switcr/  stabint,  zmbcint,  crossint,  densityint
      common /switci/ istabint, izmbcint, icrossint, idensityint
      common /switcl/  stabts,   zmbcts,   crossts,   densityts
c
      logical          osegs,  osege
      common /switcr/          segtim
      common /switci/ iosegs, iosege
      common /switcl/  osegs,  osege
c   
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c              A N D   A V E R A G I N G   P E R I O D
c
c     each averaging period switch needs five variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output    (e.g. xbtint  )   
c         2) a switch (logical) for the interval         (e.g. xbtts   )
c         3) an averaging period (real)                  (e.g. xbtper  )   
c         4) a switch (logical) for accumulating         (e.g. xbtperts)
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switches
c
c         5) an index (integer)                         (e.g. ixbtint  )
c
c     The user must specify the interval [e.g., xbtint] for diagnostic
c     output in units of days and the averaging period [e.g., xbtper] 
c     in units of days. The averaging period may be less than or equal
c     to the interval. For example, if the interval is 30.0 days and the
c     averaging period is 5.0 days, results will be averaged over all
c     time steps within days 26, 27, 28, 29, and 30.  An averaging period
c     of 0.0 days averages over the last time step of the interval (as
c     does xbtper = dt), and an averaging period less than zero turns
c     the switches off for all time steps.  
c
c     The logical switch for writing output at the specified interval 
c     [e.g., xbtts] is set to true on the last time step of the 
c     averaging period. The logical switch for accumulating results
c     [e.g., xbtperts] is true for all time steps within the averaging
c     period, otherwise it is false. 
c
c     internal time structures
c
c     The index [e.g., ixbtint] is allocated on the first call to 
c     function "avg_alarm". The array element iperiod(ixbtint) is an
c     index to the time structure for the internal representation of 
c     "xbtper", and ilastsw(ixbtint) is the index of the switch that 
c     flags the last time step of the accumulation period.
c     Depending on use,  ilastsw(ixbtint) may either be the index
c     of another "named" switch or the index of a new switch
c     allocated on the first time step.
c     In the latter case, iinterval(ilastsw(ixbtint)) is the index of
c     the time structure where "xbtint" is stored in internal form,
c     and ialarm(ilastsw(ixbtint)) is the index of the time when an
c     accumulation period will next end.
c     The variable nextts(ixbtint) is true whenever the next
c     time step will begin the accumulation period.
c
c-----------------------------------------------------------------------
c
      logical         xbtts,     dspts,    tmbts,    timavgts
      logical         xbtperts,  dspperts, tmbperts, timavgperts
      common /switcr/ xbtint,    dspint,   tmbint,   timavgint
      common /switcr/ xbtper,    dspper,   tmbper,   timavgper
      common /switci/ixbtint,   idspint,  itmbint,  itimavgint
      common /switcl/ xbtts,     dspts,    tmbts,    timavgts
      common /switcl/ xbtperts,  dspperts, tmbperts, timavgperts
c
c-----------------------------------------------------------------------
c
c                 S W I T C H E S    B A S E D    O N    
c
c         C A L E N D A R   O R    P R E V I O U S    S W I T C H   
c
c               A N D   A V E R A G I N G    P E R I O D
c
c    
c
c     the following logical switches are based on any calendar or 
c     interval switch and an averaging period (in days). The  averaging
c     period must be less than or equal to the interval. The last
c     time step of the averaging period is at the end of the interval.
c     If the averaging period is set to zero, the averaging period
c     consists only of the last time period of the interval.  If
c     the averaging period is less than zero, these switches are always
c     false.
c
c     each averaging period switch needs four variables in common. For
c     example, if the averaging period is before the end of each month
c     then the calendar switch (eomon), and index (ieomon) are presumed
c     to exist in common and need not be added.
c     
c     Additionally, four items are needed.
c
c       1) an averaging period (real)                  (e.g.  testper  )   
c       2) a switch (logical) for accumulating results (e.g.  testperts)
c       3) a switch (logical) for the end of interval  (e.g.  testts   )
c
c     the fourth is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c       4) an index (integer)                          (e.g.  itestper )
c
c     Suppose it is required to produce averages over all time steps
c     during the last 5 days of each month. Then "testper" = 5.0 and 
c     the following will calculate the accumulating switch.
c
c      testts = avg_alarm(itestper, ihalfstep, 0, testper, iref, ieomon)
c      testperts = on(itestper)
c
c     Note the use of "ieomon" to key off the months.  The switch
c     "testts" will be true whenever "eomon" is true.
c     Also note that when an averaging switch is keyed off another
c     switch, the switch inverval argument is not used, but is 
c     retained for consistency with the form of other averaging
c     switches.
c-----------------------------------------------------------------------
c
      logical           testperts
      logical           testts
      common /switcr/   testint
      common /switcr/   testper
      common /switci/  itestper
      common /switcl/   testts
      common /switcl/   testperts

c
      parameter (maxsw=100)
      logical          on, lastts, nextts
      common /switci/  nsw  
      common /switci/  ialarm(maxsw), iinterval(maxsw), iperiod(maxsw)
     &,                ilastsw(maxsw)
      common /switcl/  on(maxsw), lastts(maxsw), nextts(maxsw)
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c


c
c martin
c      call pathfile (patmout, fresta, pf)
      call getunit (nu, pf, 'u s r ieee')
      write (*,'(a,a,a,i10,1x,a)') 
     &  ' ==>  Writing an atmospheric restart to file '
     &,   pf(1:len_trim(pf)), ' on ts=', itt, stamp
c

      isst = mapsbc(6)
      isss = mapsbc(7)

c
      nfields = 4


      write (nu) imt, jmt, nats, dayoyr
      write (nu) nfields
      write (nu) 'time      '
      write (nu) itt, iday(imodeltime), msday(imodeltime), stamp
      write (nu) 'at        '
      write (nu) ((((at(i,j,l,n),i=1,imt),j=1,jmt),l=1,2),n=1,nat)
      write (nu) 'sst       '
      write (nu) ((sbcocn(i,j,isst),i=1,imt),j=1,jmt)
      write (nu) 'sss       '
      write (nu) ((sbcocn(i,j,isss),i=1,imt),j=1,jmt)


c
      call release_all
c
      return
      end 


      subroutine fluxes
c
c=======================================================================
c     calculate energy and moisture fluxes
c     based on code by a.fanning
c
c     Note: evaporation and precipitation are in cm/s
c           and humidities are in g/g
c
c     for Thompson and Warren outgoing radiation (see: Thommpson S.J.,
c     and S.G. Warren 'parameterization of outgoing ...'J. Atmos. Sci.,
c     39, 2667-2680, 1982.
c
c     for cloud parameterization (1) see:
c     Berliand, M.E. and T.G. Berliand, 'determining the net ...', 
c     Isv. Akad. Nauk. SSSR Ser. Geofiz No. 1, 1952.
c     or
c     Esbensen S.K., and Y. Kushnir, 'the heat budget of the global ...'
c     Clim. Res. Inst., Rep 29., Dep. Atmos. Sci., Oregon State Univ.,
c     Oregon, 1981.
c
c     author:   m.eby   e-mail: eby@uvic.ca
c=======================================================================
c
c====================== include file "param.h" =========================
c
c     main parameter file which sets ocean characteristics:
c
c     "size.h" sets model size "imt", "jmt", and "km"
c
c====================== include file "size.h" ==========================
c                                                                       
c-----------------------------------------------------------------------
c     USER INPUT: 
c-----------------------------------------------------------------------
c
c     imt    = number of grid points in the longitudinal direction
c              (calculated points are from 2 through imt-1. End points
c               are boundaries)          
c
c     jmt    = number of grid points (latitude rows) in the latitudinal
c              direction (calculated points are from 2 through jmt-1.           
c              End points are boundaries)   
c                                
c     km     = number of grid points in the vertical direction          
c              (calculated points are from 1 through km)
c
c     nt     = number of tracers (temperature, salinity, ...)
c
c     mnisle = maximum number of islands (unconnected land masses)
c
c     maxipp = maximum number of all island perimeter points
c-----------------------------------------------------------------------
c                                                                       
      parameter (imt=  92, jmt=  61, km= 15)
      parameter (nt=2)
      parameter (nat=2)
      parameter (mnisle=50, maxipp=5000)
c

c






c
c-----------------------------------------------------------------------
c     END USER INPUT
c-----------------------------------------------------------------------
c                                                                       
c-----------------------------------------------------------------------
c     By default, the MW (memory window) is 2nd order except for the
c     following options which require a 4th order MW 
c
c     for 2nd order schemes, the minimum sized MW is 3 latitude rows
c     for 4th order schemes, the minimum sized MW is 4 latitude rows
c                            (5 if using coarse_grained_parallelism)
c-----------------------------------------------------------------------
c













c
c-----------------------------------------------------------------------
c     set MW (memory window) size "jmw" 
c-----------------------------------------------------------------------
c                                                                       

c
c     for UNI-TASKING: "jmw" is set to the minimum for each option class 
c     "jmw" may be increased up to "jmt" 
c

      parameter (jmw=jmt)


c
c-----------------------------------------------------------------------
c     set first and last calculated row within the MW. other rows
c     are used as buffers
c-----------------------------------------------------------------------
c
c     jsmw   = 1st calculated row within the MW     
c     jemw   = last calculated row within the MW
c
      parameter (jsmw=2, jemw=jmw-1)
c
c
c     jextra = extra buffer rows needed for coarse_grained_parallelism.
c              "jextra" rows are added to the top and bottom of the MW
c              so the MW size increases by 2*jextra       
c

          parameter (jextra = 0)




c
c     nvar   = number of prognostic variables
c     lseg   = maximum number of longitudinal stream function segments
c     nlatpr = maximum number of latitudes for matrix printouts
c              on diagnostic time steps
c     nhreg  = number of regions in the horizontal used for averaging
c              tracers.
c     nvreg  = number of regions in the vertical used for term balance
c              calculations. note "nvreg" isn`t used for tracer averages
c     numreg = total number of regions ( = product of nhreg & nvreg)
c              used for term balance calculations
c
      parameter (lseg=5, nlatpr=10)

      parameter (nhreg=5, nvreg=2, numreg=nhreg*nvreg)

      parameter (nvar=nt+2)
c

c
      parameter (imtm1=imt-1, kmm1=km-1)                                
      parameter (imtp1=imt+1, imtm2=imt-2
     &,          jmtp1=jmt+1, jmtm1=jmt-1, jmtm2=jmt-2

     &,          jscan=jmtm2

     &,          kmp1=km+1, kmp2=km+2
     &,          imtkm=imt*km, nwds=imt*jmt, nkflds=2
     &,          nslab=imt*nvar*km, ntmin2=nt+1/nt)
c
c     include parameter constants
c
c====================== include file "pconst.h" ========================
c
c
c     rules for parameter constants
c
c     use prefix of "c" for whole real numbers (eg: c57 for 57.0)
c     use "m" after prefix to designate negative values (minus sign)
c       (eg: cm7 for -7.0)
c     use prefix of "p" for non repeating fractions (eg: p5 for 0.5)
c     use prefix of "r" for reciprocals (eg: r3 for 1/3.0)
c     combine use of prefix above and "e" for scientific notation, with
c       (eg: c5e4 for 5.0e4, c1em10 for 1.0e-10)
c
      parameter (c0=0.0, c1=1.0, c2=2.0, c3=3.0, c4=4.0, c5=5.0, c7=7.0)
      parameter (c8=8.0)
      parameter (c14=14.0, c16=16.0, c360=360.0)
      parameter (p125=0.125, p25=0.25, p5=0.5, p75=0.75)
      parameter (epsln=1.0e-20)
c
      parameter (c24=24.0, c60=60.0, c1440=1440.0)
      parameter (r24=c1/c24, r60=c1/c60, r1440=c1/c1440)
      parameter (secday=c1/(c60*c1440))
c
c     include standard I/O units
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c
c     ncrows = number of calculated rows within the MW.
c              (the remaining rows are buffer rows). 
c


      parameter (ncrows = jmw - 2)


c====================== include file "cembm.h" =========================
c
c     parameters for use in the energy balance model (also see atm.h)
c
c     addflux		= logical flag for adding only even mode fluxes
c     nats		= number of atmospheric time steps since mixing
c     namix		= time steps between mixing (set in atmos.in)
c     lf		= time step flag (1=>leapfrog, 2=>forward)
c     pyear		= calendar year (set in atmos.in, -/+ = BC/AD)
c     dtatm 		= time step for atmosphere (set in atmos.in)
c     dts		= time step (2*dtatm=>leapfrog, dtatm=>forward)
c     co2ccn		= CO2 concentration
c     anthro		= radiative forcing by CO2
c     co2ccni		= initial CO2 concentration
c     co2yri		= last year of initial CO2 concentration
c     co2ccnf		= final CO2 concentration
c     co2yrf		= first year of final CO2 concentration
c     solarconst	= solar constant (g/s**3)
c     ssp		= sea surface pressure (g/cm/s**2)
c     cdatm 		= drag coefficient (dimensionless)
c     cpatm		= atmospheric heat capacity (cm**2/s**2/K)
c     ht		= scale height for temperature
c     hq		= scale height for specific humidity
c     rhoatm		= density of air at sea surface (g/cm**3)
c     rhoocn		= representative sea surface density
c     esocn		= ocean emissivity times Stefan's constant 
c     vlocn		= latent heat of vaporization of water
c     socn		= constant ocean salinity
c     cdice 		= drag coefficient (dimensionless)
c     rhoice		= ice density (g/cm**3)
c     esice		= ice emissivity times Stefan's constant 
c     slice		= latent heat of sublimation of ice
c     flice		= latent heat of fusion of ice (cm**2/s**2)
c     condice		= ice conductivity (g*cm/s**3/K)
c     kadv		= time step divider for ice advection
c     ntats		= time step counter for time averaging
c     avetime		= time for averaging fluxes
c     totaltime		= total time for long term averages
c
      logical addflux
c
      common /cembm/ addflux
      common /cembm/ nats, namix, lf, kadv, ntats
      common /cembm/ pyear, dtatm, dts, co2ccn, anthro, co2ccni, co2yri
     &,              co2ccnf, co2yrf, solarconst, ssp, cdatm, cpatm, ht
     &,              hq, rhoatm, rhoocn, esocn, vlocn, socn, cdice
     &,              rhoice, esice, slice, flice, condice, avetime 
     &,              totaltime
c
c====================== include file "atm.h" ===========================
c
c     arrays for the energy-moisture balance model
c
c     note: units for heat flux are in g/cm**2/s**3/cm**2 or (mW/m**2)
c           units for fresh water flux are in cm/s
c           downward is into the surface (ocean, ice or land)
c           upward is into the bottom of the atmosphere
c           outward is out of the top of the atmosphere
c           inward is into the top of the atmosphere
c
c     outlwr(imt,jmt)	 = outgoing atmosphere longwave flux
c     at(imt,jmt,2,nat)	 = tracers (previous and most recent)
c     surf(imt,jmt,nat)	 = surface values (1=temperature, 2=humidity)
c     flux(imt,jmt,nat)	 = downward flux (1=heat, 2=fresh water)
c     precip(imt,jmt)	 = precipitation
c     evap(imt,jmt)	 = evaporation
c     dnswr(imt,jmt)  	 = downward surface shortwave flux
c     uplwr(imt,jmt)  	 = upward surface longwave flux
c     upsens(imt,jmt)	 = upward surface sensible heat flux
c     upltnt(imt,jmt)    = upward surface latent heat flux
c     ssh(imt,jmt) 	 = saturation specific humidity
c     spd(imt,jmt) 	 = wind speed (cm/sec)
c     da(jmt,nat)	 = tracer diffusivity parameterization
c     coalbedo(jmt)	 = planetary coalbedo
c     solins(jmt)	 = solar insolation (units of solarconst)
c     esatm(jmt)	 = atmosphere emissivity times Stefan's constant
c     scatter(jmt)	 = solar scattering into atmosphere





c     cori(jmt,2)	 = Coriolis parameter

c
      real outlwr(imt,jmt), at(imt,jmt,3,nat), surf(imt,jmt,nat)
      real flux(imt,jmt,nat), precip(imt,jmt), evap(imt,jmt)
      real dnswr(imt,jmt), uplwr(imt,jmt), upsens(imt,jmt)
      real upltnt(imt,jmt), ssh(imt,jmt), spd(imt,jmt), da(jmt,nat)
      real coalbedo(jmt), solins(jmt), esatm(jmt), scatter(jmt)





      real cori(jmt,2)
c
      common /atm/ outlwr, at, surf, flux, precip, evap, dnswr, uplwr
     &,            upsens, upltnt, spd, ssh, da, coalbedo, solins
     &,            esatm, scatter





     &,            cori
c
c====================== include file "levind.h" ========================
c
c     vertical level indicators which define model geometry & bottom
c     topography:
c
c     kmt = number of vertical boxes over "t" points
c     kmu = number of vertical boxes over "u,v" points
c
      common /levind/ kmt(imt,jmt), kmu(imt,jmt)
c
c====================== include file "csbc.h" ==========================
c
c                    surface boundary conditions (S.B.C.)
c
c
c     numosbc = number of ocean S.B.C..
c
c     numasbc = number of atmospheric S.B.C..
c
c     maxsbc  = maximum number of allowable S.B.C. fields.
c
c     numsbc  = total number of S.B.C. this is the sum of the 
c               atmosphere S.B.C. and ocean S.B.C. fields. it must
c               be less than or equal to "maxsbc".
c
c     sbcocn  = S.B.C. fields on the ocean grid.
c               n=1..numosbc are for the incoming ocean S.B.C.
c               n=numosbc+1..numosbc+numasbc are for the outgoing S.B.C.
c

c
c     ntspos  = number of time steps per ocean segment
c
c     sbcname  = S.B.C. character string names (eg: "SST", "taux", etc)
c               note that these character strings should be changed with
c               care since they are used to identify fields for special
c               treatment
c
c     dunits  = dimensional units for S.B.C. (eg: "deg C")
c
c     mapsbc  = indices for relating how S.B.C. fields are stored
c               within arrays "sbcocn" and "sbcatm"  
c               eg: m = mapsbc(n) where sbcocn(,,m) is S.B.C. "n"
c
c     restrictions on re-arranging S.B.C. fields and "mapsbc":
c
c     1) all ocean S.B.C. (taux, tauy, etc) should be grouped together. 
c        relative ordering within the group is unimportant but the
c        group must preceed the atmos S.B.C. group.
c
c     2) all atmos S.B.C. (sst, ...) should also be grouped together.
c        relative ordering within the group is unimportant.
c
c     the default arrangement is defined as:
c
c             (these five ocean S.B.C. come from the atmos )
c     mapsbc(1) references taux
c     mapsbc(2) references tauy
c     mapsbc(3) references heat flux
c     mapsbc(4) references salt flux
c      if the atmos supplied fresh water flux then it
c      would have to be converted to ...
c      salt flux  = -(P-E+R) * rho * Sref
c      where...
c      P-E+R represents a precipitation minus evaporation
c            plus runoff rate in cm of water/sec
c      rho is the density if water taken to be 1 g/cm**3, and
c      Sref is a reference salinity in units of grams of salt per
c            gram of water (in units of "parts per part" such
c            as 0.035 ... not "parts per thousand")
c      Depending upon the application of interest, users may wish
c      to set Sref to either be a constant over the entire model
c      domain or for it to be the locally predicted salinity of
c      the uppermost model level (S(1)).  If one desires to ensure
c      that a global average P-E+R flux of zero translates to zero
c      trend in the salt content of the ocean, then a constant Sref
c      is needed.      
c     mapsbc(5) references short wave
c
c             (these four atmos S.B.C. come from the ocean)
c     mapsbc(6) references SST
c     mapsbc(7) references SSS
c     mapsbc(8) references surface u
c     mapsbc(9) references surface v
c
c
c     when re-ordering S.B.C., search for "mapsbc"  
c     (eg: grep mapsbc *.F) to insure the new indexing is consistant
c     with the re-ordering. also make changes in "sbcname", "dunits", 
c     "coabc", and "crits" to maintain consistancy.
c
c     example 1: suppose you want only the first six S.B.C...
c                in "csbc.h", set  numosbc=5, numasbc=1
c                this reduces memory requirements.
c                no other changes are necessary
c
c     example 2: suppose you want to remove the short wave boundary
c                condition (to save more memory) from example 1 . 
c                a) in "csbc.h", set numosbc=4, numasbc=1
c                b) grep "mapsbc(5)" *.F to find and remove references
c                c) grep "mapsbc(6)" *.F to change references to 
c                                        mapsbc(5)
c
c     
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c
c
      logical asegs, asege, afirst, alast
      character*10 sbcname
      character*15 dunits
c
      parameter (numosbc=5
     &,          numasbc=4
     &,          maxsbc=numosbc+numasbc, numsbc=maxsbc)
c
      common /csbc/ sbcocn(imt,jmt,numsbc) 
      common /csbc/ dampts(nt), dampdz(nt)
      common /csbc/ coabc(maxsbc), crits(maxsbc)
      common /csbc1/ mapsbc(maxsbc), numpas, iombc, ntspos, ntspas
      common /csbc2/ sbcname(maxsbc), dunits(maxsbc)
      common /csbc3/ asegs, asege, afirst, alast 
c
c
c-----------------------------------------------------------------------
c     set appropriate constants
c-----------------------------------------------------------------------
c
      fa = 3.80116e03/ssp
      fb = rhoatm/rhoocn
      fc = vlocn*rhoocn
      fd = 0.94*rhoatm*cpatm
c

c     Thomson and Warren constants
c
      b00 = 2.43414e2
      b10 = -3.47968e1
      b20 = 1.02790e1
      b01 = 2.60065
      b11 = -1.62064
      b21 = 6.34856e-1
      b02 = 4.40272e-3
      b12 = -2.26092e-2
      b22 = 1.12265e-2
      b03 = -2.05237e-5
      b13 = -9.67e-5
      b23 = 5.62925e-5
c

      do j=2,jmtm1
        dswr = (1.0 - scatter(j))*solins(j)*coalbedo(j)
        do i=2,imtm1
c
c-----------------------------------------------------------------------
c         calculate saturation specific humidity at surface air temp
c-----------------------------------------------------------------------
c

          ssh(i,j) = fa*exp(17.67*at(i,j,2,1)/(at(i,j,2,1) + 243.5))


          rh = max(0.0, min(1.0, at(i,j,2,2)/(ssh(i,j) + epsln)))

c
c-----------------------------------------------------------------------
c         calculate outgoing longwave radiation
c-----------------------------------------------------------------------
c

          rhrh = rh*rh
          outlwr(i,j) = 1.0e3*(b00 + b10*rh + b20*rhrh
     &                + (b01 + b11*rh + b21*rhrh)*at(i,j,2,1)
     &                + (b02 + b12*rh + b22*rhrh)*at(i,j,2,1)**2
     &                + (b03 + b13*rh + b23*rhrh)*at(i,j,2,1)**3)


c
c-----------------------------------------------------------------------
c         set the incoming short wave
c-----------------------------------------------------------------------
c
          dnswr(i,j) = dswr
c
c-----------------------------------------------------------------------
c         calculations only for ocean points
c-----------------------------------------------------------------------
c
          if (kmt(i,j) .gt. 0) then
c
            ws = spd(i,j)

            dt = surf(i,j,1) - at(i,j,2,1)
            dalt = Dalton (dt, ws)
c
c-----------------------------------------------------------------------
c           calculate evaporation or sublimation (ensure it is positive)
c-----------------------------------------------------------------------
c
            evap(i,j) = max(0.0, fb*dalt*ws*(surf(i,j,2) - at(i,j,2,2)))
            upltnt(i,j) = fc*evap(i,j)
c
c-----------------------------------------------------------------------
c           calculate upward sensible heat flux
c-----------------------------------------------------------------------
c
            upsens(i,j) = fd*dalt*ws*(dt)
c
c-----------------------------------------------------------------------
c           calculate upward longwave re-radiation
c-----------------------------------------------------------------------
c

            uplwr(i,j) = esocn*(surf(i,j,1) + 273.15)**4
     &                 - esatm(j)*(at(i,j,2,1) + 273.15)**4

	  endif
c
        enddo
      enddo
c	
      return
      end


      subroutine precipitate
c
c=======================================================================
c     calculate precipitation explicitly and update humidity
c     based on code by a.fanning
c
c     Note: evaporation and precipitation are in cm/s
c           and humidities are in g/g
c
c     author:   m.eby   e-mail: eby@uvic.ca
c=======================================================================
c
c====================== include file "param.h" =========================
c
c     main parameter file which sets ocean characteristics:
c
c     "size.h" sets model size "imt", "jmt", and "km"
c
c====================== include file "size.h" ==========================
c                                                                       
c-----------------------------------------------------------------------
c     USER INPUT: 
c-----------------------------------------------------------------------
c
c     imt    = number of grid points in the longitudinal direction
c              (calculated points are from 2 through imt-1. End points
c               are boundaries)          
c
c     jmt    = number of grid points (latitude rows) in the latitudinal
c              direction (calculated points are from 2 through jmt-1.           
c              End points are boundaries)   
c                                
c     km     = number of grid points in the vertical direction          
c              (calculated points are from 1 through km)
c
c     nt     = number of tracers (temperature, salinity, ...)
c
c     mnisle = maximum number of islands (unconnected land masses)
c
c     maxipp = maximum number of all island perimeter points
c-----------------------------------------------------------------------
c                                                                       
      parameter (imt=  92, jmt=  61, km= 15)
      parameter (nt=2)
      parameter (nat=2)
      parameter (mnisle=50, maxipp=5000)
c

c






c
c-----------------------------------------------------------------------
c     END USER INPUT
c-----------------------------------------------------------------------
c                                                                       
c-----------------------------------------------------------------------
c     By default, the MW (memory window) is 2nd order except for the
c     following options which require a 4th order MW 
c
c     for 2nd order schemes, the minimum sized MW is 3 latitude rows
c     for 4th order schemes, the minimum sized MW is 4 latitude rows
c                            (5 if using coarse_grained_parallelism)
c-----------------------------------------------------------------------
c













c
c-----------------------------------------------------------------------
c     set MW (memory window) size "jmw" 
c-----------------------------------------------------------------------
c                                                                       

c
c     for UNI-TASKING: "jmw" is set to the minimum for each option class 
c     "jmw" may be increased up to "jmt" 
c

      parameter (jmw=jmt)


c
c-----------------------------------------------------------------------
c     set first and last calculated row within the MW. other rows
c     are used as buffers
c-----------------------------------------------------------------------
c
c     jsmw   = 1st calculated row within the MW     
c     jemw   = last calculated row within the MW
c
      parameter (jsmw=2, jemw=jmw-1)
c
c
c     jextra = extra buffer rows needed for coarse_grained_parallelism.
c              "jextra" rows are added to the top and bottom of the MW
c              so the MW size increases by 2*jextra       
c

          parameter (jextra = 0)




c
c     nvar   = number of prognostic variables
c     lseg   = maximum number of longitudinal stream function segments
c     nlatpr = maximum number of latitudes for matrix printouts
c              on diagnostic time steps
c     nhreg  = number of regions in the horizontal used for averaging
c              tracers.
c     nvreg  = number of regions in the vertical used for term balance
c              calculations. note "nvreg" isn`t used for tracer averages
c     numreg = total number of regions ( = product of nhreg & nvreg)
c              used for term balance calculations
c
      parameter (lseg=5, nlatpr=10)

      parameter (nhreg=5, nvreg=2, numreg=nhreg*nvreg)

      parameter (nvar=nt+2)
c

c
      parameter (imtm1=imt-1, kmm1=km-1)                                
      parameter (imtp1=imt+1, imtm2=imt-2
     &,          jmtp1=jmt+1, jmtm1=jmt-1, jmtm2=jmt-2

     &,          jscan=jmtm2

     &,          kmp1=km+1, kmp2=km+2
     &,          imtkm=imt*km, nwds=imt*jmt, nkflds=2
     &,          nslab=imt*nvar*km, ntmin2=nt+1/nt)
c
c     include parameter constants
c
c====================== include file "pconst.h" ========================
c
c
c     rules for parameter constants
c
c     use prefix of "c" for whole real numbers (eg: c57 for 57.0)
c     use "m" after prefix to designate negative values (minus sign)
c       (eg: cm7 for -7.0)
c     use prefix of "p" for non repeating fractions (eg: p5 for 0.5)
c     use prefix of "r" for reciprocals (eg: r3 for 1/3.0)
c     combine use of prefix above and "e" for scientific notation, with
c       (eg: c5e4 for 5.0e4, c1em10 for 1.0e-10)
c
      parameter (c0=0.0, c1=1.0, c2=2.0, c3=3.0, c4=4.0, c5=5.0, c7=7.0)
      parameter (c8=8.0)
      parameter (c14=14.0, c16=16.0, c360=360.0)
      parameter (p125=0.125, p25=0.25, p5=0.5, p75=0.75)
      parameter (epsln=1.0e-20)
c
      parameter (c24=24.0, c60=60.0, c1440=1440.0)
      parameter (r24=c1/c24, r60=c1/c60, r1440=c1/c1440)
      parameter (secday=c1/(c60*c1440))
c
c     include standard I/O units
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c
c     ncrows = number of calculated rows within the MW.
c              (the remaining rows are buffer rows). 
c


      parameter (ncrows = jmw - 2)


c====================== include file "cembm.h" =========================
c
c     parameters for use in the energy balance model (also see atm.h)
c
c     addflux		= logical flag for adding only even mode fluxes
c     nats		= number of atmospheric time steps since mixing
c     namix		= time steps between mixing (set in atmos.in)
c     lf		= time step flag (1=>leapfrog, 2=>forward)
c     pyear		= calendar year (set in atmos.in, -/+ = BC/AD)
c     dtatm 		= time step for atmosphere (set in atmos.in)
c     dts		= time step (2*dtatm=>leapfrog, dtatm=>forward)
c     co2ccn		= CO2 concentration
c     anthro		= radiative forcing by CO2
c     co2ccni		= initial CO2 concentration
c     co2yri		= last year of initial CO2 concentration
c     co2ccnf		= final CO2 concentration
c     co2yrf		= first year of final CO2 concentration
c     solarconst	= solar constant (g/s**3)
c     ssp		= sea surface pressure (g/cm/s**2)
c     cdatm 		= drag coefficient (dimensionless)
c     cpatm		= atmospheric heat capacity (cm**2/s**2/K)
c     ht		= scale height for temperature
c     hq		= scale height for specific humidity
c     rhoatm		= density of air at sea surface (g/cm**3)
c     rhoocn		= representative sea surface density
c     esocn		= ocean emissivity times Stefan's constant 
c     vlocn		= latent heat of vaporization of water
c     socn		= constant ocean salinity
c     cdice 		= drag coefficient (dimensionless)
c     rhoice		= ice density (g/cm**3)
c     esice		= ice emissivity times Stefan's constant 
c     slice		= latent heat of sublimation of ice
c     flice		= latent heat of fusion of ice (cm**2/s**2)
c     condice		= ice conductivity (g*cm/s**3/K)
c     kadv		= time step divider for ice advection
c     ntats		= time step counter for time averaging
c     avetime		= time for averaging fluxes
c     totaltime		= total time for long term averages
c
      logical addflux
c
      common /cembm/ addflux
      common /cembm/ nats, namix, lf, kadv, ntats
      common /cembm/ pyear, dtatm, dts, co2ccn, anthro, co2ccni, co2yri
     &,              co2ccnf, co2yrf, solarconst, ssp, cdatm, cpatm, ht
     &,              hq, rhoatm, rhoocn, esocn, vlocn, socn, cdice
     &,              rhoice, esice, slice, flice, condice, avetime 
     &,              totaltime
c
c====================== include file "atm.h" ===========================
c
c     arrays for the energy-moisture balance model
c
c     note: units for heat flux are in g/cm**2/s**3/cm**2 or (mW/m**2)
c           units for fresh water flux are in cm/s
c           downward is into the surface (ocean, ice or land)
c           upward is into the bottom of the atmosphere
c           outward is out of the top of the atmosphere
c           inward is into the top of the atmosphere
c
c     outlwr(imt,jmt)	 = outgoing atmosphere longwave flux
c     at(imt,jmt,2,nat)	 = tracers (previous and most recent)
c     surf(imt,jmt,nat)	 = surface values (1=temperature, 2=humidity)
c     flux(imt,jmt,nat)	 = downward flux (1=heat, 2=fresh water)
c     precip(imt,jmt)	 = precipitation
c     evap(imt,jmt)	 = evaporation
c     dnswr(imt,jmt)  	 = downward surface shortwave flux
c     uplwr(imt,jmt)  	 = upward surface longwave flux
c     upsens(imt,jmt)	 = upward surface sensible heat flux
c     upltnt(imt,jmt)    = upward surface latent heat flux
c     ssh(imt,jmt) 	 = saturation specific humidity
c     spd(imt,jmt) 	 = wind speed (cm/sec)
c     da(jmt,nat)	 = tracer diffusivity parameterization
c     coalbedo(jmt)	 = planetary coalbedo
c     solins(jmt)	 = solar insolation (units of solarconst)
c     esatm(jmt)	 = atmosphere emissivity times Stefan's constant
c     scatter(jmt)	 = solar scattering into atmosphere





c     cori(jmt,2)	 = Coriolis parameter

c
      real outlwr(imt,jmt), at(imt,jmt,3,nat), surf(imt,jmt,nat)
      real flux(imt,jmt,nat), precip(imt,jmt), evap(imt,jmt)
      real dnswr(imt,jmt), uplwr(imt,jmt), upsens(imt,jmt)
      real upltnt(imt,jmt), ssh(imt,jmt), spd(imt,jmt), da(jmt,nat)
      real coalbedo(jmt), solins(jmt), esatm(jmt), scatter(jmt)





      real cori(jmt,2)
c
      common /atm/ outlwr, at, surf, flux, precip, evap, dnswr, uplwr
     &,            upsens, upltnt, spd, ssh, da, coalbedo, solins
     &,            esatm, scatter





     &,            cori
c
c====================== include file "levind.h" ========================
c
c     vertical level indicators which define model geometry & bottom
c     topography:
c
c     kmt = number of vertical boxes over "t" points
c     kmu = number of vertical boxes over "u,v" points
c
      common /levind/ kmt(imt,jmt), kmu(imt,jmt)
c
c
c
c-----------------------------------------------------------------------
c     set appropriate constants
c-----------------------------------------------------------------------
c
      fa = rhoatm*hq/(rhoocn*dts)
c
      do j=2,jmtm1
        do i=2,imtm1
c

c-----------------------------------------------------------------------
c         no rivers, so precipitate only over ocean points
c-----------------------------------------------------------------------
c
          if (kmt(i,j) .gt. 0) then
c

c-----------------------------------------------------------------------
c         check if specific humidity is greater than saturation 
c-----------------------------------------------------------------------
c
          qmax = 0.85*ssh(i,j)
          if (at(i,j,2,2) .gt. qmax) then
            precip(i,j) = fa*(at(i,j,2,2) - qmax)
            at(i,j,2,2) = qmax
          else 
            precip(i,j) = 0.0
            if (at(i,j,2,2) .lt. 0.0) then
              at(i,j,2,2) = 0.0
              write(stdout,*) '=>Warning: negative q(i,j) at ', i, j
            endif
          endif

c
          endif
c
        enddo
      enddo

c	
      return
      end


      function Dalton (dt, ws)
c=======================================================================
c     calculate the Dalton number based on stability criterion
c     based on code by a.fanning
c
c     author:   m.eby   e-mail: eby@uvic.ca
c=======================================================================
c
      Dalton = 1.0022e-3 + 8.22e-5*(dt) + 2.66e-6*ws
      Dalton =  max(Dalton, 6.0e-05)     
      Dalton =  min(Dalton, 2.190e-03)
c
c	
      return
      end
      subroutine gasbc (ncall)


c
c=======================================================================
c     calculate boundary conditions for the atmospheric model
c
c     inputs:
c     ncall = number of times this routine was called
c
c     author:      m.eby                 e-mail=> eby@uvic.ca
c=======================================================================
c
c====================== include file "param.h" =========================
c
c     main parameter file which sets ocean characteristics:
c
c     "size.h" sets model size "imt", "jmt", and "km"
c
c====================== include file "size.h" ==========================
c                                                                       
c-----------------------------------------------------------------------
c     USER INPUT: 
c-----------------------------------------------------------------------
c
c     imt    = number of grid points in the longitudinal direction
c              (calculated points are from 2 through imt-1. End points
c               are boundaries)          
c
c     jmt    = number of grid points (latitude rows) in the latitudinal
c              direction (calculated points are from 2 through jmt-1.           
c              End points are boundaries)   
c                                
c     km     = number of grid points in the vertical direction          
c              (calculated points are from 1 through km)
c
c     nt     = number of tracers (temperature, salinity, ...)
c
c     mnisle = maximum number of islands (unconnected land masses)
c
c     maxipp = maximum number of all island perimeter points
c-----------------------------------------------------------------------
c                                                                       
      parameter (imt=  92, jmt=  61, km= 15)
      parameter (nt=2)
      parameter (nat=2)
      parameter (mnisle=50, maxipp=5000)
c

c






c
c-----------------------------------------------------------------------
c     END USER INPUT
c-----------------------------------------------------------------------
c                                                                       
c-----------------------------------------------------------------------
c     By default, the MW (memory window) is 2nd order except for the
c     following options which require a 4th order MW 
c
c     for 2nd order schemes, the minimum sized MW is 3 latitude rows
c     for 4th order schemes, the minimum sized MW is 4 latitude rows
c                            (5 if using coarse_grained_parallelism)
c-----------------------------------------------------------------------
c













c
c-----------------------------------------------------------------------
c     set MW (memory window) size "jmw" 
c-----------------------------------------------------------------------
c                                                                       

c
c     for UNI-TASKING: "jmw" is set to the minimum for each option class 
c     "jmw" may be increased up to "jmt" 
c

      parameter (jmw=jmt)


c
c-----------------------------------------------------------------------
c     set first and last calculated row within the MW. other rows
c     are used as buffers
c-----------------------------------------------------------------------
c
c     jsmw   = 1st calculated row within the MW     
c     jemw   = last calculated row within the MW
c
      parameter (jsmw=2, jemw=jmw-1)
c
c
c     jextra = extra buffer rows needed for coarse_grained_parallelism.
c              "jextra" rows are added to the top and bottom of the MW
c              so the MW size increases by 2*jextra       
c

          parameter (jextra = 0)




c
c     nvar   = number of prognostic variables
c     lseg   = maximum number of longitudinal stream function segments
c     nlatpr = maximum number of latitudes for matrix printouts
c              on diagnostic time steps
c     nhreg  = number of regions in the horizontal used for averaging
c              tracers.
c     nvreg  = number of regions in the vertical used for term balance
c              calculations. note "nvreg" isn`t used for tracer averages
c     numreg = total number of regions ( = product of nhreg & nvreg)
c              used for term balance calculations
c
      parameter (lseg=5, nlatpr=10)

      parameter (nhreg=5, nvreg=2, numreg=nhreg*nvreg)

      parameter (nvar=nt+2)
c

c
      parameter (imtm1=imt-1, kmm1=km-1)                                
      parameter (imtp1=imt+1, imtm2=imt-2
     &,          jmtp1=jmt+1, jmtm1=jmt-1, jmtm2=jmt-2

     &,          jscan=jmtm2

     &,          kmp1=km+1, kmp2=km+2
     &,          imtkm=imt*km, nwds=imt*jmt, nkflds=2
     &,          nslab=imt*nvar*km, ntmin2=nt+1/nt)
c
c     include parameter constants
c
c====================== include file "pconst.h" ========================
c
c
c     rules for parameter constants
c
c     use prefix of "c" for whole real numbers (eg: c57 for 57.0)
c     use "m" after prefix to designate negative values (minus sign)
c       (eg: cm7 for -7.0)
c     use prefix of "p" for non repeating fractions (eg: p5 for 0.5)
c     use prefix of "r" for reciprocals (eg: r3 for 1/3.0)
c     combine use of prefix above and "e" for scientific notation, with
c       (eg: c5e4 for 5.0e4, c1em10 for 1.0e-10)
c
      parameter (c0=0.0, c1=1.0, c2=2.0, c3=3.0, c4=4.0, c5=5.0, c7=7.0)
      parameter (c8=8.0)
      parameter (c14=14.0, c16=16.0, c360=360.0)
      parameter (p125=0.125, p25=0.25, p5=0.5, p75=0.75)
      parameter (epsln=1.0e-20)
c
      parameter (c24=24.0, c60=60.0, c1440=1440.0)
      parameter (r24=c1/c24, r60=c1/c60, r1440=c1/c1440)
      parameter (secday=c1/(c60*c1440))
c
c     include standard I/O units
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c
c     ncrows = number of calculated rows within the MW.
c              (the remaining rows are buffer rows). 
c


      parameter (ncrows = jmw - 2)


c====================== include file "coord.h" =========================
c
c                    model grid point coordinates
c
c     grid definition:
c
c     the model uses a staggard arakawa "b" grid which is setup and 
c     generated by the "grids.F" module. 
c
c     xt(i)   = longitude of the ith "t" point in degrees.   i=1..imt
c     xu(i)   = longitude of the ith "u,v" point in degrees. i=1..imt
c     yt(j)   = latitude of the jth "t" point in degrees.    j=1..jmt
c     yu(j)   = latitude of the jth "u,v" point in degrees.  j=1..jmt
c     zt(k)   = distance from surface down to center of level k (in cm)
c               (for depth of "t" and "u,v" grid points: k=1,km)
c     zw(k)   = distance from surface down to bottom of level k (in cm)
c               (for depth of "t" and "u,v" grid points: k=1,km)
c     dxtdeg  = widths for "t" grid cells (degrees)
c     dytdeg  = heights for "t" grid cells (degrees)
c     dxudeg  = widths for "u" grid cells (degrees)
c     dyudeg  = heights for "u" grid cells (degrees)
c     dzt(k)  = vertical resolution of "t" and "u" grid cells (in cm)
c     dzw(k)  = vertical resolution of "w" grid cells (in cm)
c
c     "i" increases in an eastward direction, "j" increases in a
c     northward direction, and "k" increases downward.
c     
      common /coord/ xt(imt), yt(jmt), xu(imt), yu(jmt), zw(km), zt(km)
      common /coord/ dxtdeg(imt), dytdeg(jmt), dzt(km)
      common /coord/ dxudeg(imt), dyudeg(jmt), dzw(0:km)
c
c====================== include file "csbc.h" ==========================
c
c                    surface boundary conditions (S.B.C.)
c
c
c     numosbc = number of ocean S.B.C..
c
c     numasbc = number of atmospheric S.B.C..
c
c     maxsbc  = maximum number of allowable S.B.C. fields.
c
c     numsbc  = total number of S.B.C. this is the sum of the 
c               atmosphere S.B.C. and ocean S.B.C. fields. it must
c               be less than or equal to "maxsbc".
c
c     sbcocn  = S.B.C. fields on the ocean grid.
c               n=1..numosbc are for the incoming ocean S.B.C.
c               n=numosbc+1..numosbc+numasbc are for the outgoing S.B.C.
c

c
c     ntspos  = number of time steps per ocean segment
c
c     sbcname  = S.B.C. character string names (eg: "SST", "taux", etc)
c               note that these character strings should be changed with
c               care since they are used to identify fields for special
c               treatment
c
c     dunits  = dimensional units for S.B.C. (eg: "deg C")
c
c     mapsbc  = indices for relating how S.B.C. fields are stored
c               within arrays "sbcocn" and "sbcatm"  
c               eg: m = mapsbc(n) where sbcocn(,,m) is S.B.C. "n"
c
c     restrictions on re-arranging S.B.C. fields and "mapsbc":
c
c     1) all ocean S.B.C. (taux, tauy, etc) should be grouped together. 
c        relative ordering within the group is unimportant but the
c        group must preceed the atmos S.B.C. group.
c
c     2) all atmos S.B.C. (sst, ...) should also be grouped together.
c        relative ordering within the group is unimportant.
c
c     the default arrangement is defined as:
c
c             (these five ocean S.B.C. come from the atmos )
c     mapsbc(1) references taux
c     mapsbc(2) references tauy
c     mapsbc(3) references heat flux
c     mapsbc(4) references salt flux
c      if the atmos supplied fresh water flux then it
c      would have to be converted to ...
c      salt flux  = -(P-E+R) * rho * Sref
c      where...
c      P-E+R represents a precipitation minus evaporation
c            plus runoff rate in cm of water/sec
c      rho is the density if water taken to be 1 g/cm**3, and
c      Sref is a reference salinity in units of grams of salt per
c            gram of water (in units of "parts per part" such
c            as 0.035 ... not "parts per thousand")
c      Depending upon the application of interest, users may wish
c      to set Sref to either be a constant over the entire model
c      domain or for it to be the locally predicted salinity of
c      the uppermost model level (S(1)).  If one desires to ensure
c      that a global average P-E+R flux of zero translates to zero
c      trend in the salt content of the ocean, then a constant Sref
c      is needed.      
c     mapsbc(5) references short wave
c
c             (these four atmos S.B.C. come from the ocean)
c     mapsbc(6) references SST
c     mapsbc(7) references SSS
c     mapsbc(8) references surface u
c     mapsbc(9) references surface v
c
c
c     when re-ordering S.B.C., search for "mapsbc"  
c     (eg: grep mapsbc *.F) to insure the new indexing is consistant
c     with the re-ordering. also make changes in "sbcname", "dunits", 
c     "coabc", and "crits" to maintain consistancy.
c
c     example 1: suppose you want only the first six S.B.C...
c                in "csbc.h", set  numosbc=5, numasbc=1
c                this reduces memory requirements.
c                no other changes are necessary
c
c     example 2: suppose you want to remove the short wave boundary
c                condition (to save more memory) from example 1 . 
c                a) in "csbc.h", set numosbc=4, numasbc=1
c                b) grep "mapsbc(5)" *.F to find and remove references
c                c) grep "mapsbc(6)" *.F to change references to 
c                                        mapsbc(5)
c
c     
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c
c
      logical asegs, asege, afirst, alast
      character*10 sbcname
      character*15 dunits
c
      parameter (numosbc=5
     &,          numasbc=4
     &,          maxsbc=numosbc+numasbc, numsbc=maxsbc)
c
      common /csbc/ sbcocn(imt,jmt,numsbc) 
      common /csbc/ dampts(nt), dampdz(nt)
      common /csbc/ coabc(maxsbc), crits(maxsbc)
      common /csbc1/ mapsbc(maxsbc), numpas, iombc, ntspos, ntspas
      common /csbc2/ sbcname(maxsbc), dunits(maxsbc)
      common /csbc3/ asegs, asege, afirst, alast 
c
c====================== include file "levind.h" ========================
c
c     vertical level indicators which define model geometry & bottom
c     topography:
c
c     kmt = number of vertical boxes over "t" points
c     kmu = number of vertical boxes over "u,v" points
c
      common /levind/ kmt(imt,jmt), kmu(imt,jmt)
c
c====================== include file "mapsbc.h" ========================
c
c     indicies for surface boundary condition arrays.  names must be
c     unique and are set at the begining of "driver"
c
c     itaux is the x component of wind stress
c     itauy is the y component of wind stress
c     ihflx is heat flux
c     ipme is for precipitation minus evaporation
c     ipsw is for penitrating shortwave (into ocean first layer)
c     isst is the ocean model SST
c     isss is the ocean model SSS
c     isu is the x component of the ocean model first layer velocity
c     isv is the y component of the ocean model first layer velocity
c     it10 is the 10 metre atmopheric temperature
c     iq10 is the 10 metre atmopheric humidity
c     ilwr is incoming longwave radiation
c     iswr is incoming shortwave radiation
c     igu is the x component of the ocean model second layer velocity
c     igv is the y component of the ocean model second layer velocity
c
      common /mapsbc/ itaux, itauy, ihflx, ipme, ipsw, isst, isss
     &,               isu, isv, it10, iq10, ilwr, iswr, igu, igv
c
c====================== include file "scalar.h" ========================
c
c     various scalar quantities:
c
c     dtts   = time step for density & tracers (in seconds)
c     dtuv   = time step for baroclinic velocity (in seconds)
c     dtsf   = time step for barotropic velocity (in seconds)
c     c2dtts = 2*dtts
c     c2dtuv = 2*dtuv
c     c2dtsf = 2*dtsf
c     acor   = (>0, 0) = (implicit, explicit) treatment of coriolis
c               term for internal and external modes.
c     rho0   = mean density for Bousinessq approximation
c     rho0r  = 1/rho0 
c     omega  = earth`s rotation rate (radians/sec)
c     radius = earth`s radius (cm)
c     grav   = earth`s gravitational acceleration (cm/sec**2)
c     cdbot  = bottom drag coefficient
c     ncon   = number of  passes through convective code in tracer
c     gcor   = time centering for coriolis term
c
c     taux0  = constant zonal windstress (dynes/cm**2) for idealized
c              equatorial studies
c     tauy0  = constant meridional windstress (dynes/cm**2) for
c              idealized equatorial studies
c
      common /scalar/ dtts, dtuv, dtsf, c2dtts, c2dtuv, c2dtsf, acor
      common /scalar/ rho0, rho0r, omega, radius, grav, cdbot, gcor
      common /scalar/ taux0, tauy0
      common /scalri/ ncon
c
c     bring in non dimensional constants
c
c====================== include file "ndcon.h" ========================
c
c     various non dimensional quantities:
c
c     radian = degrees per radian
c     pi     = something good to eat
c
      common /ndcon/ radian, pi
c
c
c====================== include file "switch.h" ========================
c
c     all time dependent decisions are made by time manager "tmngr.F"
c     and communicated elsewhere to the model via logical switches.
c
c     inputs: (defaulted in "blkdta.F", optionally reset via namelist)
c
c
c     runlen  = integration period (see rununits). note "runlen" should
c               be an integral number of density time steps. if not,
c               then "runlen" is automatically adjusted to insure this.
c               fractional days are supported but not fractional months
c               or years.
c     rununits= units of "runlen". may be "days", "months", or "years".
c               tmngr will convert "runlen" which is in "rununits"
c               to "rundays" in units of days.
c
c     segtim  = the integration time "runlen" is broken into a number of
c               segments each of length "segtim" days. updated surface
c               boundary conditions are applied to MOM every "segtim" 
c               days. this is useful when coupling to atmospheric models
c               in which case both models exchange surface boundary
c               conditions every "segtim" days where "segtim"
c               is 1/(coupling frequency). without an atmospheric model,
c               when getting surface boundary conditions from data, 
c               "segtim" is set to the time step (in days) by mom.F. in
c               either case, "runlen" (in days) should be an integral
c               number of "segtim".     
c
c     nmix    = number of time steps between mixing timesteps. used
c               to damp timestep splitting due to centered leapfrog.
c
c     init    = (true,false)  indicates that this run is a
c               (start from initial conditions, restart)
c
c     restrt  = (true,false) = (do,don`t) write a restart at the end
c               of the run
c
c     eb      = (true,false) configures for the use of a 
c               (euler backward,forward) type mixing timestep
c
c-----------------------------------------------------------------------
c     inputs to tmngr.F: diagnostic intervals
c-----------------------------------------------------------------------
c
c     note: switches are used to control the interval between doing
c           diagnostics. units for all switches are in days. 
c           setting a switch < 0.0 disables whatever the switch is 
c           controlling. setting it = 0.0 causes the diagnostic to be 
c           done every time step, and setting it > 0.0 causes the 
c           diagnostic to be done repeatedly on the specified interval. 
c
c     cmixint = number of days between writing estimated mixing coeffs
c               on faces of T cells and U cells
c
c     crossint = number of days between writing diapycnal and isopycnal
c               components of flow
c
c     fctint = number of days between writing difference between 
c              FCT and leapfrog advection
c
c     densityint = number of days between writing density
c
c     exconvint = number of days between writing temperature rate of
c                 change due to explicit convection
c
c     glenint =  number of days between global energetics integrals.
c
c     trmbint =  number of days between momentum and tracer term
c                balances (global and regional).
c
c     itrmb   = (true,false) = (do,don`t) write regional mask info for
c               the term balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     gyreint =  number of days between calculation of tracer northward
c                transport.
c     igyre   = (true,false) = (do,don`t) write regional mask info for
c               the gyre diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     vmsfint =  number of days between calculation of vertical and
c                meridional stream function.
c
c     tyzint  =  number of days between calculation of zonally averaged
c                tracer components.
c
c     prxzint =  number of days between printouts of x-z data.
c
c     extint  =  number of days between printouts of external mode.
c
c     dspint  =  number of days between surface pressure calculation.
c                Note: only when "diagnostic_surface_height" is enabled.
c     dspper  = averaging period for "diagnostic_surface_height"
c
c     tavgint = number of days between regional tracer averages (under
c               horizontal regions).
c
c     itavg   = (true,false) = (do,don`t) write regional mask info for
c               the tracer average diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     tmbint  = number of days over which tracer equation in averaged
c               in depth and longitude to determine the meridional 
c               balance among storage, divergence, dissipation and 
c               forcing.
c     tmbper  = averaging period for "meridional_tracer_balance"
c
c     itmb    = (true,false) = (do,don`t) write "msktmb" for tracer
c               the meridional balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c
c     tsiint  = number of days between printing of time step integrals.
c
c     stabint = number of days between sampling for various stability
c               criteria.
c
c     snapint = number of days between writing instantaneous samples
c               of data from the MOM grid. note: only when "snapshots"
c               is enabled. see "iounit.h" for more details.
c               all data is at time level "tau" so it is one time step
c               before the date shown in "stamp".
c
c     timavgint= interval (days) for writing time mean data from
c               the "averaging" grid (only when "time_averages" is
c               enabled). if "timavgint" is not an integral number of
c               density time steps,"timavgint" is automatically adjusted
c               to insure this. if the number of days to integrate is
c               not an integral number of "timavgint" then the last
c               averaging period will be less than "timavgint" days.this 
c               may lead to one more averaging period than expected. 
c               see "iounit.h" for more details.
c     timavgper= averaging period for "time_averages"
c
c     xbtint  = averaging period (days) for writing XBT data (only when
c               "xbts" is enabled). if "xbtint" is not an integral
c               number of density time steps, "xbtint" is automatically
c               adjusted to insure this. if the number of days to 
c               integrate is not an integral number of "xbtint" then the
c               last averaging period will be less than "xbtint" days.
c               this may lead to one more averaging period than  
c               expected. see "iounit.h" for more details.
c     xbtper  = averaging period for "xbts"
c
c     zmbcint = number of days between calculation of zonal mean
c               surface boundary conditions (and related  quantities)
c
c     trajint = number of days between writing particle trajectories.
c               particle trajectories are always written on the last
c               time step of the run to allow for restarting.
c
c-----------------------------------------------------------------------
c     outputs from tmngr.F: logical switches
c-----------------------------------------------------------------------
c
c     rundays = integration time in days (from "runlen")
c
c     the following are logical counterparts to the above switches are 
c     set within "tmngr" every time step. logical switches control all
c     decisions about when to do things in MOM.
c
c     cmixts  = (false,true) = (don`t, do) do write estimated mixing
c               coefficients on this time step.
c               based on "cmixint".
c
c     crossts  = (false,true) = (don`t, do) write diapycnal and 
c               isopycnal components of flow on this time step.
c               based on "crossint".
c
c     fctts    = (false,true) = (don`t, do) write difference between 
c               FCT and leapfrog advection on this time step.
c               based on "fctint".
c
c     densityts  = (false,true) = (don`t, do) write density on this time
c               step. based on "densityint".
c               
c
c     exconvts  = (false,true) = (don`t, do) do write temperature change
c               due to explicit convection on this time step.
c               based on "exconvint".
c
c     glents  = (false,true) = (don`t, do) do calculation of global
c               energy integrals on this time step. based on "glenint".
c
c     trmbts  = (false,true) = (don`t, do) do calculation of momentum &
c               tracer term balance on this timestep. based on "trmbint"
c
c     gyrets  = (false,true) = (don`t, do) do calculation of tracer
c               northward transport on this timestep. based on "gyreint"
c
c     vmsfts  = (false,true) = (don`t, do) do calculation of vertical
c               and meridional stream function on this time step.
c               based on "vmsfint"
c
c     tyzts   = (false,true) = (don`t, do) do calculation of zonally
c               averaged tracer components on this time step.
c               based on "tyzint"
c
c     prxzts  = (false,true) = (don`t, do) do printouts of x-z data
c               on this time step. based on "prxzint"
c
c     extts  = (false,true) = (don`t, do) do printout of external mode
c               on this time step. based on "extint"
c
c     dspts  = (false,true) = (don`t, do) do calculation of diagnostic 
c              surface pressure on this time step. based on "dspint"
c               
c
c     stabts  = (false,true) = (don`t, do) test for stability on this
c               time step. based on "stabint"
c
c     tavgts  = (false,true) = (don`t do) do tracer averages on this
c               time step. based on "tavgint"
c
c     tmbts   = (false,true) = (don`t, do) write out tracer meridional .
c               balance on this time step. based on "tmbint"
c
c     tsits   = (false,true) = (don`t, do) print time step integrals
c               on this time step. based on "tsiint"
c
c     zmbcts  = (false,true) = (don`t, do) print zonal mean boundary
c               conditions on this time step.  based on "zmbcint"
c
c     trajts  = (false,true) = (don`t, do) print particle trajectories
c               on this time step. based on "trajint"
c
c     snapts  = (false,true) = (don`t, do) save a snapshot of the data
c               on this time step. based on "snapint"
c
c     timats  = (false,true) = (don`t, do) write time mean data
c               on this time step. based on "timavgint"
c                                          
c     xbtts   = (false,true) = (don`t, do) write averaged XBT data on
c               this time step based on "xbtint"
c
c
c     leapfrog= (false,true) on a (mixing, normal leapfrog) time step
c                based on "nmix"
c                                          
c     euler1  = true on the 1st pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     euler2  = true on the 2nd pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     forward = true on a forward time step. otherwise false
c		(applies when "eb" = false)		  
c                                          
c
c     the following logical switches are based on the model time step. 
c    
c     first   = (true,false) =  when it`s (the first, not the first)
c                               time step of a run
c     eots    = end of a time step. always true except for first
c               pass of an euler backward time step
c     eorun   = last time step of a run. always false except during the
c               last time step of the run.
c
c     eoday   = true when within 1/2 time step of the end of a day
c               else ... false
c     eoweek  = true when within 1/2 time step of the end of a 7 day
c               week (referenced to the start of a year) else ...false
c     eo2wks  = true when within 1/2 time step of the end of two weeks
c               (referenced to the start of a year) else ... false
c     midmon  = true when within 1/2 time step of the middle of a month
c               else ... false
c     eomon   = true when within 1/2 time step of the end of a month
c               else ... false
c     eoyear  = true when within 1/2 time step of the end of a year
c               else ... false
c     osegs   = true on the 1st time step of an ocean segment in mom.F
c               otherwise false.
c     osege  =  true on the last time step of an ocean segment in mom.F
c               otherwise false.
c
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c
c
      logical eb, leapfrog, euler1, euler2, forward, eots
      logical init, first, restrt
      logical itavg, itmb, itrmb, igyre
      character *8 rununits
c
      common /switcc/ rununits
      common /switcr/ runlen, rundays
      common /switci/ nmix
      common /switcl/ eb, leapfrog, euler1, euler2, forward, eots
      common /switcl/ init, first, restrt
      common /switcl/ itavg, itmb, itrmb, igyre
c
      logical          eoday, eoweek, eo2wks
      common /switci/ ieoday,ieoweek,ieo2wks
      common /switcl/  eoday, eoweek, eo2wks
c
      logical          eomon, midmon, eoyear, eorun
      common /switci/ ieomon,imidmon,ieoyear,ieorun
      common /switcl/  eomon, midmon, eoyear, eorun
c
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c     each interval switch needs three variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output (e.g,.  glenint)
c         2) a switch (logical) for the interval (e.g.,  glents )
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c         3) an index (integer)                       (e.g., iglenint)
c
c     the user must specify the interval [e.g., glenint] for diagnostic
c     output in units of days. tmngr sets the corresponding logical  
c     switch [e.g., glents] every time step. It is set to true when  
c     within half a time step of the requested interval, otherwise it is
c     false. All decisions relating to the interval [e.g., glenint]
c     are based on the logical switch [e.g., glents].
c           
c     internal time structures
c
c     The switch index [e.g., iglenint] is used to subsrcipt into  
c     internal arrays maintained by tmngr.F. The switch index is
c     allocated on the first call to function "alarm".
c     The array entry [e.g., iinterval(iglenint)] is a time index to the
c     internal representation of the interval [e.g., glenint].
c     The array entry [e.g., ialarm(iglenint)] is a time index to the
c     next time the alarm will be true.
c-----------------------------------------------------------------------
c
      logical           tavgts,    glents,    trmbts,   prxzts
      common /switcr/   tavgint,   glenint,   trmbint,  prxzint
      common /switci/  itavgint,  iglenint,  itrmbint, iprxzint
      common /switcl/   tavgts,    glents,    trmbts,   prxzts
c
      logical          extts,   trajts,   exconvts,   cmixts
      common /switcr/  extint,  trajint,  exconvint,  cmixint
      common /switci/ iextint, itrajint, iexconvint, icmixint
      common /switcl/  extts,   trajts,   exconvts,   cmixts
c
      logical          vmsfts,   gyrets,    tsits,   snapts,   fctts
      common /switcr/  vmsfint,  gyreint,   tsiint,  snapint,  fctint
      common /switci/ ivmsfint, igyreint,  itsiint, isnapint, ifctint
      common /switcl/  vmsfts,   gyrets,    tsits,   snapts,   fctts
c
      logical          tyzts
      common /switcr/  tyzint
      common /switci/ ityzint
      common /switcl/  tyzts
c
      logical          stabts,   zmbcts,   crossts,   densityts
      common /switcr/  stabint,  zmbcint,  crossint,  densityint
      common /switci/ istabint, izmbcint, icrossint, idensityint
      common /switcl/  stabts,   zmbcts,   crossts,   densityts
c
      logical          osegs,  osege
      common /switcr/          segtim
      common /switci/ iosegs, iosege
      common /switcl/  osegs,  osege
c   
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c              A N D   A V E R A G I N G   P E R I O D
c
c     each averaging period switch needs five variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output    (e.g. xbtint  )   
c         2) a switch (logical) for the interval         (e.g. xbtts   )
c         3) an averaging period (real)                  (e.g. xbtper  )   
c         4) a switch (logical) for accumulating         (e.g. xbtperts)
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switches
c
c         5) an index (integer)                         (e.g. ixbtint  )
c
c     The user must specify the interval [e.g., xbtint] for diagnostic
c     output in units of days and the averaging period [e.g., xbtper] 
c     in units of days. The averaging period may be less than or equal
c     to the interval. For example, if the interval is 30.0 days and the
c     averaging period is 5.0 days, results will be averaged over all
c     time steps within days 26, 27, 28, 29, and 30.  An averaging period
c     of 0.0 days averages over the last time step of the interval (as
c     does xbtper = dt), and an averaging period less than zero turns
c     the switches off for all time steps.  
c
c     The logical switch for writing output at the specified interval 
c     [e.g., xbtts] is set to true on the last time step of the 
c     averaging period. The logical switch for accumulating results
c     [e.g., xbtperts] is true for all time steps within the averaging
c     period, otherwise it is false. 
c
c     internal time structures
c
c     The index [e.g., ixbtint] is allocated on the first call to 
c     function "avg_alarm". The array element iperiod(ixbtint) is an
c     index to the time structure for the internal representation of 
c     "xbtper", and ilastsw(ixbtint) is the index of the switch that 
c     flags the last time step of the accumulation period.
c     Depending on use,  ilastsw(ixbtint) may either be the index
c     of another "named" switch or the index of a new switch
c     allocated on the first time step.
c     In the latter case, iinterval(ilastsw(ixbtint)) is the index of
c     the time structure where "xbtint" is stored in internal form,
c     and ialarm(ilastsw(ixbtint)) is the index of the time when an
c     accumulation period will next end.
c     The variable nextts(ixbtint) is true whenever the next
c     time step will begin the accumulation period.
c
c-----------------------------------------------------------------------
c
      logical         xbtts,     dspts,    tmbts,    timavgts
      logical         xbtperts,  dspperts, tmbperts, timavgperts
      common /switcr/ xbtint,    dspint,   tmbint,   timavgint
      common /switcr/ xbtper,    dspper,   tmbper,   timavgper
      common /switci/ixbtint,   idspint,  itmbint,  itimavgint
      common /switcl/ xbtts,     dspts,    tmbts,    timavgts
      common /switcl/ xbtperts,  dspperts, tmbperts, timavgperts
c
c-----------------------------------------------------------------------
c
c                 S W I T C H E S    B A S E D    O N    
c
c         C A L E N D A R   O R    P R E V I O U S    S W I T C H   
c
c               A N D   A V E R A G I N G    P E R I O D
c
c    
c
c     the following logical switches are based on any calendar or 
c     interval switch and an averaging period (in days). The  averaging
c     period must be less than or equal to the interval. The last
c     time step of the averaging period is at the end of the interval.
c     If the averaging period is set to zero, the averaging period
c     consists only of the last time period of the interval.  If
c     the averaging period is less than zero, these switches are always
c     false.
c
c     each averaging period switch needs four variables in common. For
c     example, if the averaging period is before the end of each month
c     then the calendar switch (eomon), and index (ieomon) are presumed
c     to exist in common and need not be added.
c     
c     Additionally, four items are needed.
c
c       1) an averaging period (real)                  (e.g.  testper  )   
c       2) a switch (logical) for accumulating results (e.g.  testperts)
c       3) a switch (logical) for the end of interval  (e.g.  testts   )
c
c     the fourth is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c       4) an index (integer)                          (e.g.  itestper )
c
c     Suppose it is required to produce averages over all time steps
c     during the last 5 days of each month. Then "testper" = 5.0 and 
c     the following will calculate the accumulating switch.
c
c      testts = avg_alarm(itestper, ihalfstep, 0, testper, iref, ieomon)
c      testperts = on(itestper)
c
c     Note the use of "ieomon" to key off the months.  The switch
c     "testts" will be true whenever "eomon" is true.
c     Also note that when an averaging switch is keyed off another
c     switch, the switch inverval argument is not used, but is 
c     retained for consistency with the form of other averaging
c     switches.
c-----------------------------------------------------------------------
c
      logical           testperts
      logical           testts
      common /switcr/   testint
      common /switcr/   testper
      common /switci/  itestper
      common /switcl/   testts
      common /switcl/   testperts

c
      parameter (maxsw=100)
      logical          on, lastts, nextts
      common /switci/  nsw  
      common /switci/  ialarm(maxsw), iinterval(maxsw), iperiod(maxsw)
     &,                ilastsw(maxsw)
      common /switcl/  on(maxsw), lastts(maxsw), nextts(maxsw)
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c

c====================== include file "cembm.h" =========================
c
c     parameters for use in the energy balance model (also see atm.h)
c
c     addflux		= logical flag for adding only even mode fluxes
c     nats		= number of atmospheric time steps since mixing
c     namix		= time steps between mixing (set in atmos.in)
c     lf		= time step flag (1=>leapfrog, 2=>forward)
c     pyear		= calendar year (set in atmos.in, -/+ = BC/AD)
c     dtatm 		= time step for atmosphere (set in atmos.in)
c     dts		= time step (2*dtatm=>leapfrog, dtatm=>forward)
c     co2ccn		= CO2 concentration
c     anthro		= radiative forcing by CO2
c     co2ccni		= initial CO2 concentration
c     co2yri		= last year of initial CO2 concentration
c     co2ccnf		= final CO2 concentration
c     co2yrf		= first year of final CO2 concentration
c     solarconst	= solar constant (g/s**3)
c     ssp		= sea surface pressure (g/cm/s**2)
c     cdatm 		= drag coefficient (dimensionless)
c     cpatm		= atmospheric heat capacity (cm**2/s**2/K)
c     ht		= scale height for temperature
c     hq		= scale height for specific humidity
c     rhoatm		= density of air at sea surface (g/cm**3)
c     rhoocn		= representative sea surface density
c     esocn		= ocean emissivity times Stefan's constant 
c     vlocn		= latent heat of vaporization of water
c     socn		= constant ocean salinity
c     cdice 		= drag coefficient (dimensionless)
c     rhoice		= ice density (g/cm**3)
c     esice		= ice emissivity times Stefan's constant 
c     slice		= latent heat of sublimation of ice
c     flice		= latent heat of fusion of ice (cm**2/s**2)
c     condice		= ice conductivity (g*cm/s**3/K)
c     kadv		= time step divider for ice advection
c     ntats		= time step counter for time averaging
c     avetime		= time for averaging fluxes
c     totaltime		= total time for long term averages
c
      logical addflux
c
      common /cembm/ addflux
      common /cembm/ nats, namix, lf, kadv, ntats
      common /cembm/ pyear, dtatm, dts, co2ccn, anthro, co2ccni, co2yri
     &,              co2ccnf, co2yrf, solarconst, ssp, cdatm, cpatm, ht
     &,              hq, rhoatm, rhoocn, esocn, vlocn, socn, cdice
     &,              rhoice, esice, slice, flice, condice, avetime 
     &,              totaltime
c
c====================== include file "atm.h" ===========================
c
c     arrays for the energy-moisture balance model
c
c     note: units for heat flux are in g/cm**2/s**3/cm**2 or (mW/m**2)
c           units for fresh water flux are in cm/s
c           downward is into the surface (ocean, ice or land)
c           upward is into the bottom of the atmosphere
c           outward is out of the top of the atmosphere
c           inward is into the top of the atmosphere
c
c     outlwr(imt,jmt)	 = outgoing atmosphere longwave flux
c     at(imt,jmt,2,nat)	 = tracers (previous and most recent)
c     surf(imt,jmt,nat)	 = surface values (1=temperature, 2=humidity)
c     flux(imt,jmt,nat)	 = downward flux (1=heat, 2=fresh water)
c     precip(imt,jmt)	 = precipitation
c     evap(imt,jmt)	 = evaporation
c     dnswr(imt,jmt)  	 = downward surface shortwave flux
c     uplwr(imt,jmt)  	 = upward surface longwave flux
c     upsens(imt,jmt)	 = upward surface sensible heat flux
c     upltnt(imt,jmt)    = upward surface latent heat flux
c     ssh(imt,jmt) 	 = saturation specific humidity
c     spd(imt,jmt) 	 = wind speed (cm/sec)
c     da(jmt,nat)	 = tracer diffusivity parameterization
c     coalbedo(jmt)	 = planetary coalbedo
c     solins(jmt)	 = solar insolation (units of solarconst)
c     esatm(jmt)	 = atmosphere emissivity times Stefan's constant
c     scatter(jmt)	 = solar scattering into atmosphere





c     cori(jmt,2)	 = Coriolis parameter

c
      real outlwr(imt,jmt), at(imt,jmt,3,nat), surf(imt,jmt,nat)
      real flux(imt,jmt,nat), precip(imt,jmt), evap(imt,jmt)
      real dnswr(imt,jmt), uplwr(imt,jmt), upsens(imt,jmt)
      real upltnt(imt,jmt), ssh(imt,jmt), spd(imt,jmt), da(jmt,nat)
      real coalbedo(jmt), solins(jmt), esatm(jmt), scatter(jmt)





      real cori(jmt,2)
c
      common /atm/ outlwr, at, surf, flux, precip, evap, dnswr, uplwr
     &,            upsens, upltnt, spd, ssh, da, coalbedo, solins
     &,            esatm, scatter





     &,            cori
c



c

c
      sla = dampdz(1)*secday/dampts(1)
      slb = 3.80116e3/ssp
      fp = -1.9
c
      avetime = 0.0
      do j=2,jmtm1
        do i=2,imtm1
c
c-----------------------------------------------------------------------
c         zero flux totals for new accumulation
c-----------------------------------------------------------------------
c
          flux(i,j,1) = 0.0
          flux(i,j,2) = 0.0
c
          if (kmt(i,j) .gt. 0) then
c
c-----------------------------------------------------------------------
c           set sea surface temperature and surface humidity
c-----------------------------------------------------------------------
c

            if (sbcocn(i,j,ihflx) .eq. sla*(fp - surf(i,j,1))) then
c             set surface temperature to atmospheric temperature for
c             areas where ice would form if there was an ice model
              surf(i,j,1) = at(i,j,2,1)
            else
              surf(i,j,1) = sbcocn(i,j,isst)
            endif

	    surf(i,j,2) = slb*exp(17.67*surf(i,j,1)/
     &                    (surf(i,j,1) + 243.5))
c

c-----------------------------------------------------------------------
c           calculate the downward heat flux to freeze the first layer
c-----------------------------------------------------------------------
c
	    sbcocn(i,j,ihflx) = sla*(fp - surf(i,j,1))
c
	  endif
	enddo

      enddo
c






c
      return
      end
      subroutine gosbc (ncall)

c
c=======================================================================
c     calculate surface boundary conditions for the ocean
c
c     inputs:
c     ncall = number of times this routine was called
c
c     author:      m.eby                 e-mail=> eby@uvic.ca
c=======================================================================

c
c-----------------------------------------------------------------------
c     calculate the average fluxes
c-----------------------------------------------------------------------
c
      call aveflux
c
      return
      end
      subroutine gcoord (maxlen, imt, jmt, km, dxtdeg, dytdeg, dxudeg
     &,                  dyudeg, dzt, dzw, xt, xu, yt, yu, zt, zw)
c
c=======================================================================
c
c                      G R I D    C O O R D I N A T E S
c
c     Construct grid point coordinates and resolution
c
c     input:
c
c     maxlen = maximum number of grid cells in latitude, longitude,
c              and depth
c
c              set grid specifications in USER INPUT section.
c
c     output:
c
c     imt    = number of longitudes
c     jmt    = number of latitudes
c     km     = number of depths
c     dxtdeg = width of "t" grid cells (degrees)
c     dytdeg = height of "t" grid cells (degrees)
c     dxudeg = width of "u" grid cells (degrees)
c     dyudeg = height of "u" grid cells (degrees)
c     dzt    = thickness of "t" grid cells (cm)
c     dzw    = thickness of "w" grid cells (cm)
c     xt     = longitude at centers of "t" grid cells (degrees)
c     xu     = longitude at centers of "u" grid cells (degrees)
c     yt     = latitude at centers of "t" grid cells (degrees)
c     yu     = latitude at centers of "u" grid cells (degrees)
c     zt     = depth at centers of "t" grid cells (centimeters)
c     zw     = depth at centers of "u" grid cells (centimeters)
c
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c=======================================================================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c

      parameter (maxbounds=11)
      dimension xt(maxlen), yt(maxlen), xu(maxlen), yu(maxlen)
      dimension zw(maxlen), zt(maxlen)
c
      dimension dxtdeg(maxlen), dytdeg(maxlen), dzt(maxlen)
      dimension dxudeg(maxlen), dyudeg(maxlen), dzw(0:maxlen)
c
      dimension x_lon(maxbounds),   dx_lon(maxbounds)
      dimension y_lat(maxbounds),   dy_lat(maxbounds)
      dimension z_depth(maxbounds), dz_depth(maxbounds)
c
c-----------------------------------------------------------------------
c     USER INPUT ===>  read this section and specify the grid.
c-----------------------------------------------------------------------
c
c     How to define a grid resolution:
c
c     The ocean model domain is composed of one or more regions in
c     latitude, longitude, and depth. Latitude and longitude are in
c     degrees east of Greenwich and depth is in centimeters. Each
c     region is defined by its bounds and resolution at those bounds.
c     Within each region, resolution may be constant or smoothly
c     varying but there must be an integral number of grid cells
c     contained within the region`s bounds.
c     
c     If the resolution at both bounds of a region is the same, then
c     resolution within the region is constant. If the bounding
c     resolutions differ, resolution varies smoothly across the region
c     to make the transition. The functional for the variation is
c     taken to be a cosine. Regions sharing a common boundary have the
c     same resolution at that boundary AND the first derivitive is
c     zero there to minimize effects of numerics. In the vertical, the
c     last region allows a stretching factor to provide a more drastic
c     fall off of resolution to the bottom if desired.
c 
c     Example:
c
c     Define a domain composed of two regions of longitude: The first
c     is bounded by longitudes 120E and 180E with constant 1.0 degree
c     resolution. The second extends east of 180E to 300E where the
c     resolution is desired to be 3 degrees (at 300E). To do this,
c     specify the following:
c     
c      parameter (nxlons=3)
c      data (x_lon(i), i=1,nxlons)  /120.0, 180.0, 300.0/
c      data (dx_lon(i),i=1,nxlons)  /  1.0,   1.0,   3.0/                                           
c
c      where...
c
c     "nxlons"  = number of bounding longitudes to define regions {3}
c     "x_lon"   = bounding longitudes {120.0E, 180.0E, 300.0E}
c     "dx_lon"  = resolution centered at "x_lon" {1.0, 1.0, 3.0}
c     
c     Note: Region bounds are not defined exactly as in MOM 1. Now they
c           are defined on "u" grid points (which are at the edges of
c           "T" cells) as described below.
c
c     The western edge of the 1st "T" cell will be at x_lon(1) and
c     the eastern edge of the last "T" cell within the first region
c     will be at x_lon(2). Since the resolution at both bounds is
c     1.0 degree, there will be a constant 1 degree resolution within
c     this first region.
c
c     The western edge of the 1st "T" cell within the second region is
c     at x_lon(2) and the eastern edge of the last "T" cell is at
c     x_lon(3). Since resolutions at the bounds of region 2 differ,
c     resolution will gradually taper from 1.0 degree at the western
c     bound to 3.0 degrees at the eastern bound. Note that the
c     resolution of the 1st "T" cell adjacent to x_lon(2) will
c     be slightly greater than 1.0 degree (it would be 1.0 degree if
c     the grid cell were centered exactly at x_lon(2) but it is not).
c
c     The number of "T" cells within each region will be equal to the
c     width of the region divided by the average resolution within the
c     region. The average resolution within the region is simply the
c     average of the bounding resolutions. In region #1, it will be
c     (1.0 + 1.0)/2 = 1.0 degree and in region #2 it will be
c     (1.0 + 3.0)/2 = 2.0 degree. Since region #1 is 60 degree wide,
c     the number of "T" cells will be 60.0/1.0 = 60 and for region #2
c     there will be 120.0/2.0 = 60 cells also.
c
c     How are "u" cells defined?     
c
c     Since MOM uses an Arakawa "B" grid, the "u" cells are offset from
c     the "T" cells. The "u" cell grid points are at the vertices of the
c     "T" cells and visa versa. The "u" cell with coordinates (i,j) is
c     on the northeast vertex of the "T" cell with coordinates (i,j). In
c     the vertical, "u" cells and "T" cells are at the same level.
c     However, advective vertical velocity is defined at the base of
c     "T" and "u" cells. Thus "w" cells can be thought of as vertical
c     advective velocity cells with the grid being staggared in the
c     vertical. The relationship between "T" (or "u") cells and "w"
c     cells is that the "w" cell with index (k) is at the base of the
c     "T" (or "u") cell with index k. 
c
c     What happens when the grid cells are stretched?
c
c     Grid stretching (variable resolution) is not done exactly as in
c     MOM 1. In MOM 1, the "u" cell resolution was the average of the
c     resolutions of the adjacent "T" cells. For instance: "dxt" was 
c     specified first... then dxu(i) = 0.5*(dxt(i+1) + dxt(i)).
c     In a stretched grid, the "T" grid points were always in the middle
c     of "T" cells and the "u" grid points were off center in "u" cells.
c
c     In MOM 2, it`s the other way around: the "T" cell resolution is
c     the average of the resolutions of the adjacent "u" cells. So,
c     "dxu" is specified first... then dxt(i) = 0.5*(dxu(i-1) + dxu(i))
c     Also, "u" grid points are always in the middle of "u" cells and
c     "T" grid points are off center in "T" cells.
c          
c     This allows for more accurate advection velocities to be defined
c     on the faces of the cells when the resolution varies. The
c     implication is that advection will be more accurate for tracers
c     in the horizontal and both tracers and momentum in the vertical.
c     Advection will not be more accurate for momentum in the horizontal
c     because "u" grid  points will always be in the center of the "u"
c     cells.
c
c     What if I want the resolution from MOM 1?
c
c     It is possible to closely approximate the horizontal resolution
c     from MOM 1 by enabeling the "-Dcentered_t" option. Whether this is
c     done or not, the "u" grid points are always on the edges of "T"
c     cells and the "T" grid points are always on the edges of "u" 
c     cells. In the vertical, MOM 1 used a gaussian for stretching the
c     resolution. MOM 2 uses the same cosine functional for varying
c     resolution in the vertical as in the horizontal. Additionally,
c     a stretching factor is used to give the functionality of enhanced
c     stretching towards the bottom of the ocean domain if desired.
c           
c     Another alternative is to read in whatever grid discretization you 
c     like by enabeling the -D"read_my_grid" option and being aware of
c     the potential consequences. The crucial point is that if you have
c     enough resolution to adequately resolve the scales of motion (but
c     who does?), it doesn`t much matter how the resolution is
c     distributed. However, keep in mind the above remarks about
c     advection.
c            
c-----------------------------------------------------------------------
c     The following specifies the global test grid resolution: 
c-----------------------------------------------------------------------
c
c     constant 4.0 degree resolution in longitude
c
      parameter (nxlons=2)
      data (x_lon(i), i=1,nxlons) / 0.0, 360.0/
      data (dx_lon(i),i=1,nxlons) / 4.0,   4.0/        
c
c     constant 3.0 degree resolution in latitude
c
      parameter (nylats=2)
      data (y_lat(j), j=1,nylats) / -87.0,  90.0/
      data (dy_lat(j),j=1,nylats) /  3.0,    3.0/        
c
c     two vertical regions: constant 25m in the upper 100m, and variable
c     resolution in the lower region. Note that by setting the stretch
c     factor "stretch_z" > 1.0, the last region in the vertical can
c     have the grid cells stretched further. To see the effect of
c     stretching on vertical cell thickness and number of vertical
c     cells, try using "stretch_z"=1.1 and gradually increase it.  
c
      parameter (nzdepths=3)
      data (z_depth(k), k=1,nzdepths) /  0.0e2,   100.0e2,  5600.0e2/
      data (dz_depth(k),k=1,nzdepths) / 25.0e2,    25.0e2,   975.0e2/        
      data stretch_z /1.0/
c
c     Some other examples:
c
c      4.0 degrees at the poles down to 2.0 deg at the equator
c
c      parameter (nylats=3)
c      data (y_lat(j), j=1,nylats) / -90.0,  0.0,  90.0/
c      data (dy_lat(j),j=1,nylats) /   4.0,  2.0,   4.0/        
c
c      set 1 deg at -30 deg lat down to 1/3 deg at -10 deg lat
c      constant 1/3 deg resolution from -10 deg to +10 deg lat and
c      1/3 deg at +10 deg lat to 1.0 deg at +30 deg lat 
c
c      parameter (nylats=4)
c      data (y_lat(j), j=1,nylats) / -30.0,  -10.0,    10.0,  30.0/
c      data (dy_lat(j),j=1,nylats) /   1.0,  0.3333,  0.3333,  1.0/        
c


c-----------------------------------------------------------------------
c     ==> end of USER INPUT
c-----------------------------------------------------------------------
c
c     set some constants
c
      p5 = 0.5
c
      write (stdout,'(/,a,/(/a))')
     &  'The following grid options have been selected:'

     &,'-Dgenerate_a_grid'




c
      ncase = 0


      ncase = ncase + 1
c
      write (stdout,'(//,36x,a,/)') 'G R I D   G E N E R A T I O N'
      write (stdout,'(/,43x,a,/)') 'Grid resolution:'
c
      if (nxlons .gt. maxbounds .or. nylats .gt. maxbounds .or.
     &    nzdepths .gt. maxbounds) then
        write (stdout,'(/a/)')
     &  ' Increase parameter "maxbounds" to contain all regions.'
        stop
      endif
c
c-----------------------------------------------------------------------
c     Calculate resolution in longitude. Add one boundary cell at the
c     start and end of the domain so that calculations are meaningful
c     for grid cells i=2,imt-1
c-----------------------------------------------------------------------
c
      nbpts = 2
      write (stdout,'(/a,i1,a)')
     & ' Generating the longitudinal resolution ( ', nbpts
     &, ' extra boundary points will be used).'
c
c     convert negative longitudes (degrees west of Greenwich) to
c     positive longitudes
c
      offset = 0.0
      do n=1,nxlons
        if (x_lon(n) .lt. 0.0) then
          offset = 360.0
        endif
      enddo
      if (offset .gt. 0.0) then
	  write (stdout,'(/,a/,a/,a)')
     &    '=>Warning: adding 360.0 degrees to all longitudes to convert'
     &,   '           negative values (degrees west of Greenwich) to'
     &,   '           positive values (degrees east of Greenwich)'
      endif
      do n=1,nxlons
        x_lon(n) = x_lon(n) + offset
      enddo
c
c
c     if a region contains the greenwich meridian, compensate by adding
c     360.0 degrees to all remaining regions
c
      do n=2,nxlons
        if (x_lon(n-1) .gt. x_lon(n)) then
	  x_lon(n) = x_lon(n) + 360.0
	  write (stdout,'(/,a,i1,a,a/)')
     &    ' Warning: adding 360.0 degrees to x_lon(',n,')'
     &,   ' to insure region boundaries increase monotonically'
	endif
      enddo
c
c     if width of domain exceeds 360.0 deg... limit width to 360.0
c
      if (x_lon(nxlons) - x_lon(1) .gt. 360.0) then
        write (stdout,'(/a,a,g14.7/)')
     &  '=>Warning: Domain width exceeds 360 deg. Restricting last'
     &, ' x_lon to ',x_lon(1)+360.0
          do m=1,nxlons
            write (stdout,'(i3,f10.5)') m, x_lon(m)
          end do
      endif
      if (x_lon(nxlons) - x_lon(1) .eq. 360.0) then
        if (dx_lon(nxlons) .ne. dx_lon(1)) then
          write (stdout,'(/a,a)')
     &    '=>Error: dx_lon(1) must equal dx_lon(last) when domain'
     &,   ' width = 360.0 degrees'
        endif
      endif

      stretch_x = 1.0
      call gcell (maxlen, nxlons, x_lon,  dx_lon, nbpts
     &,           imt, dxtdeg, dxudeg, stretch_x)
c
c-----------------------------------------------------------------------
c     Build the longitudinal grid points for a "B" grid
c     (account for an extra boundary point at the start)
c-----------------------------------------------------------------------
c
      xt(1) = x_lon(1) - p5*dx_lon(1)
      xu(1) = x_lon(1)
c
      do i=2,imt
        xu(i) = xu(i-1) +  dxtdeg(i)
        xt(i) = xt(i-1) +  dxudeg(i-1)
      enddo
c
c-----------------------------------------------------------------------
c     Calculate resolution in latitude. Add one boundary cell at the
c     start and end of the domain so that calculations are meaningful
c     for grid cells jrow=2,jmt-1
c-----------------------------------------------------------------------
c
      nbpts = 2
      write (stdout,'(/a,i1,a)')
     & ' Generating the latitudinal resolution ( ', nbpts
     &, ' extra boundary points will be used).'
c
c     if width of domain exceeds 180.0 deg... limit width to 180.0
c
      if (y_lat(nylats) - y_lat(1) .gt. 180.0) then
        write (stdout,'(/a,a,g14.7/)')
     &  '=>Warning: Latitudinal domain width exceeds 180 deg.'
     &, ' Restricting last y_lat to ',y_lat(1)+180.0
      endif
      do n=2,nylats
        if (y_lat(n-1) .gt. y_lat(n)) then
	  write (stdout,'(/,a,/a/)')
     &    ' =>Error: latitude boundaries must increase monotonically'
     &,   '          check the specifications in the USER INPUT section'
          do m=1,nylats
            write (stdout,'(i3,f10.5)') m, y_lat(m)
          end do
          stop '==>grids'
	endif
      enddo
      stretch_y = 1.0
      call gcell (maxlen, nylats, y_lat, dy_lat, nbpts
     &,           jmt, dytdeg, dyudeg, stretch_y)
c
c-----------------------------------------------------------------------
c     Build the latitudinal grid points on a "B" grid
c     (account for an extra boundary point at the start)
c-----------------------------------------------------------------------
c
      yt(1) = y_lat(1) - p5*dy_lat(1)
      yu(1) = y_lat(1)
      do jrow=2,jmt
        yu(jrow) = yu(jrow-1) +  dytdeg(jrow)
        yt(jrow) = yt(jrow-1) +  dyudeg(jrow-1)
      enddo
c
c-----------------------------------------------------------------------
c     Calculate resolution in depth. No boundary cells added here so
c     calculations are meaningful for k=1,km. Allow the bottom region 
c     to be stretched further if desired.
c-----------------------------------------------------------------------
c
      nbpts = 0
      write (stdout,'(/a,i1,a)')
     & ' Generating the vertical resolution ( ', nbpts
     &, ' extra boundary points will be used).'
      do n=2,nzdepths
        if (z_depth(n-1) .gt. z_depth(n)) then
	  write (stdout,'(/,a,/a/)')
     &    ' =>Error: depth boundaries must increase monotonically'
     &,   '          check the specifications in the USER INPUT section'
          stop '==>grids'
	endif
      enddo
      call gcell (maxlen, nzdepths, z_depth, dz_depth, nbpts
     &,           km, dzt, dzw(1), stretch_z)
c
c-----------------------------------------------------------------------
c     Build the vertical grid points on a "B" grid. The "T" and "u"
c     cells are staggared in the horizontal but at the same level in
c     the vertical. However, the "w" cells here refer to the vertical
c     advection velocities at the bottoms of the "u" and "T" cells.
c     (no extra boundary point at the start)
c-----------------------------------------------------------------------
c
      zt(1) = z_depth(1) + p5*dz_depth(1)
      zw(1) = z_depth(1) + dzt(1)
      do k=2,km
        zw(k) = zw(k-1) + dzt(k)
        zt(k) = zt(k-1) + dzw(k-1)
      enddo
c
c     set "w" cell thickness at surface and bottom to ocean part of cell
c
      dzw(0)  = zt(1)
      dzw(km) = zw(km) - zt(km)
c
c-----------------------------------------------------------------------
c     Print grid "t" cell resolution in longitude, latitude and depth
c     (also for "w" cells in depth)
c-----------------------------------------------------------------------
c
      write (stdout,9101) 
     &'Vertical resolution of cells "dzw(k)" k=0,', km, 'cm'
      write (stdout,9002) (dzw(k),k=0,km)
      write (stdout,9101) 
     &'Vertical resolution of cells "dzt(k)" k=1,', km, 'cm'
      write (stdout,9002) (dzt(k),k=1,km)
      write (stdout,9101) 
     &'Longitudinal resolution of cells "dxtdeg(i)" i=1,', imt, 'deg'
      write (stdout,9001) (dxtdeg(i),i=1,imt)
      write (stdout,9101) 
     &'Latitudinal resolution of cells "dytdeg(j)" jrow=1,', jmt, 'deg'
      write (stdout,9001) (dytdeg(jrow),jrow=1,jmt)

      if (ncase .eq. 0) then
        write (stdout,'(/a/a/)')
     & '=>Error: One of the following options must be enabled:'
     &,'         generate_a_grid    read_my_grid'
        stop '=>grid' 
      elseif (ncase .gt. 1) then
        write (stdout,'(/a/a/)')
     & '=>Error: Only one of the following options may be enabled:'
     &,'         generate_a_grid    read_my_grid'
        stop '=>grid' 
      endif
c
c-----------------------------------------------------------------------
c     Check if the "t" grid resolution is an average of the
c     "u" cell resolution. This insures more accurate advection of
c     tracers within a stretched grid.
c-----------------------------------------------------------------------
c
      num  = 0
      tolr = 1.e-5
      write (stdout,'(/)')
      do i=2,imt-1
        dxubar = p5*(dxudeg(i) + dxudeg(i-1))
        if (abs(dxubar-dxtdeg(i)) .gt. tolr) then
	  num = num + 1
          write (stdout,'(a,i5,a)')
     &    '=>Warning: "t" cell delta x at i=',i
     &,   ' is not an average of adjacent "u" cell delta x`s'     
        endif     
      enddo
c
      do jrow=2,jmt-1
        dyubar = p5*(dyudeg(jrow) + dyudeg(jrow-1))
        if (abs(dyubar-dytdeg(jrow)) .gt. tolr) then
	  num = num + 1
          write (stdout,'(a,i5,a)')
     &    '=>Warning: "t" cell delta y at jrow=',jrow
     &,   ' is not an average of adjacent "u" cell delta y`s' 
        endif     
      enddo
c
      tolr = 1.e0
      do k=2,km-1
        dzwbar = p5*(dzw(k) + dzw(k-1))
        if (abs(dzwbar-dzt(k)) .gt. tolr) then
	  num = num + 1
          write (stdout,'(a,i5,a)')
     &    '=>Warning: "t" cell delta z at k=',k
     &,   ' is not an average of adjacent "w" cell delta z`s'     
        endif     
      enddo
c
      if (num .ne. 0) then
        write (stdout,'(/a/a/a/a//a,a/)')
     &  '==>Warning, At the above locations, advection of tracers is'
     &, 'not as accurate as it could be. If you are reading in your own'
     &, 'grid or constructing a grid as in MOM 1, we assume you want to'
     &, 'define the grid this way and we let you proceed from here...'
     &, 'Please read ALL the information in the USER INPUT section to '
     &, 'understand what this means' 
      endif
c
c-----------------------------------------------------------------------
c     Print all grid coordinates
c-----------------------------------------------------------------------
c
      write (stdout
     &,'(//,40x,a,//,a,g14.7,a,/a/,a,g14.7,a/a,/,a,g14.7,a)') 
     &  ' Grid Point Coordinate details: '
     &, ' The western edge of the 2nd "t" cell is at longitude:'
     &,   xu(1),' (deg)',' (the 1st "t" cell is a boundary cell)'
     &, ' The southern edge of the 2nd "t" cell is at latitude:'
     &,   yu(1),' (deg)',' (the 1st "t" cell is a boundary cell)'
     &,' The top edge of the 1st "t" cell is at z =',z_depth(1),' (cm)'
      write (stdout,'(/,a,g14.7,a/a/,a,g14.7,a/a/,a,g14.7,a/)') 
     &  ' The western edge of the 1st "u" cell is at longitude:', xt(1)
     &, ' (deg)',' (the 1st "u" cell is a boundary point)'
     &, ' The southern edge of the 1st "u" cell is at latitude:', yt(1)
     &, ' (deg)',' (the 1st "u" cell is a boundary point)'
     &, ' The top edge of the 1st "w" cell is at z =',zt(1),' (cm)'
      write (stdout,9103) km
      write (stdout,9002) (zt(k),k=1,km)
      write (stdout,9104) km
      write (stdout,9002) (zw(k),k=1,km)
      write (stdout,9105) jmt
      write (stdout,9001) (yt(jrow),jrow=1,jmt)
      write (stdout,9106) jmt
      write (stdout,9001) (yu(jrow),jrow=1,jmt)
      write (stdout,9107) imt
      write (stdout,9001) (xt(i),i=1,imt)
      write (stdout,9108) imt
      write (stdout,9001) (xu(i),i=1,imt)
c

c
c---------------------------------------------------------------------
c     compute a grid checksum
c---------------------------------------------------------------------
c
      cksum = 0.0
      cksum = cksum + checksum (xt, imt, 1)
      cksum = cksum + checksum (yt, jmt, 1)
      cksum = cksum + checksum (zt, km, 1)
      cksum = cksum + checksum (xu, imt, 1)
      cksum = cksum + checksum (yu, jmt, 1)
      cksum = cksum + checksum (zw, km, 1)
      cksum = cksum + checksum (dxtdeg, imt, 1)
      cksum = cksum + checksum (dytdeg, jmt, 1)
      cksum = cksum + checksum (dxudeg, imt, 1)
      cksum = cksum + checksum (dyudeg, jmt, 1)
      cksum = cksum + checksum (dzt, km, 1)
      cksum = cksum + checksum (dzw, km+1, 1)
      write (stdout,'(/)')
      write (stdout,*) 'Grid checksum = ',cksum
      write (stdout,'(/)')
      return
9001  format (1x,10f10.4)
9002  format (1x,10f10.2)
9101  format (/,  a,i4,' in units of ',a,' as follows:')
9103  format (/,' Depth to "t" & "u" grid points (cm): zt(k) k=1,',i3)
9104  format (/,' Depth to "w" grid points (cm): zw(k) k=1,',i3)
9105  format (/,' Latitude of "t" points (deg): yt(j) j=1,',i4)
9106  format (/,' Latitude of "u" points (deg): yu(j) j=1,',i4)
9107  format (/,' Longitude of "t" points (deg): xt(i) i=1,',i4)
9108  format (/,' Longitude of "u" points (deg): xu(i) i=1,',i4)
      end





      subroutine gcell (maxlen, n_bounds, bounds, d_bounds, nbpts
     &,                 num, deltat, deltau, stretch)
c
c=======================================================================
c
c              G R I D   C E L L   C O N S T R U C T I O N
c
c     A domain is composed of one or more regions:
c     Build "num" "t"  cells with resolution "deltat(n) n=1,num" 
c     within the domain composed of regions bounded by "bounds".
c     Also construct "num" "u"  cells of resolution "deltau(n) n=1,num"
c     with the relation between "t" and "u" cells given by:

c     deltat(n) = 0.5*(deltau(n-1) + deltau(n))

c     Resolution may be constant or smoothly varying within each
c     region AND there must be an integral number of grid cells within 
c     each region. The domain is the sum of all regions.
c
c     inputs:
c
c     maxlen   = maximum length of "deltat" and "deltau"
c     n_bounds = number of bounds needed to define the regions
c     bounds   = latitude, longitude, or depth at each bound
c     d_bounds = delta (resolution) at each of the "bounds"
c     nbpts    = number of extra boundary cells to add to the domain.
c                (usually one at the beginning and end)
c     stretch  = stretching factor for last region (should only be used
c                in the vertical to provide increased stretching of grid
c                points. "stretch" = 1.0 gives no increased stretching.
c                "stretch" = 1.2 gives increased stretching...etc
c             
c     outputs:
c
c     num    = total number of grid cells within the domain
c     deltau = resolution of "u" grid cells: n=1,num
c     deltat = resolution of "t" grid cells: n=1,num
c
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c=======================================================================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
      dimension deltat(maxlen), deltau(maxlen)
      dimension d_bounds(n_bounds), bounds(n_bounds)
c
c     Set some constants
c
      p5 = 0.5
      pi = 4.0*atan(1.0)
c
c     Do all regions, one at a time, to construct the domain
c
      num  = 1
      do l=1,n_bounds-1
c
        write (stdout,'(2x,a,i2,a,g14.7,a,g14.7,a,g14.7,a,g14.7,a)')
     & ' region # ',l,'  going from ',bounds(l),' (res=',d_bounds(l)
     &,') to ',  bounds(l+1),' (res=',d_bounds(l+1),')' 
c
c       avg_res = average resolution of "t" cells within region
c       chg_res = change in resolution across the region
c       wid     = width of region
c       tol     = tolerance for fitting "t" cels within region width
c
c       provide for stretching last region if needed
c
        if (l .eq. n_bounds-1) then
          avg_res = p5*(d_bounds(l) + stretch*d_bounds(l+1))
	  chg_res = (stretch*d_bounds(l+1) - d_bounds(l))
	else
          avg_res = p5*(d_bounds(l) + d_bounds(l+1))
	  chg_res = (d_bounds(l+1) - d_bounds(l))
	endif
c
	tol = 1.e-5
	wid = abs(bounds(l+1) - bounds(l))
        an  = wid/avg_res
	m   = nint(an)
c

c
c       Calculate resolution of "u" cells: "deltau"
c       "u" grid points will be centered in these cells
c       n = number of "t" cells fitting within the region boundaries
c       note: "sum" initially discounts half of the "u" cells widths
c       at the boundaries
c
        sum = 0.5*d_bounds(l) - 0.5*d_bounds(l+1)
	n   = 0
        do i = 1,100000
	  del = avg_res - p5*chg_res*cos((pi/m)*i)
	  if (sum + del .le. wid*(1.0 + tol)) then
	    sum = sum + del
	    if (num+i-1 .gt. maxlen) then
	      write (stdout,*) "=>Error: maxlen exceeded in gcell. "
     &,                        " ...increase size of maxlen"
	      stop
	    endif
	    deltau(num+i-1) = del
	    n = n + 1
	  else
	    go to 100
	  endif
	enddo 

100     continue
        if (l .eq. n_bounds-1 .and. stretch .ne. 1.0) then
          write (stdout,'(a,i3,a,f5.2)')
     & '    constructed ',n,' cells with a stretch factor of ', stretch
          write (stdout,'(/2(a,g14.7),/2(a,g14.7),/a,a/)')
     &    'Note: you specified the ocean bottom at ',bounds(l+1)
     &,   ' cm with a bottom cell thickness of ',d_bounds(l+1)
     &,   '      The stretch factor puts the bottom at ',bounds(l)+sum

     &,   ' cm with a bottom cell thickness of '
     &,   0.5*(deltau(num+n-1) + deltau(num+n-2))

     &,   '      Adjust "stretch_z" in subroutine "gcoord" to get'
     &,   ' closer to the desired specifications if needed.'

	else
          write (stdout,'(a,g14.7,a)')
     &   '    constructed ',an,' grid cells for this region'
          if (abs(an-n) .gt. 0.01) then
            write (stdout, '(/,a,i2,/,a,g14.7/,a,g14.7,a//a/a)')
     & '==>Error: non integral number of cells in region #',l
     &,'          average resolution within region =',avg_res
     &,'          this implies ',an,' grid cells'
     &,'          Change grid specifications within USER INPUT section'
     &,'          Here is some help...'
            d_new = (2.0*wid)/(n-1) - d_bounds(l)
            write (stdout,'(/a,i4,a,i2,a,1pe14.7,a,1pe14.7/)')
     &      ' Note: to get ',n-1,' grid cells within region ',l
     &,     ', change resolution from ', d_bounds(l+1), ' to ', d_new
            d_new = (2.0*wid)/n - d_bounds(l)
            write (stdout,'(/a,i4,a,i2,a,1pe14.7,a,1pe14.7/)')
     &      ' Note: to get ',n,' grid cells within region ',l
     &,     ', change resolution from ', d_bounds(l+1), ' to ', d_new
            d_new = (2.0*wid)/(n+1) - d_bounds(l)
            write (stdout,'(/a,i4,a,i2,a,1pe14.7,a,1pe14.7/)')
     &      ' Note: to get ',n+1,' grid cells within region ',l
     &,     ', change resolution from ', d_bounds(l+1), ' to ', d_new
            stop '=>gcell'
          endif
        endif
        num = num + n
      enddo
c
c     adjust "num" to reflect the total number of cells contained in
c     all regions
c
      num = num - 1
c
      do i=1,num

c
c       build resolution for "T" cells: "deltat". Note that
c       variable resolution (stretched grid) implies "T" points are
c       off center
c
        if (i .eq. 1) then
          deltat(i) = p5*(d_bounds(1) + deltau(i))
        else
	  deltat(i) = p5*(deltau(i) + deltau(i-1))
        endif

      enddo     
c
c     add boundary points if needed
c
      if (nbpts .ne. 0) then
	do i=num,1,-1
	  deltat(i+1) = deltat(i) 
	  deltau(i+1) = deltau(i)
	enddo
	deltat(1)     = deltat(2)
	deltau(1)     = d_bounds(1)
	deltat(num+2) = deltat(num+1) 
	deltau(num+2) = deltau(num+1)
	num           = num + 2 
      endif
      return
      end




      subroutine grids
c
c=======================================================================
c     set up a staggered "B" grid for MOM and compute grid related
c     variables
c
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c=======================================================================
c
c====================== include file "param.h" =========================
c
c     main parameter file which sets ocean characteristics:
c
c     "size.h" sets model size "imt", "jmt", and "km"
c
c====================== include file "size.h" ==========================
c                                                                       
c-----------------------------------------------------------------------
c     USER INPUT: 
c-----------------------------------------------------------------------
c
c     imt    = number of grid points in the longitudinal direction
c              (calculated points are from 2 through imt-1. End points
c               are boundaries)          
c
c     jmt    = number of grid points (latitude rows) in the latitudinal
c              direction (calculated points are from 2 through jmt-1.           
c              End points are boundaries)   
c                                
c     km     = number of grid points in the vertical direction          
c              (calculated points are from 1 through km)
c
c     nt     = number of tracers (temperature, salinity, ...)
c
c     mnisle = maximum number of islands (unconnected land masses)
c
c     maxipp = maximum number of all island perimeter points
c-----------------------------------------------------------------------
c                                                                       
      parameter (imt=  92, jmt=  61, km= 15)
      parameter (nt=2)
      parameter (nat=2)
      parameter (mnisle=50, maxipp=5000)
c

c






c
c-----------------------------------------------------------------------
c     END USER INPUT
c-----------------------------------------------------------------------
c                                                                       
c-----------------------------------------------------------------------
c     By default, the MW (memory window) is 2nd order except for the
c     following options which require a 4th order MW 
c
c     for 2nd order schemes, the minimum sized MW is 3 latitude rows
c     for 4th order schemes, the minimum sized MW is 4 latitude rows
c                            (5 if using coarse_grained_parallelism)
c-----------------------------------------------------------------------
c













c
c-----------------------------------------------------------------------
c     set MW (memory window) size "jmw" 
c-----------------------------------------------------------------------
c                                                                       

c
c     for UNI-TASKING: "jmw" is set to the minimum for each option class 
c     "jmw" may be increased up to "jmt" 
c

      parameter (jmw=jmt)


c
c-----------------------------------------------------------------------
c     set first and last calculated row within the MW. other rows
c     are used as buffers
c-----------------------------------------------------------------------
c
c     jsmw   = 1st calculated row within the MW     
c     jemw   = last calculated row within the MW
c
      parameter (jsmw=2, jemw=jmw-1)
c
c
c     jextra = extra buffer rows needed for coarse_grained_parallelism.
c              "jextra" rows are added to the top and bottom of the MW
c              so the MW size increases by 2*jextra       
c

          parameter (jextra = 0)




c
c     nvar   = number of prognostic variables
c     lseg   = maximum number of longitudinal stream function segments
c     nlatpr = maximum number of latitudes for matrix printouts
c              on diagnostic time steps
c     nhreg  = number of regions in the horizontal used for averaging
c              tracers.
c     nvreg  = number of regions in the vertical used for term balance
c              calculations. note "nvreg" isn`t used for tracer averages
c     numreg = total number of regions ( = product of nhreg & nvreg)
c              used for term balance calculations
c
      parameter (lseg=5, nlatpr=10)

      parameter (nhreg=5, nvreg=2, numreg=nhreg*nvreg)

      parameter (nvar=nt+2)
c

c
      parameter (imtm1=imt-1, kmm1=km-1)                                
      parameter (imtp1=imt+1, imtm2=imt-2
     &,          jmtp1=jmt+1, jmtm1=jmt-1, jmtm2=jmt-2

     &,          jscan=jmtm2

     &,          kmp1=km+1, kmp2=km+2
     &,          imtkm=imt*km, nwds=imt*jmt, nkflds=2
     &,          nslab=imt*nvar*km, ntmin2=nt+1/nt)
c
c     include parameter constants
c
c====================== include file "pconst.h" ========================
c
c
c     rules for parameter constants
c
c     use prefix of "c" for whole real numbers (eg: c57 for 57.0)
c     use "m" after prefix to designate negative values (minus sign)
c       (eg: cm7 for -7.0)
c     use prefix of "p" for non repeating fractions (eg: p5 for 0.5)
c     use prefix of "r" for reciprocals (eg: r3 for 1/3.0)
c     combine use of prefix above and "e" for scientific notation, with
c       (eg: c5e4 for 5.0e4, c1em10 for 1.0e-10)
c
      parameter (c0=0.0, c1=1.0, c2=2.0, c3=3.0, c4=4.0, c5=5.0, c7=7.0)
      parameter (c8=8.0)
      parameter (c14=14.0, c16=16.0, c360=360.0)
      parameter (p125=0.125, p25=0.25, p5=0.5, p75=0.75)
      parameter (epsln=1.0e-20)
c
      parameter (c24=24.0, c60=60.0, c1440=1440.0)
      parameter (r24=c1/c24, r60=c1/c60, r1440=c1/c1440)
      parameter (secday=c1/(c60*c1440))
c
c     include standard I/O units
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c
c     ncrows = number of calculated rows within the MW.
c              (the remaining rows are buffer rows). 
c


      parameter (ncrows = jmw - 2)


c====================== include file "coord.h" =========================
c
c                    model grid point coordinates
c
c     grid definition:
c
c     the model uses a staggard arakawa "b" grid which is setup and 
c     generated by the "grids.F" module. 
c
c     xt(i)   = longitude of the ith "t" point in degrees.   i=1..imt
c     xu(i)   = longitude of the ith "u,v" point in degrees. i=1..imt
c     yt(j)   = latitude of the jth "t" point in degrees.    j=1..jmt
c     yu(j)   = latitude of the jth "u,v" point in degrees.  j=1..jmt
c     zt(k)   = distance from surface down to center of level k (in cm)
c               (for depth of "t" and "u,v" grid points: k=1,km)
c     zw(k)   = distance from surface down to bottom of level k (in cm)
c               (for depth of "t" and "u,v" grid points: k=1,km)
c     dxtdeg  = widths for "t" grid cells (degrees)
c     dytdeg  = heights for "t" grid cells (degrees)
c     dxudeg  = widths for "u" grid cells (degrees)
c     dyudeg  = heights for "u" grid cells (degrees)
c     dzt(k)  = vertical resolution of "t" and "u" grid cells (in cm)
c     dzw(k)  = vertical resolution of "w" grid cells (in cm)
c
c     "i" increases in an eastward direction, "j" increases in a
c     northward direction, and "k" increases downward.
c     
      common /coord/ xt(imt), yt(jmt), xu(imt), yu(jmt), zw(km), zt(km)
      common /coord/ dxtdeg(imt), dytdeg(jmt), dzt(km)
      common /coord/ dxudeg(imt), dyudeg(jmt), dzw(0:km)
c
c====================== include file "grdvar.h" ========================
c
c     variables which are functions of the grid defined by "coord.h"
c
c     dxt     = longitudinal width of "t" grid box at the 
c               equator (in cm)
c     dxtr    = reciprocal of "dxt"
c     dxt2r   = reciprocal of "2*dxt"
c     dxt4r   = reciprocal of "4*dxt"
c     dxu     = longitudinal width of "u,v" grid box at the 
c               equator (in cm)
c     dxur    = reciprocal of "dxu"
c     dxu2r   = reciprocal of "2*dxu"
c     dxu4r   = reciprocal of "4*dxu"
c     dxmetr  = reciprocal of "(dxt(i)+dxt(i+1))"
c     duw     = xu(i) - xt(i)
c     due     = xt(i+1) - xu(i)
c     dus     = yu(jrow) - yt(jrow)
c     dun     = yt(jrow+1) - yu(jrow)
c
c     dyt     = latitudinal height of "t" grid box (in cm)
c     dytr    = reciprocal of "dyt"
c     dyt2r   = reciprocal of "2*dyt"
c     dyt4r   = reciprocal of "4*dyt"
c     dyu     = latitudinal height of "u,v" grid box (in cm)
c     dyur    = reciprocal of "dyu"
c     dyu2r   = reciprocal of "2*dyu"
c     dyu4r   = reciprocal of "4*dyu"
c
c     csu     = cosine of "u,v" grid point latitude
c     csur    = reciprocal of "csu"
c     cst     = cosine of "t" grid point latitude
c     cstr    = reciprocal of "cst"
c     phi     = latitude of "u,v" grid point in radians
c     phit    = latitude of "t" grid point in radians
c     sine    = sine of "u,v" grid point latitude
c     tng     = tan of "u,v" grid point latitude
c     fcor    = 2*omega*sine(j)
c
c     c2dzt(k)= "2*dzt"
c     dztr(k) = reciprocal of dzt ("t" cell vertical resolution)
c     dzt2r(k)= reciprocal of "2*dzt"
c     dzwr(k) = reciprocal of dzw ("w" cell vertical resolution)
c     dzw2r(k)= reciprocal of "2*dzw"
c     dztur(k)= upper diffusion grid factor = 1.0/(dzw(k-1)*dzt(k))
c     dztlr(k)= lower diffusion grid factor = 1.0/(dzw(k)*dzt(k))
c     dzwur(k)= upper diffusion grid factor = 1.0/(dzt(k)*dzw(k))
c     dzwlr(k)= lower diffusion grid factor = 1.0/(dzt(k+1)*dzw(k))
c     
      common /grdvar/ dxt(imt),  dxtr(imt),  dxt2r(imt), dxu(imt)
      common /grdvar/ dxur(imt), dxu2r(imt), dxu4r(imt), dxt4r(imt)
      common /grdvar/ dyt(jmt),  dytr(jmt),  dyt2r(jmt), dyu(jmt)
      common /grdvar/ dyur(jmt), dyu2r(jmt), dyu4r(jmt), dyt4r(jmt)
      common /grdvar/ csu(jmt),  csur(jmt),  cst(jmt),   cstr(jmt)
      common /grdvar/ cstdytr(jmt), cstdyt2r(jmt)
      common /grdvar/ csudyur(jmt), csudyu2r(jmt)
      common /grdvar/ cst_dytr(jmt), csu_dyur(jmt)
      common /grdvar/ phi(jmt),  phit(jmt),  sine(jmt),  tng(jmt)
      common /grdvar/ fcor(jmt), c2dzt(km),  dztr(km),   dzt2r(km) 
      common /grdvar/ dzwr(0:km), dzw2r(0:km)
      common /grdvar/ dxmetr(imt), duw(imt), due(imt)
      common /grdvar/ dun(jmt), dus(jmt)


c

c====================== include file "scalar.h" ========================
c
c     various scalar quantities:
c
c     dtts   = time step for density & tracers (in seconds)
c     dtuv   = time step for baroclinic velocity (in seconds)
c     dtsf   = time step for barotropic velocity (in seconds)
c     c2dtts = 2*dtts
c     c2dtuv = 2*dtuv
c     c2dtsf = 2*dtsf
c     acor   = (>0, 0) = (implicit, explicit) treatment of coriolis
c               term for internal and external modes.
c     rho0   = mean density for Bousinessq approximation
c     rho0r  = 1/rho0 
c     omega  = earth`s rotation rate (radians/sec)
c     radius = earth`s radius (cm)
c     grav   = earth`s gravitational acceleration (cm/sec**2)
c     cdbot  = bottom drag coefficient
c     ncon   = number of  passes through convective code in tracer
c     gcor   = time centering for coriolis term
c
c     taux0  = constant zonal windstress (dynes/cm**2) for idealized
c              equatorial studies
c     tauy0  = constant meridional windstress (dynes/cm**2) for
c              idealized equatorial studies
c
      common /scalar/ dtts, dtuv, dtsf, c2dtts, c2dtuv, c2dtsf, acor
      common /scalar/ rho0, rho0r, omega, radius, grav, cdbot, gcor
      common /scalar/ taux0, tauy0
      common /scalri/ ncon
c
c     bring in non dimensional constants
c
c====================== include file "ndcon.h" ========================
c
c     various non dimensional quantities:
c
c     radian = degrees per radian
c     pi     = something good to eat
c
      common /ndcon/ radian, pi
c
c
c
c-----------------------------------------------------------------------
c     set some constants
c-----------------------------------------------------------------------
c
      pi     = c4*atan(c1)
      radian = c360/(c2*pi)
      degtcm = radius/radian
c
c-----------------------------------------------------------------------
c     calculate coordinates for "t" and "u" grid cells.
c-----------------------------------------------------------------------
c
      maxlen = max(imt,jmt,km)
      call gcoord (maxlen, imt2, jmt2, km2, dxtdeg, dytdeg, dxudeg
     &,            dyudeg, dzt, dzw, xt, xu, yt, yu, zt, zw)
c
c-----------------------------------------------------------------------
c     verify that the number of grid points match the number set in
c     the parameter statement in "size.h".
c-----------------------------------------------------------------------
c
      call size_check (imt2, jmt2, km2, 'sub grids', 'stop')
c
c-----------------------------------------------------------------------
c     convert grid resolution to cm
c-----------------------------------------------------------------------
c
      do jrow=1,jmt
        dyt(jrow) = dytdeg(jrow)*degtcm
        dyu(jrow) = dyudeg(jrow)*degtcm
      enddo
c
      do i=1,imt
        dxt(i) = dxtdeg(i)*degtcm
        dxu(i) = dxudeg(i)*degtcm
      enddo

c
c-----------------------------------------------------------------------
c     compute all quantities derived from the grid spacings
c-----------------------------------------------------------------------
c
      do k=1,km
        c2dzt(k) = c2*dzt(k)
        dzt2r(k) = c1/c2dzt(k)
      enddo
c
      dzwr(km)  = c1/dzw(km)
      dzw2r(km) = p5/dzw(km)
c
      do k=1,km
        dzwr(k-1)    = c1/dzw(k-1)
        dzw2r(k-1)   = p5/dzw(k-1)
      enddo
c
      do k=1,km


        dztr(k)  = c1/dzt(k)
      enddo
c
      tiny = 1.e-20
      do jrow=1,jmt
        dytr(jrow)  = c1/dyt(jrow)
        dyt2r(jrow) = p5/dyt(jrow)
        dyt4r(jrow) = p25/dyt(jrow)
        dyur(jrow)  = c1/dyu(jrow)
        dyu2r(jrow) = p5/dyu(jrow)
        dyu4r(jrow) = p25/dyu(jrow)

        phi(jrow)   = yu(jrow)/radian
	phit(jrow)  = yt(jrow)/radian

        cst(jrow)   = cos(phit(jrow))
        csu(jrow)   = cos(phi (jrow))
        sine(jrow)  = sin(phi(jrow))
	if (cst(jrow)  .eq. 0.0) then
	  print '(/a,e14.7,a,i4,/a)'
     &  ,' Warning: setting cst(jrow) = ',tiny, ' for jrow =',jrow
     &,  '          to prevent division by zero at the pole'
	  cst(jrow)  = tiny
	endif
	if (csu(jrow)  .eq. 0.0) then
	  print '(/a,e14.7,a,i4,/a)'
     &  ,' Warning: setting cst(jrow) = ',tiny, ' for jrow =',jrow
     &,  '          to prevent division by zero at the pole'
	  csu(jrow)  = tiny
	endif
        cstr(jrow)     = c1/cst(jrow)
        csur(jrow)     = c1/csu(jrow)
        tng(jrow)      = sine(jrow)/csu(jrow)
	cstdytr(jrow)  = c1/(cst(jrow)*dyt(jrow))
	cstdyt2r(jrow) = cstdytr(jrow)*p5
        csudyur(jrow)  = c1/(csu(jrow)*dyu(jrow))
        csudyu2r(jrow) = p5/(csu(jrow)*dyu(jrow))
        cst_dytr(jrow) = cst(jrow)/dyt(jrow)
        csu_dyur(jrow) = csu(jrow)/dyu(jrow)
c
      enddo
c
      do i=1,imt
        dxtr(i)  = c1/dxt(i)
        dxt2r(i) = p5/dxt(i)
        dxt4r(i) = p25/dxt(i)
        dxur(i)  = c1/dxu(i)
        dxu2r(i) = p5/dxu(i)
        dxu4r(i) = p25/dxu(i)
      enddo
c
      do i=2,imtm1

        dxmetr(i) = c1/(dxt(i) + dxt(i+1))

      enddo
c
      do i=1,imt
        duw(i) = (xu(i) - xt(i))*degtcm
      enddo
      do i=1,imtm1
	due(i) = (xt(i+1) - xu(i))*degtcm
      enddo

      due(imt) = due(imtm1)

c
      do jrow=1,jmt
        dus(jrow) = (yu(jrow) - yt(jrow))*degtcm
      enddo
c
      do jrow=1,jmtm1
	dun(jrow) = (yt(jrow+1) - yu(jrow))*degtcm
      enddo
      dun(jmt) = dun(jmtm1)
c
c
      return
      end



      subroutine insolation (dayoyr, phi, solins)
c=======================================================================
c     calculate daily insolation
c     based on code by a.fanning and a.berger
c
c     input:
c       dayoyr = days + fractional days since start of calendar year
c       phi    = latitude in degrees
c     output:
c       solins = insolation (units as for solarconst)
c
c     author:   m.eby   e-mail: eby@uvic.ca
c=======================================================================
c

c=================== include file "insolation.h" =======================
c
c     note: this solution of berger 1978 is valid only for 1,000,000 
c           years centered on present-day. for longer period the 
c           solution 1990 must be used (contact Berger for this)                
c                                                              
c                                                              
c     refer to :                                      
c     Berger A. 1978. a simple algorithm to compute long term
c                     variations of daily or monthly insolation
c                     contr. 18  Inst of Astronomy and Geophysics
c                     Universite Catholique de Louvain
c                     Louvain-la-Neuve  Belgium              
c                                                                 
c     Berger A. 1978. long term variations of daily insolation 
c                     and quaternary climatic changes
c                     J. of Atmospheric Sciences  35  2362-2367
c                              
c     nef  nob  nop have been reduced to  19  18  9  
c 
c     these are the expansion coefficients for minimal efficiency, they 
c     can be increased by referring to Berger, 1978:
c     eccentricity           ecc   table 1
c     obliquity              xob   table 2
c     longitude perihelion   perh  table 3
c                    
      parameter	(nef=19, nob=18, nop=9)
c
      real ae(nef), be(nef), ce(nef), ye(nef), ze(nef)
     &,	   aob(nob), bob(nob), cob(nob), yob(nob), zob(nob)
     &,	   aop(nop), bop(nop), cop(nop), yop(nop), zop(nop)
c
      common /insol/ ae, be, ce, ye, ze, aob, bob, cob, yob, zob
     &,              aop, bop, cop, yop, zop, pir, pirr, step
     &,              test, xod, xop, prm, nd, ecc, perh, pre, xob




c====================== include file "ndcon.h" ========================
c
c     various non dimensional quantities:
c
c     radian = degrees per radian
c     pi     = something good to eat
c
      common /ndcon/ radian, pi
c
c====================== include file "cembm.h" =========================
c
c     parameters for use in the energy balance model (also see atm.h)
c
c     addflux		= logical flag for adding only even mode fluxes
c     nats		= number of atmospheric time steps since mixing
c     namix		= time steps between mixing (set in atmos.in)
c     lf		= time step flag (1=>leapfrog, 2=>forward)
c     pyear		= calendar year (set in atmos.in, -/+ = BC/AD)
c     dtatm 		= time step for atmosphere (set in atmos.in)
c     dts		= time step (2*dtatm=>leapfrog, dtatm=>forward)
c     co2ccn		= CO2 concentration
c     anthro		= radiative forcing by CO2
c     co2ccni		= initial CO2 concentration
c     co2yri		= last year of initial CO2 concentration
c     co2ccnf		= final CO2 concentration
c     co2yrf		= first year of final CO2 concentration
c     solarconst	= solar constant (g/s**3)
c     ssp		= sea surface pressure (g/cm/s**2)
c     cdatm 		= drag coefficient (dimensionless)
c     cpatm		= atmospheric heat capacity (cm**2/s**2/K)
c     ht		= scale height for temperature
c     hq		= scale height for specific humidity
c     rhoatm		= density of air at sea surface (g/cm**3)
c     rhoocn		= representative sea surface density
c     esocn		= ocean emissivity times Stefan's constant 
c     vlocn		= latent heat of vaporization of water
c     socn		= constant ocean salinity
c     cdice 		= drag coefficient (dimensionless)
c     rhoice		= ice density (g/cm**3)
c     esice		= ice emissivity times Stefan's constant 
c     slice		= latent heat of sublimation of ice
c     flice		= latent heat of fusion of ice (cm**2/s**2)
c     condice		= ice conductivity (g*cm/s**3/K)
c     kadv		= time step divider for ice advection
c     ntats		= time step counter for time averaging
c     avetime		= time for averaging fluxes
c     totaltime		= total time for long term averages
c
      logical addflux
c
      common /cembm/ addflux
      common /cembm/ nats, namix, lf, kadv, ntats
      common /cembm/ pyear, dtatm, dts, co2ccn, anthro, co2ccni, co2yri
     &,              co2ccnf, co2yrf, solarconst, ssp, cdatm, cpatm, ht
     &,              hq, rhoatm, rhoocn, esocn, vlocn, socn, cdice
     &,              rhoice, esice, slice, flice, condice, avetime 
     &,              totaltime
c
c
      nd = nint(dayoyr)
c
c     longitude of perihelion relative to vernal equinox
      xl = perh + 180.0
c
c     calendar date  month (ma) and day (ja)
c     nd  number of this day in a year of 365 days
c     xlam = mean long. sun for true long. = 0
c     dlamm = mean long. sun for ma-ja
c
      xllp = xl*pir
      xee = ecc**2.0
      xse = sqrt(1.0-xee)
      xlam = (ecc/2.0 + ecc*xee/8.0)*(1.0+xse)*sin(xllp)
     &     - xee/4.0*(1.5 + xse)*sin(2.0*xllp)
     &     + ecc*xee/8.0*(1.0/3.0 + xse)*sin(3.20*xllp)
      xlam = 2.0*xlam/pir
      dlamm = xlam + (nd - 80)*step
      anm = dlamm - xl
      ranm = anm*pir
      xec = xee*ecc
      ranv = ranm + (2.0*ecc - xec/4.0)*sin(ranm)
     &     + 5.0/4.0*ecc**2*sin(2.0*ranm)
     &     + 13.0/12.0*xec*sin(3.0*ranm)
      anv = ranv/pir
c
c     true longitude of the earth
      tls = anv + xl
c
      rphi = phi*pir
      s = 1.0/(pi*((1.0-ecc*ecc)/(1.0+ecc*cos((tls-xl)*pir)))**2)
      sind = sin(xob*pir)*sin(tls*pir)
      cosd = sqrt(1.0-sind**2)
      rdelta = atan(sind/cosd)
      delta = rdelta/pir
      aphi = abs(phi)
      adelta = abs(delta)
c
c     singularity for aphi = 90 and delta = 0 => polar night
      if ((abs(aphi - 90.0) .gt. test) .or. (adelta .gt. test)) then
        if(adelta .le. test) then
c         equinoxes (delta = 0)
          dayl = 12.0
          ww = s*cos(rphi)
        else
          if(aphi .le. test) then
c           equator (phi = 0)
            dayl = 12.0
            ww = s*cos(rdelta)
          else
            phid = phi*delta
            if ((aphi .gt. 90.0 - adelta) .and. (phid .ne. 0.0)) then
              if (phid .gt. 0.0) then
c               polar continual day
                dayl = 24.00
	        ww = s*sind*sin(rphi)*pi
              else
c               polar continual night
                dayl = 0.0
                ww = 0.0
              endif
            else
c             daily sunrise and sunset
              sinp = sind*sin(rphi)
              cosp = cosd*cos(rphi)
              tp = -sinp/cosp
              stp = sqrt(1.0-tp*tp)
              rdayl = acos(tp)
              dayl = 24.0*rdayl/pi
              ww = s*(rdayl*sinp+cosp*stp)
            endif
          endif
        endif
      else
c       polar continual night
        dayl = 0.0
        ww = 0.0
      endif
c
      solins = solarconst*ww
c
      return
      end


      subroutine berger
c=======================================================================
c     calculate eccentricity, precession and obliquity for any year
c     based on code by a.fanning and a.berger
c
c     author:   m.eby   e-mail: eby@uvic.ca
c=======================================================================
c
c=================== include file "insolation.h" =======================
c
c     note: this solution of berger 1978 is valid only for 1,000,000 
c           years centered on present-day. for longer period the 
c           solution 1990 must be used (contact Berger for this)                
c                                                              
c                                                              
c     refer to :                                      
c     Berger A. 1978. a simple algorithm to compute long term
c                     variations of daily or monthly insolation
c                     contr. 18  Inst of Astronomy and Geophysics
c                     Universite Catholique de Louvain
c                     Louvain-la-Neuve  Belgium              
c                                                                 
c     Berger A. 1978. long term variations of daily insolation 
c                     and quaternary climatic changes
c                     J. of Atmospheric Sciences  35  2362-2367
c                              
c     nef  nob  nop have been reduced to  19  18  9  
c 
c     these are the expansion coefficients for minimal efficiency, they 
c     can be increased by referring to Berger, 1978:
c     eccentricity           ecc   table 1
c     obliquity              xob   table 2
c     longitude perihelion   perh  table 3
c                    
      parameter	(nef=19, nob=18, nop=9)
c
      real ae(nef), be(nef), ce(nef), ye(nef), ze(nef)
     &,	   aob(nob), bob(nob), cob(nob), yob(nob), zob(nob)
     &,	   aop(nop), bop(nop), cop(nop), yop(nop), zop(nop)
c
      common /insol/ ae, be, ce, ye, ze, aob, bob, cob, yob, zob
     &,              aop, bop, cop, yop, zop, pir, pirr, step
     &,              test, xod, xop, prm, nd, ecc, perh, pre, xob




c====================== include file "ndcon.h" ========================
c
c     various non dimensional quantities:
c
c     radian = degrees per radian
c     pi     = something good to eat
c
      common /ndcon/ radian, pi
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c====================== include file "cembm.h" =========================
c
c     parameters for use in the energy balance model (also see atm.h)
c
c     addflux		= logical flag for adding only even mode fluxes
c     nats		= number of atmospheric time steps since mixing
c     namix		= time steps between mixing (set in atmos.in)
c     lf		= time step flag (1=>leapfrog, 2=>forward)
c     pyear		= calendar year (set in atmos.in, -/+ = BC/AD)
c     dtatm 		= time step for atmosphere (set in atmos.in)
c     dts		= time step (2*dtatm=>leapfrog, dtatm=>forward)
c     co2ccn		= CO2 concentration
c     anthro		= radiative forcing by CO2
c     co2ccni		= initial CO2 concentration
c     co2yri		= last year of initial CO2 concentration
c     co2ccnf		= final CO2 concentration
c     co2yrf		= first year of final CO2 concentration
c     solarconst	= solar constant (g/s**3)
c     ssp		= sea surface pressure (g/cm/s**2)
c     cdatm 		= drag coefficient (dimensionless)
c     cpatm		= atmospheric heat capacity (cm**2/s**2/K)
c     ht		= scale height for temperature
c     hq		= scale height for specific humidity
c     rhoatm		= density of air at sea surface (g/cm**3)
c     rhoocn		= representative sea surface density
c     esocn		= ocean emissivity times Stefan's constant 
c     vlocn		= latent heat of vaporization of water
c     socn		= constant ocean salinity
c     cdice 		= drag coefficient (dimensionless)
c     rhoice		= ice density (g/cm**3)
c     esice		= ice emissivity times Stefan's constant 
c     slice		= latent heat of sublimation of ice
c     flice		= latent heat of fusion of ice (cm**2/s**2)
c     condice		= ice conductivity (g*cm/s**3/K)
c     kadv		= time step divider for ice advection
c     ntats		= time step counter for time averaging
c     avetime		= time for averaging fluxes
c     totaltime		= total time for long term averages
c
      logical addflux
c
      common /cembm/ addflux
      common /cembm/ nats, namix, lf, kadv, ntats
      common /cembm/ pyear, dtatm, dts, co2ccn, anthro, co2ccni, co2yri
     &,              co2ccnf, co2yrf, solarconst, ssp, cdatm, cpatm, ht
     &,              hq, rhoatm, rhoocn, esocn, vlocn, socn, cdice
     &,              rhoice, esice, slice, flice, condice, avetime 
     &,              totaltime
c
c
c
      logical done
c
      pir = pi/180.0
      pirr = pir/3600.0
      step = 360.0/365.25
      test = 1.0e-4
      xod = 23.320556
      xop = 3.392506
      prm = 50.439273
c                                        
c     eccentricity                                       
c       
c     number of terms to keep for expansion solution of eccentricity
      do i=1,nef
        be(i) = ye(i)*pirr
        ce(i) = ze(i)*pir
      enddo
c
c     obliquity relative to mean ecliptic of date
c   
c     number of terms to keep for expansion solution of obliquity
      do i=1,nob
        bob(i) = yob(i)*pirr
        cob(i) = zob(i)*pir
      enddo
c
c     general precession in longitude
c
c     number of terms to keep in series expansion of solution of 
c     general precession
      do i=1,nop
        bop(i) = yop(i)*pirr
        cop(i) = zop(i)*pir
      enddo
c
c     Berger's solution is referenced to 1950.
c     convert t such that zero is referenced about calendar year 0
c
      t = pyear - 1950
c
c-----------------------------------------------------------------------
c      calculate eccentricity (ecc)
c-----------------------------------------------------------------------
c
      xes = 0.0
      xec = 0.0
      do i=1, nef
        arg = be(i)*t + ce(i)
        xes = xes + ae(i)*sin(arg)
        xec = xec + ae(i)*cos(arg)
      enddo
c
      ecc = sqrt(xes*xes + xec*xec)
c
c-----------------------------------------------------------------------
c     calculate precession (pre)
c-----------------------------------------------------------------------
c
      if (abs(xec) .gt. 1.0e-08) then
        rp = atan(xes/xec)
        if (xec .lt. 0.0) rp = rp + pi
        if (xec .gt. 0.0 .and. xes .lt. 0.0) rp = rp + 2.0*pi
      else
        if (xes .lt. 0.0) rp = 1.5*pi
        if (xes .eq. 0.0) rp = 0.0
        if (xes .gt. 0.0) rp = pi/2.0
      endif
      perh = rp/pir
c
      prg = prm*t
      do i=1, nop
        arg = bop(i)*t + cop(i)
        prg = prg + aop(i)*sin(arg)
      enddo
      prg = (prg/3600.0) + xop
      perh = perh + prg
      if (abs(perh) .gt. 360.) perh = perh-float(int(perh/360.0))*360.0
      if (perh .lt. 0.0) perh = perh + 360.0
c
      pre = ecc*sin(perh*pir)
c
c-----------------------------------------------------------------------
c     calculate obliquity (xob)
c-----------------------------------------------------------------------
c
      xob = xod
      do i=1,nob
        arg = bob(i)*t + cob(i)
        xob = xob+aob(i)/3600.0*cos(arg)
      enddo
c
c-----------------------------------------------------------------------
c     write summary
c-----------------------------------------------------------------------
c
      write(stdout,*) 
      write(stdout,*) 'Insolation parameters'
      write(stdout,*) 'year = ', t + 1950, '(not always model year)'
      write(stdout,*) 'eccentricity = ', ecc
      write(stdout,*) 'obliquity = ', xob
      write(stdout,*) 'precession factor = ', perh+180.0
      write(stdout,*) 'precession = ', pre

c
	return
	end

c=======================================================================
c
c   old iomngr module:  see subroutine print_iomngr_description below
c
c     The following iomngr define options may be selected:
c
c     stand-alone test of iomngr
c #define test_iomngr
c     print description of iomngr features and their use
c #define print_iomngr_description
c     generate "io_history" file showing i/o file use
c #define io_history
c     print record of calls to getunit and relunit, etc.
c #define verbose_iomngr
c     [cray_ymp only:] print "assign" system calls made by getunit
c #define show_assigns
c     print cray_ymp debugging information about file attributes
c #define debug_iomngr
c     print more detailed debugging information
c #define debug_iomngr2

c=======================================================================












      subroutine ioinit
c
c=======================================================================
c     Ioinit initializes logical array "inuse" to show which i/o units
c     are available to the subroutine getunitnumber.  It also
c     initializes the array fname of file names associated with each
c     i/o unit, and opens a file "iohistory", if enabled.
c
c     author c. h. goldberg          e-mail: chg@gfdl.gov
c=======================================================================
c
c====================== include file "iomngr.h"=========================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c   arrays:
c     inuse        = does iomngr know unit number is currently in use
c     hide_file    = file which because of system quirks should not
c                    be closed by relunit
c     scratch_file = file should be deleted when released
c     unix_name    = file known to 1 by name [exceptions: cray_ymp
c                    "word" and "sdsalloc" files]
c     ifile        = index into fname array corresponding to unit number
c     fname        = list of file names used since ioinit
c     iunit        = unit number corresponding to file name
c   scalars:
c     iohist       = unit number of io_history file
c     nfiles       = number of files names used so far
c
      parameter (maxunit = 99, maxfilenames = 200)
      logical inuse, hide_file, scratch_file, unix_name
      character * 64 fname
      common /iomngrl/ inuse(1:maxunit), hide_file(0:maxfilenames)
      common /iomngrl/ scratch_file(1:maxunit), unix_name(1:maxunit)
      common /iomngri/ ifile(1:maxunit)
      common /iomngrc/ fname(0:maxfilenames)
      common /iomngri/ iunit(0:maxfilenames), iohist, nfiles
c


      parameter (last_reserved_unit=0)
c

      print '(a)'
     &, 'WARNING:  This i/o manager has been tested extensively only'
     &, '          on the Cray YMP and Silicon Graphics Personal Iris'
     &, '          and Indigo computers.  If you are using one of these'
     &, '          you must enable the -Dcray_ymp or -Dsgi or'
     &, '          -Dcray_t3d or -Daix define options for proper'
     &, '          execution.'
     &, ' '
     &, '          If you are not using one of these computers, there'
     &, '          are generic choices made in the i/o manager. However'
     &, '          certain aspects of Fortran I/O such as size units'
     &, '          for record lengths in direct access are not'
     &, '          standardized, and others such as INQUIRE and APPEND'
     &, '          do not become standard until Fortran 90, although'
     &, '          they appear as possibly not standard-conforming'
     &, '          extensions in many Fortran compilers.'
     &, ' '
     &, '          Also, there are options in MOM to use high'
     &, '          performance features of vendor-specific I/O on'
     &, '          computers available to the developers.'
     &, ' '
     &, '          If there are no I/O problems running MOM on your'
     &, '          computer, please add its name to the cpp test'
     &, '          that surpresses this message and error stop.'
     &, '          We suggest running the stand-alone driver for the'
     &, '          i/o manager and other test programs designed to'
     &, '          exercise the specific i/o options you are using.'
     &, '          Pay particular attention to record and file sizes'
     &, '          and to record blocking on your system.'
c      stop '==>iomngr'

      do i=0,maxfilenames
        hide_file(i) = .false.
        iunit(i) = 0
        fname(i) = ' '
      end do
c
      fname(0) = ' '
      fname(1) = 'reserved'
      nfiles = 1
c
c     reserve units 1..last_reserved_unit (making them not available)
c             units last_reserved_unit+1..maxunit=99 are available
c
c     unnecessary assignment to avoid WARNING on sgi f77 compiler
      last_reserved = last_reserved_unit
c
      do i=1,last_reserved
        inuse(i) = .true.
        ifile(i) = 1
        scratch_file(i) = .false.
        unix_name(i) = .true.
      end do
      do i=last_reserved_unit+1,maxunit
        inuse(i) = .false.
        ifile(i) = 0
        scratch_file(i) = .false.
        unix_name(i) = .true.
      end do
c
c     reserve units 5 and 6, whether or not they are stdin/stdout
c
      inuse(5) = .true.
      inuse(6) = .true.
      ifile(5) = 1
      ifile(6) = 1
c
c     reserve standard i/o files:  stdin, stdout, stderr
c
      call link_unit (stdin, 'stdin')
      call link_unit (stdout, 'stdout')
      if (stderr .ne. stdout) then
        call link_unit (stderr, 'stderr')
      else
        fname(ifile(stdout)) = 'stdout/stderr'
      end if
c




c
      return
      end



      subroutine getunitnumber (iounit)
c
c=======================================================================
c     getunitnumber assigns a Fortran i/o unit number that does not
c     conflict with any i/o unit currently in use.
c
c     comments:
c
c     see relunit which releases a Fortran i/o unit number.
c
c     author c. h. goldberg          e-mail: chg@gfdl.gov
c=======================================================================
c
c====================== include file "iomngr.h"=========================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c   arrays:
c     inuse        = does iomngr know unit number is currently in use
c     hide_file    = file which because of system quirks should not
c                    be closed by relunit
c     scratch_file = file should be deleted when released
c     unix_name    = file known to 1 by name [exceptions: cray_ymp
c                    "word" and "sdsalloc" files]
c     ifile        = index into fname array corresponding to unit number
c     fname        = list of file names used since ioinit
c     iunit        = unit number corresponding to file name
c   scalars:
c     iohist       = unit number of io_history file
c     nfiles       = number of files names used so far
c
      parameter (maxunit = 99, maxfilenames = 200)
      logical inuse, hide_file, scratch_file, unix_name
      character * 64 fname
      common /iomngrl/ inuse(1:maxunit), hide_file(0:maxfilenames)
      common /iomngrl/ scratch_file(1:maxunit), unix_name(1:maxunit)
      common /iomngri/ ifile(1:maxunit)
      common /iomngrc/ fname(0:maxfilenames)
      common /iomngri/ iunit(0:maxfilenames), iohist, nfiles
c



      character * 2 aiounit
      logical       exists,named
      character * 64 name
      character * 64 string

      do i = 1,maxunit

        if (.NOT. inuse(i)) then
          inquire(i,EXIST=exists,NAMED=named,NAME=name)

c
c         A unit opened, even without the knowledge of Getunit will
c         still be NAMED.  Getunit skips over it.
c

          if (.NOT. named) then

c
c           Cray ymp: (5/94) (Unicos 7.x, cf77)
c           A unit given a file name in an "assign -a filename"
c           statement in the Unix script, but not yet opened by a
c           Fortran open statement will inquire as ".NOT. NAMED",
c           but in an attempted open of the unit with a different name,
c           IOSTAT will return error value 1062.  Such units should
c           not be used.
c           Note:  this test does no harm in sgi Fortran (5/94).
c

            open (i,FILE='dummy',IOSTAT=iostat)

c

            if (iostat .EQ. 0) then
              close (i)
              goto 101
            end if

          end if

        end if
      end do
c
c     "Normal" termination of the do loop indicates all units are in use
c
      write (stdout, '(a4)')
     &    'ERROR:  No i/o units available -- Execution terminated'
      call showunits
      stop '==>Getunit'
c
  101 continue
      iounit = i
      inuse(i) = .true.
c


      return
      end


      subroutine getunit (iounit, filename, optionlist)
c
c=======================================================================
c     getunit gets an unused Fortran unit number, assigns it to the
c     dummy argument iounit, and opens it with FILE=filename and options
c     given in optionlist.  Enable cpp directive "print_io_description"
c     to see the list of options.
c
c     author c. h. goldberg          e-mail: chg@gfdl.gov
c=======================================================================
c
c====================== include file "iomngr.h"=========================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c   arrays:
c     inuse        = does iomngr know unit number is currently in use
c     hide_file    = file which because of system quirks should not
c                    be closed by relunit
c     scratch_file = file should be deleted when released
c     unix_name    = file known to 1 by name [exceptions: cray_ymp
c                    "word" and "sdsalloc" files]
c     ifile        = index into fname array corresponding to unit number
c     fname        = list of file names used since ioinit
c     iunit        = unit number corresponding to file name
c   scalars:
c     iohist       = unit number of io_history file
c     nfiles       = number of files names used so far
c
      parameter (maxunit = 99, maxfilenames = 200)
      logical inuse, hide_file, scratch_file, unix_name
      character * 64 fname
      common /iomngrl/ inuse(1:maxunit), hide_file(0:maxfilenames)
      common /iomngrl/ scratch_file(1:maxunit), unix_name(1:maxunit)
      common /iomngri/ ifile(1:maxunit)
      common /iomngrc/ fname(0:maxfilenames)
      common /iomngri/ iunit(0:maxfilenames), iohist, nfiles
c



c
      character * (*) filename, optionlist
      character * 160 options
      character * 2 aiounit
      character * 160 string
      character * 15 ssequential, sdirect
      character * 15 sformatted, sunformatted
      character * 15 srewind, sappend
      character * 15 sread, swrite, sreadwrite, sunknown, sold, snew
      character * 15 sstatus, saccess, sform, sposition, saction
      character * 15 sieee, srec_len, sdummy, sbyte, sword, sblock
      character * 15 sbuffer, sblocking, psblocking, snumeric, snum
      character * 15 ssave, sovfl
      character * 15 sffio, snamelist
      character * 40 slayer
      dimension slayer(6)
      logical scan_option, scan_number, scan_size, exists, named
      integer sdsalloc, errors
      logical skip_open

      data ssequential  /'SEQUENTIAL'/
      data sdirect      /'DIRECT'/
      data sformatted   /'FORMATTED'/
      data sunformatted /'UNFORMATTED'/
      data srewind      /'REWIND'/
      data sappend      /'APPEND'/
      data sread        /'READ'/
      data swrite       /'WRITE'/
      data sreadwrite   /'READWRITE'/
      data sunknown     /'UNKNOWN'/
      data sold         /'OLD'/
      data snew         /'NEW'/
c
c     set default file attributes
c
      saccess     = ssequential
      sform       = ' '
      sposition   = srewind
      saction     = sreadwrite
      sstatus     = sunknown
      sblocking   = ' '
      psblocking  = ' '
      sieee       = ' '
      snumeric    = ' '
      ssave       = 'save'
      sovfl       = 'novfl'
      irec_len    = 0
      iblock      = 0
      iword       = 0
      ibyte       = 0
      inum        = 0
      ibuffer     = 0
      maxsize     = 0
      layer       = 0
      sffio       = ' '
      snamelist   = ' '
c
c     convert options list to lowercase
c
      options = optionlist
      call tolower (options)

c
c     decode options:
c
      i = 1
      errors = 0
100   continue
      if (i .gt. len_trim(options)) go to 101
c
c       scan options by full names
c
        if     (scan_option(options, i,
     &          'sequential', saccess, ssequential)) then
        else if(scan_option(options, i,
     &          'direct', saccess, sdirect)) then
          if(scan_option(options, i, 'recl', sdummy, sdummy)) then
          end if
          if(scan_size(options, i, irec_len, iblock, iword, ibyte)) then
          end if
          call setreclen (irec_len,srec_len,sform,iblock,iword,ibyte)
          if (irec_len .eq. 0) then
            print '(a,a,/,a,a)',
     &         '=>ERROR in getunit options list:',
     &         ' ''direct'' requires a record length',
     &         ' options=',options
            errors = errors + 1
          end if
        else if(scan_option(options, i, 'recl', sdummy, sdummy)) then
          if(scan_size(options, i, irec_len, iblock, iword, ibyte)) then
          end if
          call setreclen (irec_len,srec_len,sform,iblock,iword,ibyte)
          if (irec_len .eq. 0) then
            print '(a,a,/,a,a)',
     &         '=>ERROR in getunit options list:',
     &         ' ''recl='' requires a record length',
     &         ' options=',options
            errors = errors + 1
          end if
        else if(scan_option(options, i,
     &          'formatted', sform, sformatted)) then
        else if(scan_option(options, i,
     &          'unformatted', sform, sunformatted)) then
        else if(scan_option(options, i,
     &          'readwrite', saction, sreadwrite)) then
        else if(scan_option(options, i,
     &          'read', saction, sread)) then
          if (scan_option(options, i, 'only', sdummy, sdummy)) then
          end if
          print '(a,a)', 'WARNING:  ACTION=''read'' not supported.  ',
     &                            'ACTION=''READWRITE'' is used.'
        else if(scan_option(options, i,
     &          'write', saction, swrite)) then
          if (scan_option(options, i, 'only', sdummy, sdummy)) then
          end if
          print '(a,a)', 'WARNING:  ACTION=''write'' not supported.  ',
     &                            'ACTION=''READWRITE'' is used.'
        else if(scan_option(options, i,
     &          'rewind', sposition, srewind)) then
        else if(scan_option(options, i,
     &          'append', sposition, sappend)) then

        else if(scan_option(options, i, 'ieee', sieee, 'ieee')) then


        else if(scan_option(options, i, 'f77namelist',
     &          snamelist, 'f77')) then
c
c       scan for blocking options
c
        else if(scan_option(options, i, 'fortran',
     &          sblocking, 'f77')) then
        else if(scan_option(options, i, 'f77',
     &          sblocking, 'f77')) then
        else if(scan_option(options, i, 'stream',
     &          sblocking, 'null')) then
        else if(scan_option(options, i, 'unblocked',
     &          sblocking, 'null')) then
        else if(scan_option(options, i, 'null',
     &          sblocking, 'null')) then

c
c       the 'buffer' option is parsed, but ignored on many systems
c       f77 blocking is assumed
c
        else if(scan_option(options, i, 'buffer', sdummy, sdummy)) then
c
c         force new_layer to recognize f77 blocking
c
          sblocking = 'f77'
          if (scan_size(options, i, ibuffer, iblock, iword, ibyte)) then
          end if
c         why assume that buffers are in bytes?   f77 buffer units=bytes.
          call set2byte (ibuffer, iblock, iword, ibyte)
            inum = ibuffer
          if (ibuffer .eq. 0) then
            print '(a,a,/,a,a)',
     &         '=>ERROR in getunit options list:',
     &         ' ''buffer='' requires a size',
     &         ' options=',options
            errors = errors + 1
          end if


c
c       scan options by abbreviated names
c
        else if(scan_option(options, i, 's', saccess, ssequential)) then
        else if(scan_option(options, i, 'd', saccess, sdirect)) then
          if(scan_option(options, i, 'recl', sdummy, sdummy)) then
          end if
          if(scan_size(options, i, irec_len, iblock, iword, ibyte)) then
          end if
          call setreclen (irec_len,srec_len,sform,iblock,iword,ibyte)
          if (irec_len .eq. 0) then
            print '(a,a,/,a,a)',
     &         '=>ERROR in getunit options list:',
     &         ' ''direct'' requires a record length',
     &         ' options=',options
            errors = errors + 1
          end if
        else if(scan_option(options, i, 'f', sform, sformatted)) then
        else if(scan_option(options, i, 'u', sform, sunformatted)) then
        else if(scan_option(options, i, 'rw', saction, sreadwrite)) then
        else if(scan_option(options, i, 'ro', saction, sread)) then
        else if(scan_option(options, i, 'wo', saction, swrite)) then
        else if(scan_option(options, i, 'r', sposition, srewind)) then
        else if(scan_option(options, i, 'a', sposition, sappend)) then

c
c       scan for size options with no introductory keyword
c       the introductory keyword must be several options back
c
        else if(scan_size(options, i, inum, iblock, iword, ibyte)) then
        else
          print '(4a)', '=>ERROR:  Getunit unable to parse options=',
     &                    options(1:i-1), '|',
     &                    options(i:len_trim(options))
          errors = errors + 1
          i = i + 1
        end if

      goto 100
c
c     end of scan loop
c     a do loop is not be used because i is changed within the loop
c
101   continue

      if (errors .gt. 0) then
        print '(/a/a,i3,a)'
     &,   'STOP in getunit'
     &,   'There were',errors,' errors scanning the list of I/O options'
        stop
      end if
c
c     in case neither "formatted" or "unformatted" is specified, choose
c     the proper default for sequential and direct access files.
c
      if (sform .eq. ' ') then
        if (saccess .eq. ssequential) then
          sform = sformatted
        else if (saccess .eq. sdirect) then
          sform = sunformatted
        end if
      end if
c-----------------------------------------------------------------------
c     See if the file has previously been opened in this run
c-----------------------------------------------------------------------
c

c
      do i=1,nfiles

        if (fname(i) .eq. filename) then
          sstatus = sold
          if (iunit(i) .ne. 0) then
c
c           This happens when a call relunit was executed for this file,
c           but due to system bugs, it was necessary to merely hide the
c           file while keeping it connected to a unit to permit later
c           appending.
c
            iounit = iunit(i)
            ifile(iounit) = i
            inuse(iounit) = .true.
            if (sposition .eq. sappend) then
              skip_open = .true.
            else
c
c             A previously hidden file that is now being opened with
c             POSITION=REWIND.  It should first be closed to permit
c             reading from it.
c

              call close_file (iounit, filename)
              skip_open = .false.
c

            end if
          else
c
c           This file is now closed, but had previously been opened.
c           Get a new unit number and reconnect it.
c
            call getunitnumber (iounit)
            ifile(iounit) = i
            iunit(i) = iounit
c
c           STATUS=UNKNOWN may cause rewind on some computers.
c           This is incompatible with append
c
            if (sposition .eq. sappend) then
              sstatus = sold
            end if
            skip_open = .false.

          end if
          go to 201
        end if
      end do
c
c
c     This file has not previously been opened in this run.
c
c     Get a free unit number and bind it to the file
c     unless the request is 'sdsalloc' which does not
c     use a true i/o unit number.
c
      if (saccess .ne. 'sdsalloc') then
        call getunitnumber (iounit)
        call link_unit (iounit, filename)
        if (sposition .eq. sappend) then
c
c         If file pre-exists, append to it, but if no such file
c         exists, open a new file and rewind it.
c
          inquire (FILE=fname(nfiles), EXIST=exists, NAMED=named)

          if (.not. exists .or. .not. named) then

            sstatus = snew
            sposition = srewind
          else

            sstatus = sold
          end if


        end if
      end if
      skip_open = .false.
c
201   continue

c

c-----------------------------------------------------------------------
c
c-----------------------------------------------------------------------

      write (aiounit,'(i2)') iounit

c
c-----------------------------------------------------------------------
c


c
c     set implied file attributes corresponding to 'stream' options.
c




c-----------------------------------------------------------------------
c
c     select open statement compatible with options and computer platform
c
c-----------------------------------------------------------------------
      if (skip_open) then
        goto 301
      end if

      if (saccess .eq. ssequential .or. saccess .eq. sappend) then
c
c       some compilers may allow a record length specifier for
c       sequential access files.  iomngr supports this possibility
c
        if (irec_len .eq. 0) then
        open (iounit,
     &        FILE=filename,
     &        FORM=sform,
     &        ACCESS=saccess,
     &        STATUS=sstatus

c martin
c     &,       POSITION=sposition


     &        )
        else
        open (iounit,
     &        FILE=filename,
     &        FORM=sform,
     &        ACCESS=saccess,
     &        STATUS=sstatus

c martin
c     &,       POSITION=sposition

     &,       RECL=irec_len
     &        )
        end if
        unix_name(iounit) = .true.
      else if (saccess .eq. sdirect) then
        open (iounit,
     &        FILE=filename,
     &        FORM=sform,
     &        ACCESS=saccess,
     &        RECL=irec_len,
     &        STATUS=sstatus
     &        )
c        unix_name(iounit) = .true.
        unix_name(iounit) = .false.

      end if
c
301   continue

c


c
      return
      end



      subroutine relunit (iounit)
c
c=======================================================================
c     Relunit releases a Fortran i/o unit number currently in use and
c     closes the file.
c     see Getunit which gets a Fortran i/o unit number.
c
c     author c. h. goldberg          e-mail: chg@gfdl.gov
c=======================================================================
c
c====================== include file "iomngr.h"=========================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c   arrays:
c     inuse        = does iomngr know unit number is currently in use
c     hide_file    = file which because of system quirks should not
c                    be closed by relunit
c     scratch_file = file should be deleted when released
c     unix_name    = file known to 1 by name [exceptions: cray_ymp
c                    "word" and "sdsalloc" files]
c     ifile        = index into fname array corresponding to unit number
c     fname        = list of file names used since ioinit
c     iunit        = unit number corresponding to file name
c   scalars:
c     iohist       = unit number of io_history file
c     nfiles       = number of files names used so far
c
      parameter (maxunit = 99, maxfilenames = 200)
      logical inuse, hide_file, scratch_file, unix_name
      character * 64 fname
      common /iomngrl/ inuse(1:maxunit), hide_file(0:maxfilenames)
      common /iomngrl/ scratch_file(1:maxunit), unix_name(1:maxunit)
      common /iomngri/ ifile(1:maxunit)
      common /iomngrc/ fname(0:maxfilenames)
      common /iomngri/ iunit(0:maxfilenames), iohist, nfiles
c



      character * 2 aiounit
c

c
      ifn = ifile(iounit)


c
      if (iounit .ge. 1 .and. iounit .le. maxunit) then
        inuse(iounit) = .false.
        if (.not. hide_file(ifn) .and. unix_name(iounit)) then

          call close_file (iounit, fname(ifn))
          iunit(ifn) = 0
        end if
        ifile(iounit) = 0
      else
        print *,'=>ERROR: iounit is bad. iounit=',iounit
        stop 'relunit'
      endif

      return
      end



      subroutine release_all

c=======================================================================
c
c     Releases all user i/o units currently in use and their file names.
c     All files except stdin, stdout, and stderr are closed.
c     Hidden files are closed at this time.
c
c     Ater a call to release_all, it is safe to execute a sectiion of
c     code that does not use the iomngr to allocate units.

c
c=======================================================================

c====================== include file "iomngr.h"=========================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c   arrays:
c     inuse        = does iomngr know unit number is currently in use
c     hide_file    = file which because of system quirks should not
c                    be closed by relunit
c     scratch_file = file should be deleted when released
c     unix_name    = file known to 1 by name [exceptions: cray_ymp
c                    "word" and "sdsalloc" files]
c     ifile        = index into fname array corresponding to unit number
c     fname        = list of file names used since ioinit
c     iunit        = unit number corresponding to file name
c   scalars:
c     iohist       = unit number of io_history file
c     nfiles       = number of files names used so far
c
      parameter (maxunit = 99, maxfilenames = 200)
      logical inuse, hide_file, scratch_file, unix_name
      character * 64 fname
      common /iomngrl/ inuse(1:maxunit), hide_file(0:maxfilenames)
      common /iomngrl/ scratch_file(1:maxunit), unix_name(1:maxunit)
      common /iomngri/ ifile(1:maxunit)
      common /iomngrc/ fname(0:maxfilenames)
      common /iomngri/ iunit(0:maxfilenames), iohist, nfiles
c



      logical exists
      character *160 string, oldfname
c

c
      do ifn=1,nfiles
        if (iunit(ifn) .ne. 0) then
          if ((inuse(iunit(ifn)) .or. hide_file(ifn)) .and.
     &        unix_name(iunit(ifn)) .and.
     &        fname(ifn) .ne. 'reserved' .and.
     &        fname(ifn) .ne. 'stdin' .and.
     &        fname(ifn) .ne. 'stdout' .and.
     &        fname(ifn) .ne. 'stderr' .and.
     &        fname(ifn) .ne. 'stdout/stderr') then

            call close_file (iunit(ifn), fname(ifn))

c
c           mark file as released
c
            inuse(iunit(ifn)) = .false.
            iunit(ifn) = 0
          end if
        end if
      end do


      return
      end


      subroutine close_file (iounit, filename)
c=======================================================================
c
c       close Fortran unit iounit
c

c=======================================================================
c
c

        character *(*) filename
        character * 64 string1, string2
        character * 2 aiounit
c
        close (iounit)

        return
        end







      subroutine showunits

c=======================================================================
c
c     lists all i/o units currently in use and their file names.
c
c=======================================================================

c====================== include file "iomngr.h"=========================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c   arrays:
c     inuse        = does iomngr know unit number is currently in use
c     hide_file    = file which because of system quirks should not
c                    be closed by relunit
c     scratch_file = file should be deleted when released
c     unix_name    = file known to 1 by name [exceptions: cray_ymp
c                    "word" and "sdsalloc" files]
c     ifile        = index into fname array corresponding to unit number
c     fname        = list of file names used since ioinit
c     iunit        = unit number corresponding to file name
c   scalars:
c     iohist       = unit number of io_history file
c     nfiles       = number of files names used so far
c
      parameter (maxunit = 99, maxfilenames = 200)
      logical inuse, hide_file, scratch_file, unix_name
      character * 64 fname
      common /iomngrl/ inuse(1:maxunit), hide_file(0:maxfilenames)
      common /iomngrl/ scratch_file(1:maxunit), unix_name(1:maxunit)
      common /iomngri/ ifile(1:maxunit)
      common /iomngrc/ fname(0:maxfilenames)
      common /iomngri/ iunit(0:maxfilenames), iohist, nfiles
c




      write(stdout, '(/,a,/)') 'i/o units in use'
      write(stdout, '(a5,tr1,a,tr1,a)') ' unit', 'hidden', 'file name'
      do i=1,maxunit
        if (inuse(i)) then
          write(stdout, '(i4,tr3,l2,tr4,a)')
     &              i, hide_file(ifile(i)),
     &              fname(ifile(i))(1:len_trim(fname(ifile(i))))
        end if
      end do


      return
      end
c=======================================================================


      subroutine showfiles

c=======================================================================
c
c     lists all file names that have been used [in chronological order]
c
c=======================================================================

c====================== include file "iomngr.h"=========================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c   arrays:
c     inuse        = does iomngr know unit number is currently in use
c     hide_file    = file which because of system quirks should not
c                    be closed by relunit
c     scratch_file = file should be deleted when released
c     unix_name    = file known to 1 by name [exceptions: cray_ymp
c                    "word" and "sdsalloc" files]
c     ifile        = index into fname array corresponding to unit number
c     fname        = list of file names used since ioinit
c     iunit        = unit number corresponding to file name
c   scalars:
c     iohist       = unit number of io_history file
c     nfiles       = number of files names used so far
c
      parameter (maxunit = 99, maxfilenames = 200)
      logical inuse, hide_file, scratch_file, unix_name
      character * 64 fname
      common /iomngrl/ inuse(1:maxunit), hide_file(0:maxfilenames)
      common /iomngrl/ scratch_file(1:maxunit), unix_name(1:maxunit)
      common /iomngri/ ifile(1:maxunit)
      common /iomngrc/ fname(0:maxfilenames)
      common /iomngri/ iunit(0:maxfilenames), iohist, nfiles
c




      write(stdout, '(/,a,/)') '  Files Used in This Run'
      write(stdout, '(a5,tr1,a,tr1,a)') '     ', 'hidden', 'file name'
      do i=1,nfiles
        write(stdout, '(i4,tr3,l2,tr4,a)')
     &            i, hide_file(i),
     &              fname(i)(1:len_trim(fname(i)))
      end do


      return
      end
c=======================================================================

      subroutine link_unit (iounit, filename)

c=======================================================================
c     links an i/o unit number to a new file name
c-----------------------------------------------------------------------

c====================== include file "iomngr.h"=========================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c   arrays:
c     inuse        = does iomngr know unit number is currently in use
c     hide_file    = file which because of system quirks should not
c                    be closed by relunit
c     scratch_file = file should be deleted when released
c     unix_name    = file known to 1 by name [exceptions: cray_ymp
c                    "word" and "sdsalloc" files]
c     ifile        = index into fname array corresponding to unit number
c     fname        = list of file names used since ioinit
c     iunit        = unit number corresponding to file name
c   scalars:
c     iohist       = unit number of io_history file
c     nfiles       = number of files names used so far
c
      parameter (maxunit = 99, maxfilenames = 200)
      logical inuse, hide_file, scratch_file, unix_name
      character * 64 fname
      common /iomngrl/ inuse(1:maxunit), hide_file(0:maxfilenames)
      common /iomngrl/ scratch_file(1:maxunit), unix_name(1:maxunit)
      common /iomngri/ ifile(1:maxunit)
      common /iomngrc/ fname(0:maxfilenames)
      common /iomngri/ iunit(0:maxfilenames), iohist, nfiles
c



      character * (*) filename

      nfiles = nfiles + 1
      inuse(iounit) = .true.
      fname(nfiles) = filename
      ifile(iounit) = nfiles
      iunit(nfiles) = iounit
c
      return
      end

c=======================================================================

      subroutine setreclen (irec_len,srec_len,sform,iblock,iword,ibyte)

c-----------------------------------------------------------------------
c     calculates record length for direct access files
c-----------------------------------------------------------------------
      character *(*) srec_len, sform
      character *15 sformatted
      data sformatted   /'FORMATTED'/
c




      if (sform .eq. sformatted) then
        call set2byte (irec_len, iblock, iword, ibyte)
      else
        call set2word (irec_len, iblock, iword, ibyte)
      end if



      call i2a(irec_len, srec_len)
c
      return
      end

c=======================================================================

      subroutine set2byte (inum, iblock, iword, ibyte)

c-----------------------------------------------------------------------
c     if first argument is zero, sets first argument to value in bytes
c-----------------------------------------------------------------------
      if (inum .eq. 0) then
        if (ibyte .ne. 0) then
          inum = ibyte
        else if (iword .ne. 0) then


          inum = 4 * iword



        end if
      end if

      return
      end

c=======================================================================

      subroutine set2word (inum, iblock, iword, ibyte)

c-----------------------------------------------------------------------
c     if first argument is zero, sets first argument to value in bytes
c-----------------------------------------------------------------------
      if (inum .eq. 0) then
        if (ibyte .ne. 0) then


          inum = 1 + (ibyte - 1) / 4


        else if (iword .ne. 0) then
          inum = iword

        end if
      end if

      return
      end


c=======================================================================
      subroutine tolower (string)

c-----------------------------------------------------------------------
c     converts all alphabetic characters in string to lowercase
c-----------------------------------------------------------------------

      character*(*) string
      character*1 c
      parameter (lcshift=32)

      do i=1,len(string)
        c = string(i:i)
        if ('A' .le. c .and. c .le. 'Z') then
          string(i:i) = char(ichar(c) + lcshift)
        end if
      end do

      return
      end


c=======================================================================

      subroutine i2a (i, a)

      character * (*) a
      character * 15 string

      write (string, '(i15)') i
      do j=1,15
        if (string(j:j) .ne. ' ') go to 101
      end do
101   continue
      a = string(j:)

      return
      end

c=======================================================================

      function scan_option (options, i, spattern, svar, soption)

c-----------------------------------------------------------------------
c     scans the options string for spattern starting at position i.
c     if found, svar is set to soption.
c-----------------------------------------------------------------------

      logical scan_option
      character*(*) options, spattern, svar, soption
      character*1 c

c     skip delimiters

100   continue
      if (i .le. len(options)) then
        c = options(i:i)
        if (c.eq.'=' .or. c.eq.' ' .or. c.eq.',' .or. c.eq.':') then
          i = i + 1
          goto 100
          end if
        end if
c
c     scan for option
c
      scan_option = .false.
      j = i + len_trim(spattern) - 1
      if (j .le. len(options)) then
        if (options(i:j) .eq. spattern) then
          scan_option = .true.
          svar = soption

          i = i + len_trim(spattern)
        end if
      end if

      return
      end

c=======================================================================
c
      function scan_size(options, i, inum, iblock, iword, ibyte)
c
c-----------------------------------------------------------------------
c     scans the options string for a size specification starting at
c     position i.
c     if found, one of inum, iblock, iword, ibyte is nonzero.
c-----------------------------------------------------------------------
      logical scan_size, scan_number, scan_option
      character*(*) options
      character*15 snum, sblock, sword, sbyte, sdummy

c     scan for size options
c
      scan_size = .false.
c
      if(scan_number(options, i, inum, snum)) then
        iblock = 0
        iword = 0
        ibyte = 0
        scan_size = .true.

      else if(scan_option(options, i, 'words', sdummy, sdummy)) then
        if (scan_number(options, i, iword, sword)) then
          inum = 0
          iblock = 0
          ibyte = 0
          scan_size = .true.
        else
          print '(a,a,/,a,a)',
     &       '=>ERROR in getunit options list:',
     &       ' ''words='' requires a size in words',
     &       ' options=',options
        end if
      else if(scan_option(options, i, 'bytes', sdummy, sdummy)) then
        if (scan_number(options, i, ibyte, sbyte)) then
          inum = 0
          iblock = 0
          iword = 0
          scan_size = .true.
        else
          print '(a,a,/,a,a)',
     &       '=>ERROR in getunit options list:',
     &       ' ''bytes='' requires a size in bytes',
     &       ' options=',options
        end if
      end if
c
      return
      end

c=======================================================================
c
      function scan_number (options, i, n, sn)

c-----------------------------------------------------------------------
c     scans the options string for a number starting at position i.
c     if found, n is the number as an integer and sn as a string.
c-----------------------------------------------------------------------

      logical scan_number
      character*(*) options, sn
      character*1 c


c     skip delimiters

100   continue
      if (i .le. len(options)) then
        c = options(i:i)
        if (c.eq.'=' .or. c.eq.' ' .or. c.eq.',' .or. c.eq.':') then
          i = i + 1
          goto 100
        end if
      end if
c
c     scan for digits
c
      if (i .le. len(options)) then
        c = options(i:i)
        if ('0' .le. c .and. c .le. '9') then
          sn = c
          n = ichar(c) - ichar('0')
          scan_number = .true.
200       continue
          i = i + 1
          if (i .le. len(options)) then
            c = options(i:i)
            if ('0' .le. c .and. c .le. '9') then
              sn = sn(1:len_trim(sn)) // c
              n = 10 * n + ichar(c) - ichar('0')
              goto 200
            end if
          end if

        else
          scan_number = .false.
        end if
      end if

      return
      end









      function len_trim (string)
c
c     defines length of "string" ignoring trailing blanks
c
      character * (*) string
      integer len_trim, i
c
      len_trim = 0
      do i = len (string), 1, -1
        if (string(i:i) .NE. ' ') then
          len_trim = i
          goto 999
        end if
      end do
999   continue
c
      return
      end




c martin

      subroutine rivmodel
c
c=======================================================================
c     river model for energy-moisture balance model
c     calculates river runoff from precipitation over land
c     based on code by e.wiebe
c
c     author:   m.eby   e-mail: eby@uvic.ca
c=======================================================================
c

c
      return
      end








      subroutine setembm (dtatmos)
c
c=======================================================================
c     initialize the energy-moisture balance model
c     based on code by a.fanning
c
c     author:   m.eby   e-mail: eby@uvic.ca
c=======================================================================
c

c====================== include file "param.h" =========================
c
c     main parameter file which sets ocean characteristics:
c
c     "size.h" sets model size "imt", "jmt", and "km"
c
c====================== include file "size.h" ==========================
c                                                                       
c-----------------------------------------------------------------------
c     USER INPUT: 
c-----------------------------------------------------------------------
c
c     imt    = number of grid points in the longitudinal direction
c              (calculated points are from 2 through imt-1. End points
c               are boundaries)          
c
c     jmt    = number of grid points (latitude rows) in the latitudinal
c              direction (calculated points are from 2 through jmt-1.           
c              End points are boundaries)   
c                                
c     km     = number of grid points in the vertical direction          
c              (calculated points are from 1 through km)
c
c     nt     = number of tracers (temperature, salinity, ...)
c
c     mnisle = maximum number of islands (unconnected land masses)
c
c     maxipp = maximum number of all island perimeter points
c-----------------------------------------------------------------------
c                                                                       
      parameter (imt=  92, jmt=  61, km= 15)
      parameter (nt=2)
      parameter (nat=2)
      parameter (mnisle=50, maxipp=5000)
c

c






c
c-----------------------------------------------------------------------
c     END USER INPUT
c-----------------------------------------------------------------------
c                                                                       
c-----------------------------------------------------------------------
c     By default, the MW (memory window) is 2nd order except for the
c     following options which require a 4th order MW 
c
c     for 2nd order schemes, the minimum sized MW is 3 latitude rows
c     for 4th order schemes, the minimum sized MW is 4 latitude rows
c                            (5 if using coarse_grained_parallelism)
c-----------------------------------------------------------------------
c













c
c-----------------------------------------------------------------------
c     set MW (memory window) size "jmw" 
c-----------------------------------------------------------------------
c                                                                       

c
c     for UNI-TASKING: "jmw" is set to the minimum for each option class 
c     "jmw" may be increased up to "jmt" 
c

      parameter (jmw=jmt)


c
c-----------------------------------------------------------------------
c     set first and last calculated row within the MW. other rows
c     are used as buffers
c-----------------------------------------------------------------------
c
c     jsmw   = 1st calculated row within the MW     
c     jemw   = last calculated row within the MW
c
      parameter (jsmw=2, jemw=jmw-1)
c
c
c     jextra = extra buffer rows needed for coarse_grained_parallelism.
c              "jextra" rows are added to the top and bottom of the MW
c              so the MW size increases by 2*jextra       
c

          parameter (jextra = 0)




c
c     nvar   = number of prognostic variables
c     lseg   = maximum number of longitudinal stream function segments
c     nlatpr = maximum number of latitudes for matrix printouts
c              on diagnostic time steps
c     nhreg  = number of regions in the horizontal used for averaging
c              tracers.
c     nvreg  = number of regions in the vertical used for term balance
c              calculations. note "nvreg" isn`t used for tracer averages
c     numreg = total number of regions ( = product of nhreg & nvreg)
c              used for term balance calculations
c
      parameter (lseg=5, nlatpr=10)

      parameter (nhreg=5, nvreg=2, numreg=nhreg*nvreg)

      parameter (nvar=nt+2)
c

c
      parameter (imtm1=imt-1, kmm1=km-1)                                
      parameter (imtp1=imt+1, imtm2=imt-2
     &,          jmtp1=jmt+1, jmtm1=jmt-1, jmtm2=jmt-2

     &,          jscan=jmtm2

     &,          kmp1=km+1, kmp2=km+2
     &,          imtkm=imt*km, nwds=imt*jmt, nkflds=2
     &,          nslab=imt*nvar*km, ntmin2=nt+1/nt)
c
c     include parameter constants
c
c====================== include file "pconst.h" ========================
c
c
c     rules for parameter constants
c
c     use prefix of "c" for whole real numbers (eg: c57 for 57.0)
c     use "m" after prefix to designate negative values (minus sign)
c       (eg: cm7 for -7.0)
c     use prefix of "p" for non repeating fractions (eg: p5 for 0.5)
c     use prefix of "r" for reciprocals (eg: r3 for 1/3.0)
c     combine use of prefix above and "e" for scientific notation, with
c       (eg: c5e4 for 5.0e4, c1em10 for 1.0e-10)
c
      parameter (c0=0.0, c1=1.0, c2=2.0, c3=3.0, c4=4.0, c5=5.0, c7=7.0)
      parameter (c8=8.0)
      parameter (c14=14.0, c16=16.0, c360=360.0)
      parameter (p125=0.125, p25=0.25, p5=0.5, p75=0.75)
      parameter (epsln=1.0e-20)
c
      parameter (c24=24.0, c60=60.0, c1440=1440.0)
      parameter (r24=c1/c24, r60=c1/c60, r1440=c1/c1440)
      parameter (secday=c1/(c60*c1440))
c
c     include standard I/O units
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c
c     ncrows = number of calculated rows within the MW.
c              (the remaining rows are buffer rows). 
c


      parameter (ncrows = jmw - 2)


c====================== include file "slap.h" ==========================
c
c     variables needed for the energy balance model solution technique
c
c     5-point stencil
c     max number non-zeros: total, upper and lower triangles (with diag)
c
      parameter  (maxnelt = (jmt+2)*(3*imt) + 2*(imt+2)*(jmt+1))
      parameter  (maxneltu = 3*(jmt+2)*(imt+2) - imt - jmt)
      parameter  (maxneltl = maxneltu)
c
c     number direction vectors to orthogonalize against
c
      parameter  (nsave = 10)
c
c     work space
c
      parameter  (lenw = 1 + (imt)*(jmt)*(nsave+7) + 
     &	         nsave*(nsave+3) + maxneltu + maxneltl)
      parameter  (leniw =  (imt)*(jmt)*4+maxneltu + maxneltl + 32)
      real       rwork(lenw)
      integer    iwork(leniw)
c
c     the tracer matrix
c
      integer    slapia(maxnelt,2,nat), slapja(maxnelt,2,nat)
      integer    nelt, orda
c
      real       slapam(maxnelt,2,nat), slaprhs(imt*jmt,nat)
      real       slaplhs(imt*jmt,nat), sltol(nat)
c
      common /slapmats/ slapia, slapja, nelt, orda
     &,	                slapam, slaprhs, slaplhs, sltol
c
c     index maps
c
      integer    indexgrid(imt,jmt), gridrow(imt*jmt)
      integer    gridcol(imt*jmt)
c
      common /slapmaps/ indexgrid, gridrow, gridcol
c
c====================== include file "switch.h" ========================
c
c     all time dependent decisions are made by time manager "tmngr.F"
c     and communicated elsewhere to the model via logical switches.
c
c     inputs: (defaulted in "blkdta.F", optionally reset via namelist)
c
c
c     runlen  = integration period (see rununits). note "runlen" should
c               be an integral number of density time steps. if not,
c               then "runlen" is automatically adjusted to insure this.
c               fractional days are supported but not fractional months
c               or years.
c     rununits= units of "runlen". may be "days", "months", or "years".
c               tmngr will convert "runlen" which is in "rununits"
c               to "rundays" in units of days.
c
c     segtim  = the integration time "runlen" is broken into a number of
c               segments each of length "segtim" days. updated surface
c               boundary conditions are applied to MOM every "segtim" 
c               days. this is useful when coupling to atmospheric models
c               in which case both models exchange surface boundary
c               conditions every "segtim" days where "segtim"
c               is 1/(coupling frequency). without an atmospheric model,
c               when getting surface boundary conditions from data, 
c               "segtim" is set to the time step (in days) by mom.F. in
c               either case, "runlen" (in days) should be an integral
c               number of "segtim".     
c
c     nmix    = number of time steps between mixing timesteps. used
c               to damp timestep splitting due to centered leapfrog.
c
c     init    = (true,false)  indicates that this run is a
c               (start from initial conditions, restart)
c
c     restrt  = (true,false) = (do,don`t) write a restart at the end
c               of the run
c
c     eb      = (true,false) configures for the use of a 
c               (euler backward,forward) type mixing timestep
c
c-----------------------------------------------------------------------
c     inputs to tmngr.F: diagnostic intervals
c-----------------------------------------------------------------------
c
c     note: switches are used to control the interval between doing
c           diagnostics. units for all switches are in days. 
c           setting a switch < 0.0 disables whatever the switch is 
c           controlling. setting it = 0.0 causes the diagnostic to be 
c           done every time step, and setting it > 0.0 causes the 
c           diagnostic to be done repeatedly on the specified interval. 
c
c     cmixint = number of days between writing estimated mixing coeffs
c               on faces of T cells and U cells
c
c     crossint = number of days between writing diapycnal and isopycnal
c               components of flow
c
c     fctint = number of days between writing difference between 
c              FCT and leapfrog advection
c
c     densityint = number of days between writing density
c
c     exconvint = number of days between writing temperature rate of
c                 change due to explicit convection
c
c     glenint =  number of days between global energetics integrals.
c
c     trmbint =  number of days between momentum and tracer term
c                balances (global and regional).
c
c     itrmb   = (true,false) = (do,don`t) write regional mask info for
c               the term balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     gyreint =  number of days between calculation of tracer northward
c                transport.
c     igyre   = (true,false) = (do,don`t) write regional mask info for
c               the gyre diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     vmsfint =  number of days between calculation of vertical and
c                meridional stream function.
c
c     tyzint  =  number of days between calculation of zonally averaged
c                tracer components.
c
c     prxzint =  number of days between printouts of x-z data.
c
c     extint  =  number of days between printouts of external mode.
c
c     dspint  =  number of days between surface pressure calculation.
c                Note: only when "diagnostic_surface_height" is enabled.
c     dspper  = averaging period for "diagnostic_surface_height"
c
c     tavgint = number of days between regional tracer averages (under
c               horizontal regions).
c
c     itavg   = (true,false) = (do,don`t) write regional mask info for
c               the tracer average diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     tmbint  = number of days over which tracer equation in averaged
c               in depth and longitude to determine the meridional 
c               balance among storage, divergence, dissipation and 
c               forcing.
c     tmbper  = averaging period for "meridional_tracer_balance"
c
c     itmb    = (true,false) = (do,don`t) write "msktmb" for tracer
c               the meridional balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c
c     tsiint  = number of days between printing of time step integrals.
c
c     stabint = number of days between sampling for various stability
c               criteria.
c
c     snapint = number of days between writing instantaneous samples
c               of data from the MOM grid. note: only when "snapshots"
c               is enabled. see "iounit.h" for more details.
c               all data is at time level "tau" so it is one time step
c               before the date shown in "stamp".
c
c     timavgint= interval (days) for writing time mean data from
c               the "averaging" grid (only when "time_averages" is
c               enabled). if "timavgint" is not an integral number of
c               density time steps,"timavgint" is automatically adjusted
c               to insure this. if the number of days to integrate is
c               not an integral number of "timavgint" then the last
c               averaging period will be less than "timavgint" days.this 
c               may lead to one more averaging period than expected. 
c               see "iounit.h" for more details.
c     timavgper= averaging period for "time_averages"
c
c     xbtint  = averaging period (days) for writing XBT data (only when
c               "xbts" is enabled). if "xbtint" is not an integral
c               number of density time steps, "xbtint" is automatically
c               adjusted to insure this. if the number of days to 
c               integrate is not an integral number of "xbtint" then the
c               last averaging period will be less than "xbtint" days.
c               this may lead to one more averaging period than  
c               expected. see "iounit.h" for more details.
c     xbtper  = averaging period for "xbts"
c
c     zmbcint = number of days between calculation of zonal mean
c               surface boundary conditions (and related  quantities)
c
c     trajint = number of days between writing particle trajectories.
c               particle trajectories are always written on the last
c               time step of the run to allow for restarting.
c
c-----------------------------------------------------------------------
c     outputs from tmngr.F: logical switches
c-----------------------------------------------------------------------
c
c     rundays = integration time in days (from "runlen")
c
c     the following are logical counterparts to the above switches are 
c     set within "tmngr" every time step. logical switches control all
c     decisions about when to do things in MOM.
c
c     cmixts  = (false,true) = (don`t, do) do write estimated mixing
c               coefficients on this time step.
c               based on "cmixint".
c
c     crossts  = (false,true) = (don`t, do) write diapycnal and 
c               isopycnal components of flow on this time step.
c               based on "crossint".
c
c     fctts    = (false,true) = (don`t, do) write difference between 
c               FCT and leapfrog advection on this time step.
c               based on "fctint".
c
c     densityts  = (false,true) = (don`t, do) write density on this time
c               step. based on "densityint".
c               
c
c     exconvts  = (false,true) = (don`t, do) do write temperature change
c               due to explicit convection on this time step.
c               based on "exconvint".
c
c     glents  = (false,true) = (don`t, do) do calculation of global
c               energy integrals on this time step. based on "glenint".
c
c     trmbts  = (false,true) = (don`t, do) do calculation of momentum &
c               tracer term balance on this timestep. based on "trmbint"
c
c     gyrets  = (false,true) = (don`t, do) do calculation of tracer
c               northward transport on this timestep. based on "gyreint"
c
c     vmsfts  = (false,true) = (don`t, do) do calculation of vertical
c               and meridional stream function on this time step.
c               based on "vmsfint"
c
c     tyzts   = (false,true) = (don`t, do) do calculation of zonally
c               averaged tracer components on this time step.
c               based on "tyzint"
c
c     prxzts  = (false,true) = (don`t, do) do printouts of x-z data
c               on this time step. based on "prxzint"
c
c     extts  = (false,true) = (don`t, do) do printout of external mode
c               on this time step. based on "extint"
c
c     dspts  = (false,true) = (don`t, do) do calculation of diagnostic 
c              surface pressure on this time step. based on "dspint"
c               
c
c     stabts  = (false,true) = (don`t, do) test for stability on this
c               time step. based on "stabint"
c
c     tavgts  = (false,true) = (don`t do) do tracer averages on this
c               time step. based on "tavgint"
c
c     tmbts   = (false,true) = (don`t, do) write out tracer meridional .
c               balance on this time step. based on "tmbint"
c
c     tsits   = (false,true) = (don`t, do) print time step integrals
c               on this time step. based on "tsiint"
c
c     zmbcts  = (false,true) = (don`t, do) print zonal mean boundary
c               conditions on this time step.  based on "zmbcint"
c
c     trajts  = (false,true) = (don`t, do) print particle trajectories
c               on this time step. based on "trajint"
c
c     snapts  = (false,true) = (don`t, do) save a snapshot of the data
c               on this time step. based on "snapint"
c
c     timats  = (false,true) = (don`t, do) write time mean data
c               on this time step. based on "timavgint"
c                                          
c     xbtts   = (false,true) = (don`t, do) write averaged XBT data on
c               this time step based on "xbtint"
c
c
c     leapfrog= (false,true) on a (mixing, normal leapfrog) time step
c                based on "nmix"
c                                          
c     euler1  = true on the 1st pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     euler2  = true on the 2nd pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     forward = true on a forward time step. otherwise false
c		(applies when "eb" = false)		  
c                                          
c
c     the following logical switches are based on the model time step. 
c    
c     first   = (true,false) =  when it`s (the first, not the first)
c                               time step of a run
c     eots    = end of a time step. always true except for first
c               pass of an euler backward time step
c     eorun   = last time step of a run. always false except during the
c               last time step of the run.
c
c     eoday   = true when within 1/2 time step of the end of a day
c               else ... false
c     eoweek  = true when within 1/2 time step of the end of a 7 day
c               week (referenced to the start of a year) else ...false
c     eo2wks  = true when within 1/2 time step of the end of two weeks
c               (referenced to the start of a year) else ... false
c     midmon  = true when within 1/2 time step of the middle of a month
c               else ... false
c     eomon   = true when within 1/2 time step of the end of a month
c               else ... false
c     eoyear  = true when within 1/2 time step of the end of a year
c               else ... false
c     osegs   = true on the 1st time step of an ocean segment in mom.F
c               otherwise false.
c     osege  =  true on the last time step of an ocean segment in mom.F
c               otherwise false.
c
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c
c
      logical eb, leapfrog, euler1, euler2, forward, eots
      logical init, first, restrt
      logical itavg, itmb, itrmb, igyre
      character *8 rununits
c
      common /switcc/ rununits
      common /switcr/ runlen, rundays
      common /switci/ nmix
      common /switcl/ eb, leapfrog, euler1, euler2, forward, eots
      common /switcl/ init, first, restrt
      common /switcl/ itavg, itmb, itrmb, igyre
c
      logical          eoday, eoweek, eo2wks
      common /switci/ ieoday,ieoweek,ieo2wks
      common /switcl/  eoday, eoweek, eo2wks
c
      logical          eomon, midmon, eoyear, eorun
      common /switci/ ieomon,imidmon,ieoyear,ieorun
      common /switcl/  eomon, midmon, eoyear, eorun
c
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c     each interval switch needs three variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output (e.g,.  glenint)
c         2) a switch (logical) for the interval (e.g.,  glents )
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c         3) an index (integer)                       (e.g., iglenint)
c
c     the user must specify the interval [e.g., glenint] for diagnostic
c     output in units of days. tmngr sets the corresponding logical  
c     switch [e.g., glents] every time step. It is set to true when  
c     within half a time step of the requested interval, otherwise it is
c     false. All decisions relating to the interval [e.g., glenint]
c     are based on the logical switch [e.g., glents].
c           
c     internal time structures
c
c     The switch index [e.g., iglenint] is used to subsrcipt into  
c     internal arrays maintained by tmngr.F. The switch index is
c     allocated on the first call to function "alarm".
c     The array entry [e.g., iinterval(iglenint)] is a time index to the
c     internal representation of the interval [e.g., glenint].
c     The array entry [e.g., ialarm(iglenint)] is a time index to the
c     next time the alarm will be true.
c-----------------------------------------------------------------------
c
      logical           tavgts,    glents,    trmbts,   prxzts
      common /switcr/   tavgint,   glenint,   trmbint,  prxzint
      common /switci/  itavgint,  iglenint,  itrmbint, iprxzint
      common /switcl/   tavgts,    glents,    trmbts,   prxzts
c
      logical          extts,   trajts,   exconvts,   cmixts
      common /switcr/  extint,  trajint,  exconvint,  cmixint
      common /switci/ iextint, itrajint, iexconvint, icmixint
      common /switcl/  extts,   trajts,   exconvts,   cmixts
c
      logical          vmsfts,   gyrets,    tsits,   snapts,   fctts
      common /switcr/  vmsfint,  gyreint,   tsiint,  snapint,  fctint
      common /switci/ ivmsfint, igyreint,  itsiint, isnapint, ifctint
      common /switcl/  vmsfts,   gyrets,    tsits,   snapts,   fctts
c
      logical          tyzts
      common /switcr/  tyzint
      common /switci/ ityzint
      common /switcl/  tyzts
c
      logical          stabts,   zmbcts,   crossts,   densityts
      common /switcr/  stabint,  zmbcint,  crossint,  densityint
      common /switci/ istabint, izmbcint, icrossint, idensityint
      common /switcl/  stabts,   zmbcts,   crossts,   densityts
c
      logical          osegs,  osege
      common /switcr/          segtim
      common /switci/ iosegs, iosege
      common /switcl/  osegs,  osege
c   
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c              A N D   A V E R A G I N G   P E R I O D
c
c     each averaging period switch needs five variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output    (e.g. xbtint  )   
c         2) a switch (logical) for the interval         (e.g. xbtts   )
c         3) an averaging period (real)                  (e.g. xbtper  )   
c         4) a switch (logical) for accumulating         (e.g. xbtperts)
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switches
c
c         5) an index (integer)                         (e.g. ixbtint  )
c
c     The user must specify the interval [e.g., xbtint] for diagnostic
c     output in units of days and the averaging period [e.g., xbtper] 
c     in units of days. The averaging period may be less than or equal
c     to the interval. For example, if the interval is 30.0 days and the
c     averaging period is 5.0 days, results will be averaged over all
c     time steps within days 26, 27, 28, 29, and 30.  An averaging period
c     of 0.0 days averages over the last time step of the interval (as
c     does xbtper = dt), and an averaging period less than zero turns
c     the switches off for all time steps.  
c
c     The logical switch for writing output at the specified interval 
c     [e.g., xbtts] is set to true on the last time step of the 
c     averaging period. The logical switch for accumulating results
c     [e.g., xbtperts] is true for all time steps within the averaging
c     period, otherwise it is false. 
c
c     internal time structures
c
c     The index [e.g., ixbtint] is allocated on the first call to 
c     function "avg_alarm". The array element iperiod(ixbtint) is an
c     index to the time structure for the internal representation of 
c     "xbtper", and ilastsw(ixbtint) is the index of the switch that 
c     flags the last time step of the accumulation period.
c     Depending on use,  ilastsw(ixbtint) may either be the index
c     of another "named" switch or the index of a new switch
c     allocated on the first time step.
c     In the latter case, iinterval(ilastsw(ixbtint)) is the index of
c     the time structure where "xbtint" is stored in internal form,
c     and ialarm(ilastsw(ixbtint)) is the index of the time when an
c     accumulation period will next end.
c     The variable nextts(ixbtint) is true whenever the next
c     time step will begin the accumulation period.
c
c-----------------------------------------------------------------------
c
      logical         xbtts,     dspts,    tmbts,    timavgts
      logical         xbtperts,  dspperts, tmbperts, timavgperts
      common /switcr/ xbtint,    dspint,   tmbint,   timavgint
      common /switcr/ xbtper,    dspper,   tmbper,   timavgper
      common /switci/ixbtint,   idspint,  itmbint,  itimavgint
      common /switcl/ xbtts,     dspts,    tmbts,    timavgts
      common /switcl/ xbtperts,  dspperts, tmbperts, timavgperts
c
c-----------------------------------------------------------------------
c
c                 S W I T C H E S    B A S E D    O N    
c
c         C A L E N D A R   O R    P R E V I O U S    S W I T C H   
c
c               A N D   A V E R A G I N G    P E R I O D
c
c    
c
c     the following logical switches are based on any calendar or 
c     interval switch and an averaging period (in days). The  averaging
c     period must be less than or equal to the interval. The last
c     time step of the averaging period is at the end of the interval.
c     If the averaging period is set to zero, the averaging period
c     consists only of the last time period of the interval.  If
c     the averaging period is less than zero, these switches are always
c     false.
c
c     each averaging period switch needs four variables in common. For
c     example, if the averaging period is before the end of each month
c     then the calendar switch (eomon), and index (ieomon) are presumed
c     to exist in common and need not be added.
c     
c     Additionally, four items are needed.
c
c       1) an averaging period (real)                  (e.g.  testper  )   
c       2) a switch (logical) for accumulating results (e.g.  testperts)
c       3) a switch (logical) for the end of interval  (e.g.  testts   )
c
c     the fourth is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c       4) an index (integer)                          (e.g.  itestper )
c
c     Suppose it is required to produce averages over all time steps
c     during the last 5 days of each month. Then "testper" = 5.0 and 
c     the following will calculate the accumulating switch.
c
c      testts = avg_alarm(itestper, ihalfstep, 0, testper, iref, ieomon)
c      testperts = on(itestper)
c
c     Note the use of "ieomon" to key off the months.  The switch
c     "testts" will be true whenever "eomon" is true.
c     Also note that when an averaging switch is keyed off another
c     switch, the switch inverval argument is not used, but is 
c     retained for consistency with the form of other averaging
c     switches.
c-----------------------------------------------------------------------
c
      logical           testperts
      logical           testts
      common /switcr/   testint
      common /switcr/   testper
      common /switci/  itestper
      common /switcl/   testts
      common /switcl/   testperts

c
      parameter (maxsw=100)
      logical          on, lastts, nextts
      common /switci/  nsw  
      common /switci/  ialarm(maxsw), iinterval(maxsw), iperiod(maxsw)
     &,                ilastsw(maxsw)
      common /switcl/  on(maxsw), lastts(maxsw), nextts(maxsw)
c
c====================== include file "coord.h" =========================
c
c                    model grid point coordinates
c
c     grid definition:
c
c     the model uses a staggard arakawa "b" grid which is setup and 
c     generated by the "grids.F" module. 
c
c     xt(i)   = longitude of the ith "t" point in degrees.   i=1..imt
c     xu(i)   = longitude of the ith "u,v" point in degrees. i=1..imt
c     yt(j)   = latitude of the jth "t" point in degrees.    j=1..jmt
c     yu(j)   = latitude of the jth "u,v" point in degrees.  j=1..jmt
c     zt(k)   = distance from surface down to center of level k (in cm)
c               (for depth of "t" and "u,v" grid points: k=1,km)
c     zw(k)   = distance from surface down to bottom of level k (in cm)
c               (for depth of "t" and "u,v" grid points: k=1,km)
c     dxtdeg  = widths for "t" grid cells (degrees)
c     dytdeg  = heights for "t" grid cells (degrees)
c     dxudeg  = widths for "u" grid cells (degrees)
c     dyudeg  = heights for "u" grid cells (degrees)
c     dzt(k)  = vertical resolution of "t" and "u" grid cells (in cm)
c     dzw(k)  = vertical resolution of "w" grid cells (in cm)
c
c     "i" increases in an eastward direction, "j" increases in a
c     northward direction, and "k" increases downward.
c     
      common /coord/ xt(imt), yt(jmt), xu(imt), yu(jmt), zw(km), zt(km)
      common /coord/ dxtdeg(imt), dytdeg(jmt), dzt(km)
      common /coord/ dxudeg(imt), dyudeg(jmt), dzw(0:km)
c
c====================== include file "grdvar.h" ========================
c
c     variables which are functions of the grid defined by "coord.h"
c
c     dxt     = longitudinal width of "t" grid box at the 
c               equator (in cm)
c     dxtr    = reciprocal of "dxt"
c     dxt2r   = reciprocal of "2*dxt"
c     dxt4r   = reciprocal of "4*dxt"
c     dxu     = longitudinal width of "u,v" grid box at the 
c               equator (in cm)
c     dxur    = reciprocal of "dxu"
c     dxu2r   = reciprocal of "2*dxu"
c     dxu4r   = reciprocal of "4*dxu"
c     dxmetr  = reciprocal of "(dxt(i)+dxt(i+1))"
c     duw     = xu(i) - xt(i)
c     due     = xt(i+1) - xu(i)
c     dus     = yu(jrow) - yt(jrow)
c     dun     = yt(jrow+1) - yu(jrow)
c
c     dyt     = latitudinal height of "t" grid box (in cm)
c     dytr    = reciprocal of "dyt"
c     dyt2r   = reciprocal of "2*dyt"
c     dyt4r   = reciprocal of "4*dyt"
c     dyu     = latitudinal height of "u,v" grid box (in cm)
c     dyur    = reciprocal of "dyu"
c     dyu2r   = reciprocal of "2*dyu"
c     dyu4r   = reciprocal of "4*dyu"
c
c     csu     = cosine of "u,v" grid point latitude
c     csur    = reciprocal of "csu"
c     cst     = cosine of "t" grid point latitude
c     cstr    = reciprocal of "cst"
c     phi     = latitude of "u,v" grid point in radians
c     phit    = latitude of "t" grid point in radians
c     sine    = sine of "u,v" grid point latitude
c     tng     = tan of "u,v" grid point latitude
c     fcor    = 2*omega*sine(j)
c
c     c2dzt(k)= "2*dzt"
c     dztr(k) = reciprocal of dzt ("t" cell vertical resolution)
c     dzt2r(k)= reciprocal of "2*dzt"
c     dzwr(k) = reciprocal of dzw ("w" cell vertical resolution)
c     dzw2r(k)= reciprocal of "2*dzw"
c     dztur(k)= upper diffusion grid factor = 1.0/(dzw(k-1)*dzt(k))
c     dztlr(k)= lower diffusion grid factor = 1.0/(dzw(k)*dzt(k))
c     dzwur(k)= upper diffusion grid factor = 1.0/(dzt(k)*dzw(k))
c     dzwlr(k)= lower diffusion grid factor = 1.0/(dzt(k+1)*dzw(k))
c     
      common /grdvar/ dxt(imt),  dxtr(imt),  dxt2r(imt), dxu(imt)
      common /grdvar/ dxur(imt), dxu2r(imt), dxu4r(imt), dxt4r(imt)
      common /grdvar/ dyt(jmt),  dytr(jmt),  dyt2r(jmt), dyu(jmt)
      common /grdvar/ dyur(jmt), dyu2r(jmt), dyu4r(jmt), dyt4r(jmt)
      common /grdvar/ csu(jmt),  csur(jmt),  cst(jmt),   cstr(jmt)
      common /grdvar/ cstdytr(jmt), cstdyt2r(jmt)
      common /grdvar/ csudyur(jmt), csudyu2r(jmt)
      common /grdvar/ cst_dytr(jmt), csu_dyur(jmt)
      common /grdvar/ phi(jmt),  phit(jmt),  sine(jmt),  tng(jmt)
      common /grdvar/ fcor(jmt), c2dzt(km),  dztr(km),   dzt2r(km) 
      common /grdvar/ dzwr(0:km), dzw2r(0:km)
      common /grdvar/ dxmetr(imt), duw(imt), due(imt)
      common /grdvar/ dun(jmt), dus(jmt)


c

c====================== include file "atm.h" ===========================
c
c     arrays for the energy-moisture balance model
c
c     note: units for heat flux are in g/cm**2/s**3/cm**2 or (mW/m**2)
c           units for fresh water flux are in cm/s
c           downward is into the surface (ocean, ice or land)
c           upward is into the bottom of the atmosphere
c           outward is out of the top of the atmosphere
c           inward is into the top of the atmosphere
c
c     outlwr(imt,jmt)	 = outgoing atmosphere longwave flux
c     at(imt,jmt,2,nat)	 = tracers (previous and most recent)
c     surf(imt,jmt,nat)	 = surface values (1=temperature, 2=humidity)
c     flux(imt,jmt,nat)	 = downward flux (1=heat, 2=fresh water)
c     precip(imt,jmt)	 = precipitation
c     evap(imt,jmt)	 = evaporation
c     dnswr(imt,jmt)  	 = downward surface shortwave flux
c     uplwr(imt,jmt)  	 = upward surface longwave flux
c     upsens(imt,jmt)	 = upward surface sensible heat flux
c     upltnt(imt,jmt)    = upward surface latent heat flux
c     ssh(imt,jmt) 	 = saturation specific humidity
c     spd(imt,jmt) 	 = wind speed (cm/sec)
c     da(jmt,nat)	 = tracer diffusivity parameterization
c     coalbedo(jmt)	 = planetary coalbedo
c     solins(jmt)	 = solar insolation (units of solarconst)
c     esatm(jmt)	 = atmosphere emissivity times Stefan's constant
c     scatter(jmt)	 = solar scattering into atmosphere





c     cori(jmt,2)	 = Coriolis parameter

c
      real outlwr(imt,jmt), at(imt,jmt,3,nat), surf(imt,jmt,nat)
      real flux(imt,jmt,nat), precip(imt,jmt), evap(imt,jmt)
      real dnswr(imt,jmt), uplwr(imt,jmt), upsens(imt,jmt)
      real upltnt(imt,jmt), ssh(imt,jmt), spd(imt,jmt), da(jmt,nat)
      real coalbedo(jmt), solins(jmt), esatm(jmt), scatter(jmt)





      real cori(jmt,2)
c
      common /atm/ outlwr, at, surf, flux, precip, evap, dnswr, uplwr
     &,            upsens, upltnt, spd, ssh, da, coalbedo, solins
     &,            esatm, scatter





     &,            cori
c
c====================== include file "cembm.h" =========================
c
c     parameters for use in the energy balance model (also see atm.h)
c
c     addflux		= logical flag for adding only even mode fluxes
c     nats		= number of atmospheric time steps since mixing
c     namix		= time steps between mixing (set in atmos.in)
c     lf		= time step flag (1=>leapfrog, 2=>forward)
c     pyear		= calendar year (set in atmos.in, -/+ = BC/AD)
c     dtatm 		= time step for atmosphere (set in atmos.in)
c     dts		= time step (2*dtatm=>leapfrog, dtatm=>forward)
c     co2ccn		= CO2 concentration
c     anthro		= radiative forcing by CO2
c     co2ccni		= initial CO2 concentration
c     co2yri		= last year of initial CO2 concentration
c     co2ccnf		= final CO2 concentration
c     co2yrf		= first year of final CO2 concentration
c     solarconst	= solar constant (g/s**3)
c     ssp		= sea surface pressure (g/cm/s**2)
c     cdatm 		= drag coefficient (dimensionless)
c     cpatm		= atmospheric heat capacity (cm**2/s**2/K)
c     ht		= scale height for temperature
c     hq		= scale height for specific humidity
c     rhoatm		= density of air at sea surface (g/cm**3)
c     rhoocn		= representative sea surface density
c     esocn		= ocean emissivity times Stefan's constant 
c     vlocn		= latent heat of vaporization of water
c     socn		= constant ocean salinity
c     cdice 		= drag coefficient (dimensionless)
c     rhoice		= ice density (g/cm**3)
c     esice		= ice emissivity times Stefan's constant 
c     slice		= latent heat of sublimation of ice
c     flice		= latent heat of fusion of ice (cm**2/s**2)
c     condice		= ice conductivity (g*cm/s**3/K)
c     kadv		= time step divider for ice advection
c     ntats		= time step counter for time averaging
c     avetime		= time for averaging fluxes
c     totaltime		= total time for long term averages
c
      logical addflux
c
      common /cembm/ addflux
      common /cembm/ nats, namix, lf, kadv, ntats
      common /cembm/ pyear, dtatm, dts, co2ccn, anthro, co2ccni, co2yri
     &,              co2ccnf, co2yrf, solarconst, ssp, cdatm, cpatm, ht
     &,              hq, rhoatm, rhoocn, esocn, vlocn, socn, cdice
     &,              rhoice, esice, slice, flice, condice, avetime 
     &,              totaltime
c


c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c

c====================== include file "levind.h" ========================
c
c     vertical level indicators which define model geometry & bottom
c     topography:
c
c     kmt = number of vertical boxes over "t" points
c     kmu = number of vertical boxes over "u,v" points
c
      common /levind/ kmt(imt,jmt), kmu(imt,jmt)
c
c====================== include file "mapsbc.h" ========================
c
c     indicies for surface boundary condition arrays.  names must be
c     unique and are set at the begining of "driver"
c
c     itaux is the x component of wind stress
c     itauy is the y component of wind stress
c     ihflx is heat flux
c     ipme is for precipitation minus evaporation
c     ipsw is for penitrating shortwave (into ocean first layer)
c     isst is the ocean model SST
c     isss is the ocean model SSS
c     isu is the x component of the ocean model first layer velocity
c     isv is the y component of the ocean model first layer velocity
c     it10 is the 10 metre atmopheric temperature
c     iq10 is the 10 metre atmopheric humidity
c     ilwr is incoming longwave radiation
c     iswr is incoming shortwave radiation
c     igu is the x component of the ocean model second layer velocity
c     igv is the y component of the ocean model second layer velocity
c
      common /mapsbc/ itaux, itauy, ihflx, ipme, ipsw, isst, isss
     &,               isu, isv, it10, iq10, ilwr, iswr, igu, igv
c
c====================== include file "csbc.h" ==========================
c
c                    surface boundary conditions (S.B.C.)
c
c
c     numosbc = number of ocean S.B.C..
c
c     numasbc = number of atmospheric S.B.C..
c
c     maxsbc  = maximum number of allowable S.B.C. fields.
c
c     numsbc  = total number of S.B.C. this is the sum of the 
c               atmosphere S.B.C. and ocean S.B.C. fields. it must
c               be less than or equal to "maxsbc".
c
c     sbcocn  = S.B.C. fields on the ocean grid.
c               n=1..numosbc are for the incoming ocean S.B.C.
c               n=numosbc+1..numosbc+numasbc are for the outgoing S.B.C.
c

c
c     ntspos  = number of time steps per ocean segment
c
c     sbcname  = S.B.C. character string names (eg: "SST", "taux", etc)
c               note that these character strings should be changed with
c               care since they are used to identify fields for special
c               treatment
c
c     dunits  = dimensional units for S.B.C. (eg: "deg C")
c
c     mapsbc  = indices for relating how S.B.C. fields are stored
c               within arrays "sbcocn" and "sbcatm"  
c               eg: m = mapsbc(n) where sbcocn(,,m) is S.B.C. "n"
c
c     restrictions on re-arranging S.B.C. fields and "mapsbc":
c
c     1) all ocean S.B.C. (taux, tauy, etc) should be grouped together. 
c        relative ordering within the group is unimportant but the
c        group must preceed the atmos S.B.C. group.
c
c     2) all atmos S.B.C. (sst, ...) should also be grouped together.
c        relative ordering within the group is unimportant.
c
c     the default arrangement is defined as:
c
c             (these five ocean S.B.C. come from the atmos )
c     mapsbc(1) references taux
c     mapsbc(2) references tauy
c     mapsbc(3) references heat flux
c     mapsbc(4) references salt flux
c      if the atmos supplied fresh water flux then it
c      would have to be converted to ...
c      salt flux  = -(P-E+R) * rho * Sref
c      where...
c      P-E+R represents a precipitation minus evaporation
c            plus runoff rate in cm of water/sec
c      rho is the density if water taken to be 1 g/cm**3, and
c      Sref is a reference salinity in units of grams of salt per
c            gram of water (in units of "parts per part" such
c            as 0.035 ... not "parts per thousand")
c      Depending upon the application of interest, users may wish
c      to set Sref to either be a constant over the entire model
c      domain or for it to be the locally predicted salinity of
c      the uppermost model level (S(1)).  If one desires to ensure
c      that a global average P-E+R flux of zero translates to zero
c      trend in the salt content of the ocean, then a constant Sref
c      is needed.      
c     mapsbc(5) references short wave
c
c             (these four atmos S.B.C. come from the ocean)
c     mapsbc(6) references SST
c     mapsbc(7) references SSS
c     mapsbc(8) references surface u
c     mapsbc(9) references surface v
c
c
c     when re-ordering S.B.C., search for "mapsbc"  
c     (eg: grep mapsbc *.F) to insure the new indexing is consistant
c     with the re-ordering. also make changes in "sbcname", "dunits", 
c     "coabc", and "crits" to maintain consistancy.
c
c     example 1: suppose you want only the first six S.B.C...
c                in "csbc.h", set  numosbc=5, numasbc=1
c                this reduces memory requirements.
c                no other changes are necessary
c
c     example 2: suppose you want to remove the short wave boundary
c                condition (to save more memory) from example 1 . 
c                a) in "csbc.h", set numosbc=4, numasbc=1
c                b) grep "mapsbc(5)" *.F to find and remove references
c                c) grep "mapsbc(6)" *.F to change references to 
c                                        mapsbc(5)
c
c     
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c
c
      logical asegs, asege, afirst, alast
      character*10 sbcname
      character*15 dunits
c
      parameter (numosbc=5
     &,          numasbc=4
     &,          maxsbc=numosbc+numasbc, numsbc=maxsbc)
c
      common /csbc/ sbcocn(imt,jmt,numsbc) 
      common /csbc/ dampts(nt), dampdz(nt)
      common /csbc/ coabc(maxsbc), crits(maxsbc)
      common /csbc1/ mapsbc(maxsbc), numpas, iombc, ntspos, ntspas
      common /csbc2/ sbcname(maxsbc), dunits(maxsbc)
      common /csbc3/ asegs, asege, afirst, alast 
c
c====================== include file "cfile.h" =========================
c
c     file parameters and names
c
c     "ocean.in", "ice.in", "atmos.in" and "files.in" must be in the 
c     directory in which the model is running
c     paths and file names can be set through these namelist files
c
c     if additional file names are required, they should be added to 
c     the common block below,  defined in "setocn.F" or "setice.F" 
c     or "setatm.F" and added to the namelists defined in subroutine
c     "pathfile" (in util.F)
c
c     nsfc    = number of snapshot files counter 
c     nwsfc   = number of writes to a snapshot file counter 
c     ntafc   = number of tracer average files counter 
c     mxnsf   = maximum number snapshot files before resetting counter
c     mxnwsf  = maximum number of writes to a snapshot before renaming
c
c     focean  = namelist file for ocean parameters (ocean.in)
c     flat    = latitude data file name
c     fgrid   = flexible grid data file name
c     fcurv   = curvilinear grid data file name
c     fkmt    = levels data file name
c     ftemp   = initial temperature data file name
c     fsalt   = initial salinity data file name
c     ftaux   = x component of wind stress data file name
c     ftauy   = y component of wind stress data file name
c     fhflx   = surface heat flux data file name
c     fsflx   = surface salt flux data file name
c     fsst    = surface temperature data file name
c     fsss    = surface salinity data file name
c     fsnapo  = snapshot file name for the ocean
c     ftavgo  = time average file name for the ocean
c     fresto  = restart file name for the ocean
c     pocnin  = path for ocean input files
c     pocnout = path for ocean output files
c
c     fice    = namelist file for ice parameters (ice.in)
c     ft10    = atmospheric temperature at 10 m
c     fq10    = atmospheric humidity at 10 m
c     fswr    = incoming shortwave radiation
c     flwr    = incoming longwave radiation
c     fsnapi  = snapshot file name for the ice
c     fresti  = restart file name for the ice
c     picein  = path for ice input files
c     piceout = path for ice output files
c
c     fatmos  = namelist file for atmospheric parameters (atmos.in)
c     friver  = river file for atmospheric model
c     fwspd   = wind speed for atmospheric model
c     ftbar   = average air temperature for atmospheric model
c     fqbar   = average specific humidity for atmospheric model
c     frtbar  = run average air temperature for atmospheric model
c     frqbar  = run average specific humidity for atmospheric model
c     felev   = land elevations for modifying saturation humidity 
c     fsnapa  = snapshot file name for the atmosphere
c     ftavga  = time average file name for the atmosphere
c     fresta  = restart file name for the atmosphere
c     patmin  = path for atmosphere input files
c     patmout = path for atmosphere output files
c
c     ffiles  = namelist file of file names
c     pf      = path + file name
c
      character*15 focean, flat, fgrid, fcurv, fkmt 
     &,            ftemp, fsalt, ftaux, ftauy, fhflx, fsflx
     &,            fsst, fsss, fsnapo, ftavgo, fresto
     &,            fice, ft10, fq10, fswr, flwr, fsnapi, fresti
     &,            fatmos, friver, fwspd, ftbar, fqbar, felev
     &,            frtbar, frqbar, fsnapa, ftavga, fresta
     &,            ffiles
c
      character*45 pocnin, pocnout, picein, piceout, patmin, patmout
      character*60 pf
c
      common /cfile/ nsfc, nwsfc, ntafc, mxnsf, mxnwsf
c
      common /cfile/ focean, flat, fgrid, fcurv, fkmt 
     &,              ftemp, fsalt, ftaux, ftauy, fhflx, fsflx
     &,              fsst, fsss, fsnapo, ftavgo, fresto
     &,              fice, ft10, fq10, fswr, flwr, fsnapi, fresti
     &,              fatmos, friver, fwspd, ftbar, fqbar, felev
     &,              frtbar, frqbar, fsnapa, ftavga, fresta
     &,              ffiles
     &,              pocnin, pocnout, picein, piceout, patmin, patmout
c====================== include file "scalar.h" ========================
c
c     various scalar quantities:
c
c     dtts   = time step for density & tracers (in seconds)
c     dtuv   = time step for baroclinic velocity (in seconds)
c     dtsf   = time step for barotropic velocity (in seconds)
c     c2dtts = 2*dtts
c     c2dtuv = 2*dtuv
c     c2dtsf = 2*dtsf
c     acor   = (>0, 0) = (implicit, explicit) treatment of coriolis
c               term for internal and external modes.
c     rho0   = mean density for Bousinessq approximation
c     rho0r  = 1/rho0 
c     omega  = earth`s rotation rate (radians/sec)
c     radius = earth`s radius (cm)
c     grav   = earth`s gravitational acceleration (cm/sec**2)
c     cdbot  = bottom drag coefficient
c     ncon   = number of  passes through convective code in tracer
c     gcor   = time centering for coriolis term
c
c     taux0  = constant zonal windstress (dynes/cm**2) for idealized
c              equatorial studies
c     tauy0  = constant meridional windstress (dynes/cm**2) for
c              idealized equatorial studies
c
      common /scalar/ dtts, dtuv, dtsf, c2dtts, c2dtuv, c2dtsf, acor
      common /scalar/ rho0, rho0r, omega, radius, grav, cdbot, gcor
      common /scalar/ taux0, tauy0
      common /scalri/ ncon
c
c     bring in non dimensional constants
c
c====================== include file "ndcon.h" ========================
c
c     various non dimensional quantities:
c
c     radian = degrees per radian
c     pi     = something good to eat
c
      common /ndcon/ radian, pi
c
c

      namelist /tsteps/ dtatm, namix, segtim
      namelist /uvic/ patmin, patmout
      namelist /co2/ co2ccn, co2ccni, co2ccnf, co2yri, co2yrf
      namelist /paleo/ pyear
      namelist /ice/ kadv
c
c     default coupling time to ocean time step
      segtim = dtts*secday
c     set default CO2 parameters for constant co2ccn
      co2ccni = co2ccn
      co2ccnf = co2ccn
      co2yri = relyr
      co2yrf = relyr
c
c martin
      open(1,file='atmos.in',status='old')
      read(1,*)init
      read(1,*)runlen
      read(1,*)rununits
      read(1,*)restrt
      read(1,*)dts
      read(1,*)mxnsf
      read(1,*)mxnwsf
      read(1,*)pocnin
      read(1,*)pocnout
      close(1)
c
c
100   continue
c
c     set atmospheric time step for driver
      dtatmos = dtatm
c

c     if not coupled set ocean and coupling time to atmosphere
      dtts = dtatm
      segtim = dtts*secday
c



c-----------------------------------------------------------------------
c     calculate the expansion coefficients for Berger's solution for 
c     the year of the initial conditions
c-----------------------------------------------------------------------
c
      call berger
c
c-----------------------------------------------------------------------
c     calculate latitude dependent variables
c-----------------------------------------------------------------------
c
      pi = 4.0*atan(1.0)
      omega = pi/43082.0
c
      do j=1,jmt
        sj = sin(phit(j))
        asj = abs(sj)
c
c-----------------------------------------------------------------------
c       calculate coriolis parameter
c-----------------------------------------------------------------------
c
        cori(j,1) = 2.0*omega*sine(j)
        cori(j,2) = -2.0*omega*sine(j)
c

c-----------------------------------------------------------------------
c       calculate annual average insolation
c-----------------------------------------------------------------------
c
        solins(j) = 0.0
        do n=1, 365
          call insolation (float(n), yt(j), si)
          solins(j) = solins(j) + si
        enddo
        solins(j) = (solins(j) + 0.25*si) /365.25
c



c-----------------------------------------------------------------------
c       coalbedo
c-----------------------------------------------------------------------
c
        coalbedo(j) = 0.75 - 0.18*sj**2

        if(j.eq.1)
     & write (stdout,*) '==> Warning: ice model is not defined.'
     &,   ' heat flux may be limited to prevent freezing sst.'


c
c       Graves et al, 1993 (fudge) 
c       coalbedo(j) = 0.7995 - 0.315*sj**2
c       coalice(j) = 0.6945 - 0.315*sj**2
c
c       North et al 1983
c       coalbedo(j) = 0.75 - 0.18*sj**2
c       coalice(j) = 0.65 - 0.18*sj**2 
c
c       Flannery et al 1983
c       coalbedo(j) = 0.785 - 0.263*sj**2
c       coalice(j) = 0.65 - 0.18*sj**2 
c
c-----------------------------------------------------------------------
c       planetary and atmospheric emissivity
c-----------------------------------------------------------------------
c

        esatm(j) = 5.57e-5*(0.8666 + 0.0408*sj - 0.2553*sj**2 
     &          - 0.4660*sj**3 + 0.9877*sj**4 + 2.0257*sj**5 
     &          - 2.3374*sj**6 - 3.1990*sj**7 + 2.8581*sj**8
     &          + 1.6070*sj**9 -1.2685*sj**10)
        scatter(j) = 0.30
c
c-----------------------------------------------------------------------
c       diffusivities
c-----------------------------------------------------------------------
c
        da(j,1) = 3.0e10*(0.81 - 1.08*sj**2 + 0.74*sj**4)

        da(j,2) = 1.7e10*(1.9823 - 17.3501*asj + 117.2489*asj**2
     &          -274.1129*asj**3 + 258.2244*asj**4 - 85.7967*asj**5)
        do n=3,nat
          da(j,n) = 1.0e10
        enddo	
      enddo
c
c-----------------------------------------------------------------------
c     zero the solver work space
c-----------------------------------------------------------------------
c
      do i=1,lenw
        rwork(i) = 0.0e0
      enddo
      do i=1,leniw
        iwork(i) = 0
      enddo
c
      call indexmaps
c
c-----------------------------------------------------------------------
c     Calculate coefficients for the matrix inversion of tracers
c-----------------------------------------------------------------------
c
      do n=1,nat
        sltol(n) = 1.0e-11
        if (n .eq. 1) sltol(n) = 1.0e-4
        do lf=1,2
          dts = -2.0*dtatm
          if (lf .eq. 2) dts = -dtatm
          call coef (n)
        enddo
      enddo
c


c


c-----------------------------------------------------------------------
c     set initial conditions or read a restart
c-----------------------------------------------------------------------
c
      call initatmos
c






      return
      end









      subroutine setmom
c
c=======================================================================
c
c     set up MOM2 timing and I/O (similar to parts of setocn.F)
c     this routine is only used when the EMBM is not coupled to MOM2
c     based on code by r.pacanowski
c
c     author:   m.eby   e-mail: eby@uvic.ca
c=======================================================================
c

      external blkdta
c
      parameter (ifdmax=100)
      character*30 cifdef(ifdmax)
      character*80 momver
      real kappa_m, kappa_h
      logical annlev
c
c====================== include file "param.h" =========================
c
c     main parameter file which sets ocean characteristics:
c
c     "size.h" sets model size "imt", "jmt", and "km"
c
c====================== include file "size.h" ==========================
c                                                                       
c-----------------------------------------------------------------------
c     USER INPUT: 
c-----------------------------------------------------------------------
c
c     imt    = number of grid points in the longitudinal direction
c              (calculated points are from 2 through imt-1. End points
c               are boundaries)          
c
c     jmt    = number of grid points (latitude rows) in the latitudinal
c              direction (calculated points are from 2 through jmt-1.           
c              End points are boundaries)   
c                                
c     km     = number of grid points in the vertical direction          
c              (calculated points are from 1 through km)
c
c     nt     = number of tracers (temperature, salinity, ...)
c
c     mnisle = maximum number of islands (unconnected land masses)
c
c     maxipp = maximum number of all island perimeter points
c-----------------------------------------------------------------------
c                                                                       
      parameter (imt=  92, jmt=  61, km= 15)
      parameter (nt=2)
      parameter (nat=2)
      parameter (mnisle=50, maxipp=5000)
c

c






c
c-----------------------------------------------------------------------
c     END USER INPUT
c-----------------------------------------------------------------------
c                                                                       
c-----------------------------------------------------------------------
c     By default, the MW (memory window) is 2nd order except for the
c     following options which require a 4th order MW 
c
c     for 2nd order schemes, the minimum sized MW is 3 latitude rows
c     for 4th order schemes, the minimum sized MW is 4 latitude rows
c                            (5 if using coarse_grained_parallelism)
c-----------------------------------------------------------------------
c













c
c-----------------------------------------------------------------------
c     set MW (memory window) size "jmw" 
c-----------------------------------------------------------------------
c                                                                       

c
c     for UNI-TASKING: "jmw" is set to the minimum for each option class 
c     "jmw" may be increased up to "jmt" 
c

      parameter (jmw=jmt)


c
c-----------------------------------------------------------------------
c     set first and last calculated row within the MW. other rows
c     are used as buffers
c-----------------------------------------------------------------------
c
c     jsmw   = 1st calculated row within the MW     
c     jemw   = last calculated row within the MW
c
      parameter (jsmw=2, jemw=jmw-1)
c
c
c     jextra = extra buffer rows needed for coarse_grained_parallelism.
c              "jextra" rows are added to the top and bottom of the MW
c              so the MW size increases by 2*jextra       
c

          parameter (jextra = 0)




c
c     nvar   = number of prognostic variables
c     lseg   = maximum number of longitudinal stream function segments
c     nlatpr = maximum number of latitudes for matrix printouts
c              on diagnostic time steps
c     nhreg  = number of regions in the horizontal used for averaging
c              tracers.
c     nvreg  = number of regions in the vertical used for term balance
c              calculations. note "nvreg" isn`t used for tracer averages
c     numreg = total number of regions ( = product of nhreg & nvreg)
c              used for term balance calculations
c
      parameter (lseg=5, nlatpr=10)

      parameter (nhreg=5, nvreg=2, numreg=nhreg*nvreg)

      parameter (nvar=nt+2)
c

c
      parameter (imtm1=imt-1, kmm1=km-1)                                
      parameter (imtp1=imt+1, imtm2=imt-2
     &,          jmtp1=jmt+1, jmtm1=jmt-1, jmtm2=jmt-2

     &,          jscan=jmtm2

     &,          kmp1=km+1, kmp2=km+2
     &,          imtkm=imt*km, nwds=imt*jmt, nkflds=2
     &,          nslab=imt*nvar*km, ntmin2=nt+1/nt)
c
c     include parameter constants
c
c====================== include file "pconst.h" ========================
c
c
c     rules for parameter constants
c
c     use prefix of "c" for whole real numbers (eg: c57 for 57.0)
c     use "m" after prefix to designate negative values (minus sign)
c       (eg: cm7 for -7.0)
c     use prefix of "p" for non repeating fractions (eg: p5 for 0.5)
c     use prefix of "r" for reciprocals (eg: r3 for 1/3.0)
c     combine use of prefix above and "e" for scientific notation, with
c       (eg: c5e4 for 5.0e4, c1em10 for 1.0e-10)
c
      parameter (c0=0.0, c1=1.0, c2=2.0, c3=3.0, c4=4.0, c5=5.0, c7=7.0)
      parameter (c8=8.0)
      parameter (c14=14.0, c16=16.0, c360=360.0)
      parameter (p125=0.125, p25=0.25, p5=0.5, p75=0.75)
      parameter (epsln=1.0e-20)
c
      parameter (c24=24.0, c60=60.0, c1440=1440.0)
      parameter (r24=c1/c24, r60=c1/c60, r1440=c1/c1440)
      parameter (secday=c1/(c60*c1440))
c
c     include standard I/O units
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c
c     ncrows = number of calculated rows within the MW.
c              (the remaining rows are buffer rows). 
c


      parameter (ncrows = jmw - 2)


c====================== include file "cfile.h" =========================
c
c     file parameters and names
c
c     "ocean.in", "ice.in", "atmos.in" and "files.in" must be in the 
c     directory in which the model is running
c     paths and file names can be set through these namelist files
c
c     if additional file names are required, they should be added to 
c     the common block below,  defined in "setocn.F" or "setice.F" 
c     or "setatm.F" and added to the namelists defined in subroutine
c     "pathfile" (in util.F)
c
c     nsfc    = number of snapshot files counter 
c     nwsfc   = number of writes to a snapshot file counter 
c     ntafc   = number of tracer average files counter 
c     mxnsf   = maximum number snapshot files before resetting counter
c     mxnwsf  = maximum number of writes to a snapshot before renaming
c
c     focean  = namelist file for ocean parameters (ocean.in)
c     flat    = latitude data file name
c     fgrid   = flexible grid data file name
c     fcurv   = curvilinear grid data file name
c     fkmt    = levels data file name
c     ftemp   = initial temperature data file name
c     fsalt   = initial salinity data file name
c     ftaux   = x component of wind stress data file name
c     ftauy   = y component of wind stress data file name
c     fhflx   = surface heat flux data file name
c     fsflx   = surface salt flux data file name
c     fsst    = surface temperature data file name
c     fsss    = surface salinity data file name
c     fsnapo  = snapshot file name for the ocean
c     ftavgo  = time average file name for the ocean
c     fresto  = restart file name for the ocean
c     pocnin  = path for ocean input files
c     pocnout = path for ocean output files
c
c     fice    = namelist file for ice parameters (ice.in)
c     ft10    = atmospheric temperature at 10 m
c     fq10    = atmospheric humidity at 10 m
c     fswr    = incoming shortwave radiation
c     flwr    = incoming longwave radiation
c     fsnapi  = snapshot file name for the ice
c     fresti  = restart file name for the ice
c     picein  = path for ice input files
c     piceout = path for ice output files
c
c     fatmos  = namelist file for atmospheric parameters (atmos.in)
c     friver  = river file for atmospheric model
c     fwspd   = wind speed for atmospheric model
c     ftbar   = average air temperature for atmospheric model
c     fqbar   = average specific humidity for atmospheric model
c     frtbar  = run average air temperature for atmospheric model
c     frqbar  = run average specific humidity for atmospheric model
c     felev   = land elevations for modifying saturation humidity 
c     fsnapa  = snapshot file name for the atmosphere
c     ftavga  = time average file name for the atmosphere
c     fresta  = restart file name for the atmosphere
c     patmin  = path for atmosphere input files
c     patmout = path for atmosphere output files
c
c     ffiles  = namelist file of file names
c     pf      = path + file name
c
      character*15 focean, flat, fgrid, fcurv, fkmt 
     &,            ftemp, fsalt, ftaux, ftauy, fhflx, fsflx
     &,            fsst, fsss, fsnapo, ftavgo, fresto
     &,            fice, ft10, fq10, fswr, flwr, fsnapi, fresti
     &,            fatmos, friver, fwspd, ftbar, fqbar, felev
     &,            frtbar, frqbar, fsnapa, ftavga, fresta
     &,            ffiles
c
      character*45 pocnin, pocnout, picein, piceout, patmin, patmout
      character*60 pf
c
      common /cfile/ nsfc, nwsfc, ntafc, mxnsf, mxnwsf
c
      common /cfile/ focean, flat, fgrid, fcurv, fkmt 
     &,              ftemp, fsalt, ftaux, ftauy, fhflx, fsflx
     &,              fsst, fsss, fsnapo, ftavgo, fresto
     &,              fice, ft10, fq10, fswr, flwr, fsnapi, fresti
     &,              fatmos, friver, fwspd, ftbar, fqbar, felev
     &,              frtbar, frqbar, fsnapa, ftavga, fresta
     &,              ffiles
     &,              pocnin, pocnout, picein, piceout, patmin, patmout
c======================= include file "calendar.h"======================
c
c                       calendar specification arrays
c
c-----------------------------------------------------------------------
c
c     eqyear = true to select a calendar in which each year
c              has the same number of days (i.e., no leap years)
c              false selects a julian calendar
c
c     eqmon  = true to force all months to have the same number of days
c              false => the usual 31, 28, 31, 30, ..., days per month. 
c              only used when eqyear = true 
c
c     dayname = character names of days
c
c     monname = character names of months
c
c     monlen = the length of each month (in days) when eqmon is true
c
c     yrlen  = the length of a typical (non-leap) year in days
c
c     daypm  = array of month lengths in days   (non-leap)
c
c     msum   = array of cumulative days preceding each month
c              (again, non-leap)
c
c-----------------------------------------------------------------------
      logical eqyear, eqmon
      integer daypm, msum, yrlen, monlen
c
      character*10 dayname
      character*12 monname
c
      common /calenc/ dayname(7), monname(12)
      common /calenl/ eqyear, eqmon
      common /caleni/ daypm(12), msum(12), yrlen, monlen

c====================== include file "coord.h" =========================
c
c                    model grid point coordinates
c
c     grid definition:
c
c     the model uses a staggard arakawa "b" grid which is setup and 
c     generated by the "grids.F" module. 
c
c     xt(i)   = longitude of the ith "t" point in degrees.   i=1..imt
c     xu(i)   = longitude of the ith "u,v" point in degrees. i=1..imt
c     yt(j)   = latitude of the jth "t" point in degrees.    j=1..jmt
c     yu(j)   = latitude of the jth "u,v" point in degrees.  j=1..jmt
c     zt(k)   = distance from surface down to center of level k (in cm)
c               (for depth of "t" and "u,v" grid points: k=1,km)
c     zw(k)   = distance from surface down to bottom of level k (in cm)
c               (for depth of "t" and "u,v" grid points: k=1,km)
c     dxtdeg  = widths for "t" grid cells (degrees)
c     dytdeg  = heights for "t" grid cells (degrees)
c     dxudeg  = widths for "u" grid cells (degrees)
c     dyudeg  = heights for "u" grid cells (degrees)
c     dzt(k)  = vertical resolution of "t" and "u" grid cells (in cm)
c     dzw(k)  = vertical resolution of "w" grid cells (in cm)
c
c     "i" increases in an eastward direction, "j" increases in a
c     northward direction, and "k" increases downward.
c     
      common /coord/ xt(imt), yt(jmt), xu(imt), yu(jmt), zw(km), zt(km)
      common /coord/ dxtdeg(imt), dytdeg(jmt), dzt(km)
      common /coord/ dxudeg(imt), dyudeg(jmt), dzw(0:km)
c
c====================== include file "csbc.h" ==========================
c
c                    surface boundary conditions (S.B.C.)
c
c
c     numosbc = number of ocean S.B.C..
c
c     numasbc = number of atmospheric S.B.C..
c
c     maxsbc  = maximum number of allowable S.B.C. fields.
c
c     numsbc  = total number of S.B.C. this is the sum of the 
c               atmosphere S.B.C. and ocean S.B.C. fields. it must
c               be less than or equal to "maxsbc".
c
c     sbcocn  = S.B.C. fields on the ocean grid.
c               n=1..numosbc are for the incoming ocean S.B.C.
c               n=numosbc+1..numosbc+numasbc are for the outgoing S.B.C.
c

c
c     ntspos  = number of time steps per ocean segment
c
c     sbcname  = S.B.C. character string names (eg: "SST", "taux", etc)
c               note that these character strings should be changed with
c               care since they are used to identify fields for special
c               treatment
c
c     dunits  = dimensional units for S.B.C. (eg: "deg C")
c
c     mapsbc  = indices for relating how S.B.C. fields are stored
c               within arrays "sbcocn" and "sbcatm"  
c               eg: m = mapsbc(n) where sbcocn(,,m) is S.B.C. "n"
c
c     restrictions on re-arranging S.B.C. fields and "mapsbc":
c
c     1) all ocean S.B.C. (taux, tauy, etc) should be grouped together. 
c        relative ordering within the group is unimportant but the
c        group must preceed the atmos S.B.C. group.
c
c     2) all atmos S.B.C. (sst, ...) should also be grouped together.
c        relative ordering within the group is unimportant.
c
c     the default arrangement is defined as:
c
c             (these five ocean S.B.C. come from the atmos )
c     mapsbc(1) references taux
c     mapsbc(2) references tauy
c     mapsbc(3) references heat flux
c     mapsbc(4) references salt flux
c      if the atmos supplied fresh water flux then it
c      would have to be converted to ...
c      salt flux  = -(P-E+R) * rho * Sref
c      where...
c      P-E+R represents a precipitation minus evaporation
c            plus runoff rate in cm of water/sec
c      rho is the density if water taken to be 1 g/cm**3, and
c      Sref is a reference salinity in units of grams of salt per
c            gram of water (in units of "parts per part" such
c            as 0.035 ... not "parts per thousand")
c      Depending upon the application of interest, users may wish
c      to set Sref to either be a constant over the entire model
c      domain or for it to be the locally predicted salinity of
c      the uppermost model level (S(1)).  If one desires to ensure
c      that a global average P-E+R flux of zero translates to zero
c      trend in the salt content of the ocean, then a constant Sref
c      is needed.      
c     mapsbc(5) references short wave
c
c             (these four atmos S.B.C. come from the ocean)
c     mapsbc(6) references SST
c     mapsbc(7) references SSS
c     mapsbc(8) references surface u
c     mapsbc(9) references surface v
c
c
c     when re-ordering S.B.C., search for "mapsbc"  
c     (eg: grep mapsbc *.F) to insure the new indexing is consistant
c     with the re-ordering. also make changes in "sbcname", "dunits", 
c     "coabc", and "crits" to maintain consistancy.
c
c     example 1: suppose you want only the first six S.B.C...
c                in "csbc.h", set  numosbc=5, numasbc=1
c                this reduces memory requirements.
c                no other changes are necessary
c
c     example 2: suppose you want to remove the short wave boundary
c                condition (to save more memory) from example 1 . 
c                a) in "csbc.h", set numosbc=4, numasbc=1
c                b) grep "mapsbc(5)" *.F to find and remove references
c                c) grep "mapsbc(6)" *.F to change references to 
c                                        mapsbc(5)
c
c     
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c
c
      logical asegs, asege, afirst, alast
      character*10 sbcname
      character*15 dunits
c
      parameter (numosbc=5
     &,          numasbc=4
     &,          maxsbc=numosbc+numasbc, numsbc=maxsbc)
c
      common /csbc/ sbcocn(imt,jmt,numsbc) 
      common /csbc/ dampts(nt), dampdz(nt)
      common /csbc/ coabc(maxsbc), crits(maxsbc)
      common /csbc1/ mapsbc(maxsbc), numpas, iombc, ntspos, ntspas
      common /csbc2/ sbcname(maxsbc), dunits(maxsbc)
      common /csbc3/ asegs, asege, afirst, alast 
c
c====================== include file "cembm.h" =========================
c
c     parameters for use in the energy balance model (also see atm.h)
c
c     addflux		= logical flag for adding only even mode fluxes
c     nats		= number of atmospheric time steps since mixing
c     namix		= time steps between mixing (set in atmos.in)
c     lf		= time step flag (1=>leapfrog, 2=>forward)
c     pyear		= calendar year (set in atmos.in, -/+ = BC/AD)
c     dtatm 		= time step for atmosphere (set in atmos.in)
c     dts		= time step (2*dtatm=>leapfrog, dtatm=>forward)
c     co2ccn		= CO2 concentration
c     anthro		= radiative forcing by CO2
c     co2ccni		= initial CO2 concentration
c     co2yri		= last year of initial CO2 concentration
c     co2ccnf		= final CO2 concentration
c     co2yrf		= first year of final CO2 concentration
c     solarconst	= solar constant (g/s**3)
c     ssp		= sea surface pressure (g/cm/s**2)
c     cdatm 		= drag coefficient (dimensionless)
c     cpatm		= atmospheric heat capacity (cm**2/s**2/K)
c     ht		= scale height for temperature
c     hq		= scale height for specific humidity
c     rhoatm		= density of air at sea surface (g/cm**3)
c     rhoocn		= representative sea surface density
c     esocn		= ocean emissivity times Stefan's constant 
c     vlocn		= latent heat of vaporization of water
c     socn		= constant ocean salinity
c     cdice 		= drag coefficient (dimensionless)
c     rhoice		= ice density (g/cm**3)
c     esice		= ice emissivity times Stefan's constant 
c     slice		= latent heat of sublimation of ice
c     flice		= latent heat of fusion of ice (cm**2/s**2)
c     condice		= ice conductivity (g*cm/s**3/K)
c     kadv		= time step divider for ice advection
c     ntats		= time step counter for time averaging
c     avetime		= time for averaging fluxes
c     totaltime		= total time for long term averages
c
      logical addflux
c
      common /cembm/ addflux
      common /cembm/ nats, namix, lf, kadv, ntats
      common /cembm/ pyear, dtatm, dts, co2ccn, anthro, co2ccni, co2yri
     &,              co2ccnf, co2yrf, solarconst, ssp, cdatm, cpatm, ht
     &,              hq, rhoatm, rhoocn, esocn, vlocn, socn, cdice
     &,              rhoice, esice, slice, flice, condice, avetime 
     &,              totaltime
c
c====================== include file "grdvar.h" ========================
c
c     variables which are functions of the grid defined by "coord.h"
c
c     dxt     = longitudinal width of "t" grid box at the 
c               equator (in cm)
c     dxtr    = reciprocal of "dxt"
c     dxt2r   = reciprocal of "2*dxt"
c     dxt4r   = reciprocal of "4*dxt"
c     dxu     = longitudinal width of "u,v" grid box at the 
c               equator (in cm)
c     dxur    = reciprocal of "dxu"
c     dxu2r   = reciprocal of "2*dxu"
c     dxu4r   = reciprocal of "4*dxu"
c     dxmetr  = reciprocal of "(dxt(i)+dxt(i+1))"
c     duw     = xu(i) - xt(i)
c     due     = xt(i+1) - xu(i)
c     dus     = yu(jrow) - yt(jrow)
c     dun     = yt(jrow+1) - yu(jrow)
c
c     dyt     = latitudinal height of "t" grid box (in cm)
c     dytr    = reciprocal of "dyt"
c     dyt2r   = reciprocal of "2*dyt"
c     dyt4r   = reciprocal of "4*dyt"
c     dyu     = latitudinal height of "u,v" grid box (in cm)
c     dyur    = reciprocal of "dyu"
c     dyu2r   = reciprocal of "2*dyu"
c     dyu4r   = reciprocal of "4*dyu"
c
c     csu     = cosine of "u,v" grid point latitude
c     csur    = reciprocal of "csu"
c     cst     = cosine of "t" grid point latitude
c     cstr    = reciprocal of "cst"
c     phi     = latitude of "u,v" grid point in radians
c     phit    = latitude of "t" grid point in radians
c     sine    = sine of "u,v" grid point latitude
c     tng     = tan of "u,v" grid point latitude
c     fcor    = 2*omega*sine(j)
c
c     c2dzt(k)= "2*dzt"
c     dztr(k) = reciprocal of dzt ("t" cell vertical resolution)
c     dzt2r(k)= reciprocal of "2*dzt"
c     dzwr(k) = reciprocal of dzw ("w" cell vertical resolution)
c     dzw2r(k)= reciprocal of "2*dzw"
c     dztur(k)= upper diffusion grid factor = 1.0/(dzw(k-1)*dzt(k))
c     dztlr(k)= lower diffusion grid factor = 1.0/(dzw(k)*dzt(k))
c     dzwur(k)= upper diffusion grid factor = 1.0/(dzt(k)*dzw(k))
c     dzwlr(k)= lower diffusion grid factor = 1.0/(dzt(k+1)*dzw(k))
c     
      common /grdvar/ dxt(imt),  dxtr(imt),  dxt2r(imt), dxu(imt)
      common /grdvar/ dxur(imt), dxu2r(imt), dxu4r(imt), dxt4r(imt)
      common /grdvar/ dyt(jmt),  dytr(jmt),  dyt2r(jmt), dyu(jmt)
      common /grdvar/ dyur(jmt), dyu2r(jmt), dyu4r(jmt), dyt4r(jmt)
      common /grdvar/ csu(jmt),  csur(jmt),  cst(jmt),   cstr(jmt)
      common /grdvar/ cstdytr(jmt), cstdyt2r(jmt)
      common /grdvar/ csudyur(jmt), csudyu2r(jmt)
      common /grdvar/ cst_dytr(jmt), csu_dyur(jmt)
      common /grdvar/ phi(jmt),  phit(jmt),  sine(jmt),  tng(jmt)
      common /grdvar/ fcor(jmt), c2dzt(km),  dztr(km),   dzt2r(km) 
      common /grdvar/ dzwr(0:km), dzw2r(0:km)
      common /grdvar/ dxmetr(imt), duw(imt), due(imt)
      common /grdvar/ dun(jmt), dus(jmt)


c

c====================== include file "iounit.h" ========================
c
c     i/o units and related variables
c
c     taum1disk = disk pointer for tau-1 latitude rows
c     taudisk   = disk pointer for tau   latitude rows
c     taup1disk = disk pointer for tau+1 latitude rows
c     kflds     = disk unit used for two dimensional fields
c     latdisk   = disk units for latitude rows (alternately pointed to 
c                by taum1disk, taudisk, and taup1disk)
c     wide_open_mw = logical to indicate that the MW is fully opened.
c              if .true. then jmw = jmt and there are no latitude rows
c              on disk. Instead, they are all in the MW.
c              if .false. then jmw < jmt and all latitude rows are on
c              disk so they must be transferred between the MW and disk.
c              
c     iodoc  = unit for documentation
c     iostab = unit for stability testing
c     iotim  = unit for time means
c     iotim1 = scratch disk (SSD) unit for accumulating time means
c     ionew1 = unit for reading sponge layer data
c     ionew2 = mirror unit of sponge layer data on SSD




c     
c     for the following, a control # < 0 implies that unformatted data
c     will be written to a unit selected by the i/o manager "iomngr.F"
c     and given a hardwired name (grep getunit *.F to see names) 
c     and formatted data (to stdout) will be written. if a # > 0 and
c      # <> stdout, only unformatted data will be written.
c
c     iotavg = control # for tracer averages
c     iotmb  = control # for writing tracer meridional budget.
c     iotrmb = control # for term balances for tracer and momentum
c     ioglen = control # for writing global energetics integrals
c     iovmsf = control # for writing meridional stream function
c     iogyre = control # for writing gyre transport.
c     ioprxz = control # for writing x-z sections from latitudes
c     ioext  = control # for writing external mode (stream function)
c     iodsp  = control # for writing diagnostic surface pressure
c     iotsi  = control # for writing time step integrals
c     ioxbt  = control # for writing time averaged xbt data
c     iozmbc = control # for writing zonal mean surf boundary conditons
c
      integer taum1disk, taudisk, taup1disk
      common /iounit/ taum1disk, taudisk, taup1disk

      common /iounit/ latdisk(2), kflds

      common /iounit/ iodoc, iostab, iotavg, iotmb, iotrmb
      common /iounit/ iotim, iotim1
      common /iounit/ ioglen, iovmsf, iogyre, ioprxz, ioext, iodsp
      common /iounit/ iotsi, iozmbc, ionew1, ionew2, ioxbt




      logical wide_open_mw
      common /iounitl/ wide_open_mw
c
c     iotext  = 80 character text string for describing the details
c                of the next unformatted data record.
c     expnam  = 60 character text string for the experiment name
c
      character iotext*80, expnam*60
      common /iounitc/ iotext, expnam
c
c     when writing unformatted data records in MOM, each data record is
c     preceeded by a header record which was written as:
c     write(unit) stamp, iotext, expnam
c     where stamp is a 32 character specification of the model date &
c     time corresponding to the time step when the data was written and
c     iotext is a 80 character description of what is in the
c     data record and how it is to be read. expnam is a 60 character
c     experiment name which shows which experiment wrote the data.
c     this makes it easy to decipher any unformatted output from the
c     model by using a program similar to the following: 
c
c      program decifr
c
c-----------------------------------------------------------------------
c      decifer an unformatted file from MOM by showing the header
c      records. the file needs to copied to file "fort.21"
c-----------------------------------------------------------------------
c
c      character*32 stamp
c      character*80 iotext
c      character*60 expnam
c
c      iounit = 21
c      rewind iounit
c      do n=1,100000
c
c        read the header record
c
c        read (iounit, end=110) stamp, iotext, expnam
c        write (*,'(1x,a32,1x,a80)') stamp, iotext
c
c        skip the data record
c
c        read (iounit)
c      enddo
c110   continue
c      write (*,*) " => end of file on fort.",iounit
c      stop
c      end
c
c     note: all unformatted diagnostic MOM data is handled this way.
c     to insure that data is read properly, verify that arrays are
c     dimensioned corectly by comparing the listed variables against
c     those in the *.h files. (grep -i -n "variable" *.h) Also, most
c     data from MOM is written IEEE 32bit so it is read directly by
c     most workstations. However, when trying to read these IEEE files
c     on the CRAY, they must be assigned IEEE before being read.
c     Some diagnostic data is averaged over time before being written.
c     In these cases, the time "stamp" refers to the last time step
c     at the end of the averaging period. An averaging interval is
c     also written as part of the data. Averaging periods = zero 
c     indicate instantaneous data.
c
c====================== include file "levind.h" ========================
c
c     vertical level indicators which define model geometry & bottom
c     topography:
c
c     kmt = number of vertical boxes over "t" points
c     kmu = number of vertical boxes over "u,v" points
c
      common /levind/ kmt(imt,jmt), kmu(imt,jmt)
c
c====================== include file "scalar.h" ========================
c
c     various scalar quantities:
c
c     dtts   = time step for density & tracers (in seconds)
c     dtuv   = time step for baroclinic velocity (in seconds)
c     dtsf   = time step for barotropic velocity (in seconds)
c     c2dtts = 2*dtts
c     c2dtuv = 2*dtuv
c     c2dtsf = 2*dtsf
c     acor   = (>0, 0) = (implicit, explicit) treatment of coriolis
c               term for internal and external modes.
c     rho0   = mean density for Bousinessq approximation
c     rho0r  = 1/rho0 
c     omega  = earth`s rotation rate (radians/sec)
c     radius = earth`s radius (cm)
c     grav   = earth`s gravitational acceleration (cm/sec**2)
c     cdbot  = bottom drag coefficient
c     ncon   = number of  passes through convective code in tracer
c     gcor   = time centering for coriolis term
c
c     taux0  = constant zonal windstress (dynes/cm**2) for idealized
c              equatorial studies
c     tauy0  = constant meridional windstress (dynes/cm**2) for
c              idealized equatorial studies
c
      common /scalar/ dtts, dtuv, dtsf, c2dtts, c2dtuv, c2dtsf, acor
      common /scalar/ rho0, rho0r, omega, radius, grav, cdbot, gcor
      common /scalar/ taux0, tauy0
      common /scalri/ ncon
c
c     bring in non dimensional constants
c
c====================== include file "ndcon.h" ========================
c
c     various non dimensional quantities:
c
c     radian = degrees per radian
c     pi     = something good to eat
c
      common /ndcon/ radian, pi
c
c
c====================== include file "switch.h" ========================
c
c     all time dependent decisions are made by time manager "tmngr.F"
c     and communicated elsewhere to the model via logical switches.
c
c     inputs: (defaulted in "blkdta.F", optionally reset via namelist)
c
c
c     runlen  = integration period (see rununits). note "runlen" should
c               be an integral number of density time steps. if not,
c               then "runlen" is automatically adjusted to insure this.
c               fractional days are supported but not fractional months
c               or years.
c     rununits= units of "runlen". may be "days", "months", or "years".
c               tmngr will convert "runlen" which is in "rununits"
c               to "rundays" in units of days.
c
c     segtim  = the integration time "runlen" is broken into a number of
c               segments each of length "segtim" days. updated surface
c               boundary conditions are applied to MOM every "segtim" 
c               days. this is useful when coupling to atmospheric models
c               in which case both models exchange surface boundary
c               conditions every "segtim" days where "segtim"
c               is 1/(coupling frequency). without an atmospheric model,
c               when getting surface boundary conditions from data, 
c               "segtim" is set to the time step (in days) by mom.F. in
c               either case, "runlen" (in days) should be an integral
c               number of "segtim".     
c
c     nmix    = number of time steps between mixing timesteps. used
c               to damp timestep splitting due to centered leapfrog.
c
c     init    = (true,false)  indicates that this run is a
c               (start from initial conditions, restart)
c
c     restrt  = (true,false) = (do,don`t) write a restart at the end
c               of the run
c
c     eb      = (true,false) configures for the use of a 
c               (euler backward,forward) type mixing timestep
c
c-----------------------------------------------------------------------
c     inputs to tmngr.F: diagnostic intervals
c-----------------------------------------------------------------------
c
c     note: switches are used to control the interval between doing
c           diagnostics. units for all switches are in days. 
c           setting a switch < 0.0 disables whatever the switch is 
c           controlling. setting it = 0.0 causes the diagnostic to be 
c           done every time step, and setting it > 0.0 causes the 
c           diagnostic to be done repeatedly on the specified interval. 
c
c     cmixint = number of days between writing estimated mixing coeffs
c               on faces of T cells and U cells
c
c     crossint = number of days between writing diapycnal and isopycnal
c               components of flow
c
c     fctint = number of days between writing difference between 
c              FCT and leapfrog advection
c
c     densityint = number of days between writing density
c
c     exconvint = number of days between writing temperature rate of
c                 change due to explicit convection
c
c     glenint =  number of days between global energetics integrals.
c
c     trmbint =  number of days between momentum and tracer term
c                balances (global and regional).
c
c     itrmb   = (true,false) = (do,don`t) write regional mask info for
c               the term balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     gyreint =  number of days between calculation of tracer northward
c                transport.
c     igyre   = (true,false) = (do,don`t) write regional mask info for
c               the gyre diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     vmsfint =  number of days between calculation of vertical and
c                meridional stream function.
c
c     tyzint  =  number of days between calculation of zonally averaged
c                tracer components.
c
c     prxzint =  number of days between printouts of x-z data.
c
c     extint  =  number of days between printouts of external mode.
c
c     dspint  =  number of days between surface pressure calculation.
c                Note: only when "diagnostic_surface_height" is enabled.
c     dspper  = averaging period for "diagnostic_surface_height"
c
c     tavgint = number of days between regional tracer averages (under
c               horizontal regions).
c
c     itavg   = (true,false) = (do,don`t) write regional mask info for
c               the tracer average diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     tmbint  = number of days over which tracer equation in averaged
c               in depth and longitude to determine the meridional 
c               balance among storage, divergence, dissipation and 
c               forcing.
c     tmbper  = averaging period for "meridional_tracer_balance"
c
c     itmb    = (true,false) = (do,don`t) write "msktmb" for tracer
c               the meridional balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c
c     tsiint  = number of days between printing of time step integrals.
c
c     stabint = number of days between sampling for various stability
c               criteria.
c
c     snapint = number of days between writing instantaneous samples
c               of data from the MOM grid. note: only when "snapshots"
c               is enabled. see "iounit.h" for more details.
c               all data is at time level "tau" so it is one time step
c               before the date shown in "stamp".
c
c     timavgint= interval (days) for writing time mean data from
c               the "averaging" grid (only when "time_averages" is
c               enabled). if "timavgint" is not an integral number of
c               density time steps,"timavgint" is automatically adjusted
c               to insure this. if the number of days to integrate is
c               not an integral number of "timavgint" then the last
c               averaging period will be less than "timavgint" days.this 
c               may lead to one more averaging period than expected. 
c               see "iounit.h" for more details.
c     timavgper= averaging period for "time_averages"
c
c     xbtint  = averaging period (days) for writing XBT data (only when
c               "xbts" is enabled). if "xbtint" is not an integral
c               number of density time steps, "xbtint" is automatically
c               adjusted to insure this. if the number of days to 
c               integrate is not an integral number of "xbtint" then the
c               last averaging period will be less than "xbtint" days.
c               this may lead to one more averaging period than  
c               expected. see "iounit.h" for more details.
c     xbtper  = averaging period for "xbts"
c
c     zmbcint = number of days between calculation of zonal mean
c               surface boundary conditions (and related  quantities)
c
c     trajint = number of days between writing particle trajectories.
c               particle trajectories are always written on the last
c               time step of the run to allow for restarting.
c
c-----------------------------------------------------------------------
c     outputs from tmngr.F: logical switches
c-----------------------------------------------------------------------
c
c     rundays = integration time in days (from "runlen")
c
c     the following are logical counterparts to the above switches are 
c     set within "tmngr" every time step. logical switches control all
c     decisions about when to do things in MOM.
c
c     cmixts  = (false,true) = (don`t, do) do write estimated mixing
c               coefficients on this time step.
c               based on "cmixint".
c
c     crossts  = (false,true) = (don`t, do) write diapycnal and 
c               isopycnal components of flow on this time step.
c               based on "crossint".
c
c     fctts    = (false,true) = (don`t, do) write difference between 
c               FCT and leapfrog advection on this time step.
c               based on "fctint".
c
c     densityts  = (false,true) = (don`t, do) write density on this time
c               step. based on "densityint".
c               
c
c     exconvts  = (false,true) = (don`t, do) do write temperature change
c               due to explicit convection on this time step.
c               based on "exconvint".
c
c     glents  = (false,true) = (don`t, do) do calculation of global
c               energy integrals on this time step. based on "glenint".
c
c     trmbts  = (false,true) = (don`t, do) do calculation of momentum &
c               tracer term balance on this timestep. based on "trmbint"
c
c     gyrets  = (false,true) = (don`t, do) do calculation of tracer
c               northward transport on this timestep. based on "gyreint"
c
c     vmsfts  = (false,true) = (don`t, do) do calculation of vertical
c               and meridional stream function on this time step.
c               based on "vmsfint"
c
c     tyzts   = (false,true) = (don`t, do) do calculation of zonally
c               averaged tracer components on this time step.
c               based on "tyzint"
c
c     prxzts  = (false,true) = (don`t, do) do printouts of x-z data
c               on this time step. based on "prxzint"
c
c     extts  = (false,true) = (don`t, do) do printout of external mode
c               on this time step. based on "extint"
c
c     dspts  = (false,true) = (don`t, do) do calculation of diagnostic 
c              surface pressure on this time step. based on "dspint"
c               
c
c     stabts  = (false,true) = (don`t, do) test for stability on this
c               time step. based on "stabint"
c
c     tavgts  = (false,true) = (don`t do) do tracer averages on this
c               time step. based on "tavgint"
c
c     tmbts   = (false,true) = (don`t, do) write out tracer meridional .
c               balance on this time step. based on "tmbint"
c
c     tsits   = (false,true) = (don`t, do) print time step integrals
c               on this time step. based on "tsiint"
c
c     zmbcts  = (false,true) = (don`t, do) print zonal mean boundary
c               conditions on this time step.  based on "zmbcint"
c
c     trajts  = (false,true) = (don`t, do) print particle trajectories
c               on this time step. based on "trajint"
c
c     snapts  = (false,true) = (don`t, do) save a snapshot of the data
c               on this time step. based on "snapint"
c
c     timats  = (false,true) = (don`t, do) write time mean data
c               on this time step. based on "timavgint"
c                                          
c     xbtts   = (false,true) = (don`t, do) write averaged XBT data on
c               this time step based on "xbtint"
c
c
c     leapfrog= (false,true) on a (mixing, normal leapfrog) time step
c                based on "nmix"
c                                          
c     euler1  = true on the 1st pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     euler2  = true on the 2nd pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     forward = true on a forward time step. otherwise false
c		(applies when "eb" = false)		  
c                                          
c
c     the following logical switches are based on the model time step. 
c    
c     first   = (true,false) =  when it`s (the first, not the first)
c                               time step of a run
c     eots    = end of a time step. always true except for first
c               pass of an euler backward time step
c     eorun   = last time step of a run. always false except during the
c               last time step of the run.
c
c     eoday   = true when within 1/2 time step of the end of a day
c               else ... false
c     eoweek  = true when within 1/2 time step of the end of a 7 day
c               week (referenced to the start of a year) else ...false
c     eo2wks  = true when within 1/2 time step of the end of two weeks
c               (referenced to the start of a year) else ... false
c     midmon  = true when within 1/2 time step of the middle of a month
c               else ... false
c     eomon   = true when within 1/2 time step of the end of a month
c               else ... false
c     eoyear  = true when within 1/2 time step of the end of a year
c               else ... false
c     osegs   = true on the 1st time step of an ocean segment in mom.F
c               otherwise false.
c     osege  =  true on the last time step of an ocean segment in mom.F
c               otherwise false.
c
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c
c
      logical eb, leapfrog, euler1, euler2, forward, eots
      logical init, first, restrt
      logical itavg, itmb, itrmb, igyre
      character *8 rununits
c
      common /switcc/ rununits
      common /switcr/ runlen, rundays
      common /switci/ nmix
      common /switcl/ eb, leapfrog, euler1, euler2, forward, eots
      common /switcl/ init, first, restrt
      common /switcl/ itavg, itmb, itrmb, igyre
c
      logical          eoday, eoweek, eo2wks
      common /switci/ ieoday,ieoweek,ieo2wks
      common /switcl/  eoday, eoweek, eo2wks
c
      logical          eomon, midmon, eoyear, eorun
      common /switci/ ieomon,imidmon,ieoyear,ieorun
      common /switcl/  eomon, midmon, eoyear, eorun
c
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c     each interval switch needs three variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output (e.g,.  glenint)
c         2) a switch (logical) for the interval (e.g.,  glents )
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c         3) an index (integer)                       (e.g., iglenint)
c
c     the user must specify the interval [e.g., glenint] for diagnostic
c     output in units of days. tmngr sets the corresponding logical  
c     switch [e.g., glents] every time step. It is set to true when  
c     within half a time step of the requested interval, otherwise it is
c     false. All decisions relating to the interval [e.g., glenint]
c     are based on the logical switch [e.g., glents].
c           
c     internal time structures
c
c     The switch index [e.g., iglenint] is used to subsrcipt into  
c     internal arrays maintained by tmngr.F. The switch index is
c     allocated on the first call to function "alarm".
c     The array entry [e.g., iinterval(iglenint)] is a time index to the
c     internal representation of the interval [e.g., glenint].
c     The array entry [e.g., ialarm(iglenint)] is a time index to the
c     next time the alarm will be true.
c-----------------------------------------------------------------------
c
      logical           tavgts,    glents,    trmbts,   prxzts
      common /switcr/   tavgint,   glenint,   trmbint,  prxzint
      common /switci/  itavgint,  iglenint,  itrmbint, iprxzint
      common /switcl/   tavgts,    glents,    trmbts,   prxzts
c
      logical          extts,   trajts,   exconvts,   cmixts
      common /switcr/  extint,  trajint,  exconvint,  cmixint
      common /switci/ iextint, itrajint, iexconvint, icmixint
      common /switcl/  extts,   trajts,   exconvts,   cmixts
c
      logical          vmsfts,   gyrets,    tsits,   snapts,   fctts
      common /switcr/  vmsfint,  gyreint,   tsiint,  snapint,  fctint
      common /switci/ ivmsfint, igyreint,  itsiint, isnapint, ifctint
      common /switcl/  vmsfts,   gyrets,    tsits,   snapts,   fctts
c
      logical          tyzts
      common /switcr/  tyzint
      common /switci/ ityzint
      common /switcl/  tyzts
c
      logical          stabts,   zmbcts,   crossts,   densityts
      common /switcr/  stabint,  zmbcint,  crossint,  densityint
      common /switci/ istabint, izmbcint, icrossint, idensityint
      common /switcl/  stabts,   zmbcts,   crossts,   densityts
c
      logical          osegs,  osege
      common /switcr/          segtim
      common /switci/ iosegs, iosege
      common /switcl/  osegs,  osege
c   
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c              A N D   A V E R A G I N G   P E R I O D
c
c     each averaging period switch needs five variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output    (e.g. xbtint  )   
c         2) a switch (logical) for the interval         (e.g. xbtts   )
c         3) an averaging period (real)                  (e.g. xbtper  )   
c         4) a switch (logical) for accumulating         (e.g. xbtperts)
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switches
c
c         5) an index (integer)                         (e.g. ixbtint  )
c
c     The user must specify the interval [e.g., xbtint] for diagnostic
c     output in units of days and the averaging period [e.g., xbtper] 
c     in units of days. The averaging period may be less than or equal
c     to the interval. For example, if the interval is 30.0 days and the
c     averaging period is 5.0 days, results will be averaged over all
c     time steps within days 26, 27, 28, 29, and 30.  An averaging period
c     of 0.0 days averages over the last time step of the interval (as
c     does xbtper = dt), and an averaging period less than zero turns
c     the switches off for all time steps.  
c
c     The logical switch for writing output at the specified interval 
c     [e.g., xbtts] is set to true on the last time step of the 
c     averaging period. The logical switch for accumulating results
c     [e.g., xbtperts] is true for all time steps within the averaging
c     period, otherwise it is false. 
c
c     internal time structures
c
c     The index [e.g., ixbtint] is allocated on the first call to 
c     function "avg_alarm". The array element iperiod(ixbtint) is an
c     index to the time structure for the internal representation of 
c     "xbtper", and ilastsw(ixbtint) is the index of the switch that 
c     flags the last time step of the accumulation period.
c     Depending on use,  ilastsw(ixbtint) may either be the index
c     of another "named" switch or the index of a new switch
c     allocated on the first time step.
c     In the latter case, iinterval(ilastsw(ixbtint)) is the index of
c     the time structure where "xbtint" is stored in internal form,
c     and ialarm(ilastsw(ixbtint)) is the index of the time when an
c     accumulation period will next end.
c     The variable nextts(ixbtint) is true whenever the next
c     time step will begin the accumulation period.
c
c-----------------------------------------------------------------------
c
      logical         xbtts,     dspts,    tmbts,    timavgts
      logical         xbtperts,  dspperts, tmbperts, timavgperts
      common /switcr/ xbtint,    dspint,   tmbint,   timavgint
      common /switcr/ xbtper,    dspper,   tmbper,   timavgper
      common /switci/ixbtint,   idspint,  itmbint,  itimavgint
      common /switcl/ xbtts,     dspts,    tmbts,    timavgts
      common /switcl/ xbtperts,  dspperts, tmbperts, timavgperts
c
c-----------------------------------------------------------------------
c
c                 S W I T C H E S    B A S E D    O N    
c
c         C A L E N D A R   O R    P R E V I O U S    S W I T C H   
c
c               A N D   A V E R A G I N G    P E R I O D
c
c    
c
c     the following logical switches are based on any calendar or 
c     interval switch and an averaging period (in days). The  averaging
c     period must be less than or equal to the interval. The last
c     time step of the averaging period is at the end of the interval.
c     If the averaging period is set to zero, the averaging period
c     consists only of the last time period of the interval.  If
c     the averaging period is less than zero, these switches are always
c     false.
c
c     each averaging period switch needs four variables in common. For
c     example, if the averaging period is before the end of each month
c     then the calendar switch (eomon), and index (ieomon) are presumed
c     to exist in common and need not be added.
c     
c     Additionally, four items are needed.
c
c       1) an averaging period (real)                  (e.g.  testper  )   
c       2) a switch (logical) for accumulating results (e.g.  testperts)
c       3) a switch (logical) for the end of interval  (e.g.  testts   )
c
c     the fourth is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c       4) an index (integer)                          (e.g.  itestper )
c
c     Suppose it is required to produce averages over all time steps
c     during the last 5 days of each month. Then "testper" = 5.0 and 
c     the following will calculate the accumulating switch.
c
c      testts = avg_alarm(itestper, ihalfstep, 0, testper, iref, ieomon)
c      testperts = on(itestper)
c
c     Note the use of "ieomon" to key off the months.  The switch
c     "testts" will be true whenever "eomon" is true.
c     Also note that when an averaging switch is keyed off another
c     switch, the switch inverval argument is not used, but is 
c     retained for consistency with the form of other averaging
c     switches.
c-----------------------------------------------------------------------
c
      logical           testperts
      logical           testts
      common /switcr/   testint
      common /switcr/   testper
      common /switci/  itestper
      common /switcl/   testts
      common /switcl/   testperts

c
      parameter (maxsw=100)
      logical          on, lastts, nextts
      common /switci/  nsw  
      common /switci/  ialarm(maxsw), iinterval(maxsw), iperiod(maxsw)
     &,                ilastsw(maxsw)
      common /switcl/  on(maxsw), lastts(maxsw), nextts(maxsw)
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c

 
c     namelist /contrl/ init, runlen, rununits, segtim, restrt, initpt
c    &,                 num_processors
c     namelist /mbcin/  mapsbc, sbcname, dunits, coabc, crits
c    &,                 numpas, bwidth, taux0, tauy0
c     namelist /tsteps/ dtts, dtuv, dtsf
c     namelist /riglid/ mxscan, sor, tolrsf, tolrsp, tolrfs
c     namelist /mixing/ am, ah, ambi, ahbi
c    &,                 kappa_m, kappa_h, cdbot
c    &,                 spnep, senep
c    &,                 aidif
c    &,                 ncon, nmix, eb, acor, dampts, dampdz, annlev
c     namelist /diagn/  tsiint, tavgint, itavg, tmbint, tmbper, itmb
c    &,                 stabint, zmbcint, glenint, trmbint, itrmb
c    &,                 vmsfint, gyreint,igyre, extint, prxzint, trajint
c    &,                 exconvint, dspint, dspper, snapint, snapls
c    &,                 snaple, snapde, timavgint, timavgper, cmixint 
c    &,                 prlat, prslon, prelon, prsdpt, predpt
c    &,                 slatxy, elatxy, slonxy, elonxy
c    &,                 cflons, cflone, cflats, cflate, cfldps, cfldpe
c    &,                 maxcfl, xbtint, xbtper, crossint, densityint
c    &,                 fctint, tyzint
c     namelist /io/     expnam, iotavg 
c    &,                 iotmb, iotrmb
c    &,                 ioglen, iovmsf, iogyre
c    &,                 ioprxz, ioext, iodsp, iotsi, iozmbc, iotraj
c    &,                 ioxbt
c     namelist /ictime/ year0, month0, day0, hour0, min0, sec0
c    &,                 ryear, rmonth, rday, rhour, rmin, rsec
c    &,                 refrun, refinit, refuser, eqyear, eqmon, monlen
c     namelist /uvic/   pocnin, pocnout, mxnsf, mxnwsf
c
c-----------------------------------------------------------------------
c     initialize variables
c-----------------------------------------------------------------------
c     
      tsiint    = 1.0
      tavgint   = -365.25
      itavg     = .true.
      snapint   = -365.25
      timavgint = -365.25
      timavgper = 365.0
      mxnsf     = 12
      mxnwsf    = 1
      restrt    = .false.
      iotavg    = -1
      iotsi     = -1
c
c-----------------------------------------------------------------------
c     time at initial conditions.
c-----------------------------------------------------------------------
c
      year0  =1
      month0 =1
      day0   =1
      hour0  =0
      min0   =0
      sec0   =0
c
c-----------------------------------------------------------------------
c     set whether calculations for logical switches are referenced to
c
c     refrun  = T ==>  the start of each run
c     refinit = T ==>  initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  user specified reference time
c                     ryear, rmonth, rday, rhour, rmin, rsec
c
c     choose by setting one of the above to TRUE
c-----------------------------------------------------------------------
c
      refrun  = .true.
      refinit = .false.
      refuser = .false.
c
c     set the date and time for referencing switches
c     (only needed if rfuser = .T.)
c
      ryear  = 1900
      rmonth = 1
      rday   = 1
      rhour  = 0
      rmin   = 0
      rsec   = 0
c
c-----------------------------------------------------------------------
c     set type of year (eqyear = F => real calendar with leap years)
c                      (eqyear = T => idealized calendar)
c
c     if calendar is idealized then there are two choices:
c     eqmon = F => the usual number of days per month (31, 28, 31, ...)
c                  and the length of a year is 365 days
c                  (monlen is not used in this case)
c     eqmon = T => a fixed number of days per month set by "monlen"
c                  and the length of a year is 12*monlen
c-----------------------------------------------------------------------
c
      eqyear   = .true.
      eqmon    = .true.
      monlen   = 30
c
c     misc variables
c
      momver   = ' GFDL MOM 2 version 2 (beta)'
      expnam   = ' MOM test case  '
      init     =.true.
      numpas   = 100
c
c     initialize ifdef list
c
      do n=1,ifdmax
        cifdef(n) = '                              '
      enddo
c
      nifdef = 0
      cifdef(1) = 'no ifdefs enabled (turned on)'
c
c     damping time scales and depths for test case
c
      do n=1,nt
        dampts(n)    = 50.0
        dampdz(n)    = 26.575e2
      enddo
c
c     physical constants
c
      rho0     = 1.035
      rho0r    = c1/rho0
      grav     = 980.6
      radius   = 6370.0e5
c
c     convert snapshot interval from keeps to writes
c
      if (mxnwsf .lt. 1) mxnwsf = 1
      if (snapint/mxnwsf .lt. dtts*secday) mxnwsf = 1
      snapint = snapint/mxnwsf
c
c     initialize number of snapshot files and number of writes counters
      nsfc = 1
      nwsfc = 0


c
c-----------------------------------------------------------------------
c     read grid definition
c-----------------------------------------------------------------------
c
      call grids
c
c-----------------------------------------------------------------------
c     read land mask kmt
c-----------------------------------------------------------------------
c
      do i=1,imt
      do j=1,jmt
      kmt(i,j)=1
      end do
      end do
c
      return
      end
      subroutine size_check(imt2, jmt2, km2, sub, option)
c
c-----------------------------------------------------------------------
c     check that array bounds (imt2, jmt2, km2) = (imt, jmt, km)
c
c     inputs:
c       imt2 = input value for imt
c       jmt2 = input value for jmt
c       km2  = input value for km
c       sub  = name of the subroutine requesting the size check
c       option = what to do if size check fails:
c              'stop' is the only option
c
c     author:  c. h. goldberg             e-mail chg@gfdl.gov
c-----------------------------------------------------------------------
c
      character *(*) sub, option
      character *60 msg
c====================== include file "size.h" ==========================
c                                                                       
c-----------------------------------------------------------------------
c     USER INPUT: 
c-----------------------------------------------------------------------
c
c     imt    = number of grid points in the longitudinal direction
c              (calculated points are from 2 through imt-1. End points
c               are boundaries)          
c
c     jmt    = number of grid points (latitude rows) in the latitudinal
c              direction (calculated points are from 2 through jmt-1.           
c              End points are boundaries)   
c                                
c     km     = number of grid points in the vertical direction          
c              (calculated points are from 1 through km)
c
c     nt     = number of tracers (temperature, salinity, ...)
c
c     mnisle = maximum number of islands (unconnected land masses)
c
c     maxipp = maximum number of all island perimeter points
c-----------------------------------------------------------------------
c                                                                       
      parameter (imt=  92, jmt=  61, km= 15)
      parameter (nt=2)
      parameter (nat=2)
      parameter (mnisle=50, maxipp=5000)
c

c






c
c-----------------------------------------------------------------------
c     END USER INPUT
c-----------------------------------------------------------------------
c                                                                       
c-----------------------------------------------------------------------
c     By default, the MW (memory window) is 2nd order except for the
c     following options which require a 4th order MW 
c
c     for 2nd order schemes, the minimum sized MW is 3 latitude rows
c     for 4th order schemes, the minimum sized MW is 4 latitude rows
c                            (5 if using coarse_grained_parallelism)
c-----------------------------------------------------------------------
c













c
c-----------------------------------------------------------------------
c     set MW (memory window) size "jmw" 
c-----------------------------------------------------------------------
c                                                                       

c
c     for UNI-TASKING: "jmw" is set to the minimum for each option class 
c     "jmw" may be increased up to "jmt" 
c

      parameter (jmw=jmt)


c
c-----------------------------------------------------------------------
c     set first and last calculated row within the MW. other rows
c     are used as buffers
c-----------------------------------------------------------------------
c
c     jsmw   = 1st calculated row within the MW     
c     jemw   = last calculated row within the MW
c
      parameter (jsmw=2, jemw=jmw-1)
c
c
c     jextra = extra buffer rows needed for coarse_grained_parallelism.
c              "jextra" rows are added to the top and bottom of the MW
c              so the MW size increases by 2*jextra       
c

          parameter (jextra = 0)







c
      if (imt .ne. imt2 .or. jmt .ne. jmt2 .or. km .ne. km2) then
        print '(a/2(a,i4,a,i4,a,i4,a,a,/))', '==>Error:  size_check '
     &,       'imt = ', imt2, '  jmt = ',jmt2,'  km = ',km2
     &,       ' in ', sub
     &,       'imt = ', imt, '  jmt = ',jmt,'  km = ',km
     &,       ' in "size.h"'
        print '(/,a,a,a)'
     &,       'Sizes in ',sub,' are incompatible with "size.h"'
	stop
      end if
      return
      end

      subroutine sslugm(n, b, x, nelt, ia, ja, a, isym, nsave,
     $     itol, tol, itmax, iter, err, ierr, iunit, rwork, lenw,
     $     iwork, leniw )



      integer   locrb, locib
      parameter (locrb=1, locib=11)

      integer  n, nelt, ia(nelt), ja(nelt), isym, nsave, itol
      integer  itmax, iter, ierr, iunit, lenw, iwork(leniw), leniw
      integer   lociw, locl, locnc, locju, locnr, myitol
      integer   locw, locrgw, locdin, locu, locjl, lociu, locil
      integer   j, locigw, jbgn, jend, icol, nl, nu
      real     b(n), x(n), a(nelt), tol, err, rwork(lenw)
      external ssmv, sslui

c
c         change the slap input matrix ia, ja, a to slap-column format.
c***first executable statement  sslugm
      ierr = 0
      err  = 0.0
      if( nsave.le.1 ) then
         ierr = 3
         return
      endif
c      write(*,*) 'sslugm:  changing data structure'
      call ss2y( n, nelt, ia, ja, a, isym )
c
c         count number of non-zero elements preconditioner ilu matrix.
c         then set up the work arrays.  we assume maxl=kmp=nsave.
c      write(*,*) 'sslugm:  counting non-zeros'
      nl = 0
      nu = 0
      do 20 icol = 1, n
c         don't count diagonal.
         jbgn = ja(icol)+1
         jend = ja(icol+1)-1
         if( jbgn.le.jend ) then

            do 10 j = jbgn, jend
               if( ia(j).gt.icol ) then
                  nl = nl + 1
                  if( isym.ne.0 ) nu = nu + 1
               else
                  nu = nu + 1
               endif
 10         continue
         endif
 20   continue
c         
c      write(*,*) 'nl,nu =', nl,nu
      locigw = locib
      locil = locigw + 20
      locjl = locil + n+1
      lociu = locjl + nl
      locju = lociu + nu
      locnr = locju + n+1
      locnc = locnr + n
      lociw = locnc + n
c
      locl = locrb
      locdin = locl + nl
      locu = locdin + n
      locrgw = locu + nu
      locw = locrgw + 1+n*(nsave+6)+nsave*(nsave+3)
c
c         check the workspace allocations.
c      write(*,*) 'sslugm:  checking the workspace allocations.'
      call schkw( 'sslugm', lociw, leniw, locw, lenw, ierr, 
     &		iter, err )
      if( ierr.ne.0 ) return
c
      iwork(1) = locil
      iwork(2) = locjl
      iwork(3) = lociu
      iwork(4) = locju
      iwork(5) = locl
      iwork(6) = locdin
      iwork(7) = locu
      iwork(9) = lociw
      iwork(10) = locw
c
c         compute the incomplete lu decomposition.
c      write(*,*) 'sslugm:  computing ilu factors'
      call ssilus( n, nelt, ia, ja, a, isym, nl, iwork(locil),
     $     iwork(locjl), rwork(locl), rwork(locdin), nu, 
     $	   iwork(lociu),
     $     iwork(locju), rwork(locu), iwork(locnr), iwork(locnc) )
c         
c         perform the incomplet lu preconditioned generalized minimum
c         residual iteration algorithm.  the following sgmres 
c         defaults are used maxl = kmp = nsave, jscal = 0,
c         jpre = -1, nrmax = itmax/nsave
      iwork(locigw  ) = nsave
      iwork(locigw+1) = nsave
      iwork(locigw+2) = 0
      iwork(locigw+3) = -1
      iwork(locigw+4) = itmax/nsave
      myitol = 0
c      
c      write(*,*) 'sslugm:  starting gmres iteration, itmax',itmax

      call sgmres( n, b, x, nelt, ia, ja, a, isym, ssmv, sslui,
     $     myitol, tol, itmax, iter, err, ierr, iunit, rwork, 
     $	   rwork,
     $     rwork(locrgw), lenw-locrgw, iwork(locigw), 20,
     $     rwork, iwork )
c
c	write(*,*) ' iter, itmax = ', iter, itmax

      if( iter.gt.itmax ) ierr = 2


      return
c------------- last line of sslugm follows ----------------------------
      end


      subroutine ss2y(n, nelt, ia, ja, a, isym )


c***begin prologue  ss2y
c***date written   871119   (yymmdd)
c***revision date  881213   (yymmdd)
c***category no.  d2a4, d2b4
c***keywords  library=slatec(slap),
c             type=single precision(ss2y-s),
c             linear system, slap sparse
c***author  seager, mark k., (llnl)
c             lawrence livermore national laboratory
c             po box 808, l-300
c             livermore, ca 94550 (415) 423-3141
c             seager@lll-crg.llnl.gov
c***purpose  slap triad to slap column format converter.
c            routine to convert from the slap triad to slap column
c            format.
c***description
c *usage:
c     integer n, nelt, ia(nelt), ja(nelt), isym
c     real    a(nelt)
c
c     call ss2y( n, nelt, ia, ja, a, isym )
c
c *arguments:
c n      :in       integer
c         order of the matrix.
c nelt   :in       integer.
c         number of non-zeros stored in a.
c ia     :inout    integer ia(nelt).
c ja     :inout    integer ja(nelt).
c a      :inout    real a(nelt).
c         these arrays should hold the matrix a in either the slap
c         triad format or the slap column format.  see "long 
c         description", below.  if the slap triad format is used
c         this format is translated to the slap column format by
c         this routine.
c isym   :in       integer.
c         flag to indicate symmetric storage format.
c         if isym=0, all nonzero entries of the matrix are stored.
c         if isym=1, the matrix is symmetric, and only the lower
c         triangle of the matrix is stored.
c
c *precision:           single precision
c
c       the sparse linear algebra package (slap) utilizes two matrix
c       data structures: 1) the  slap triad  format or  2)  the slap
c       column format.  the user can hand this routine either of the
c       of these data structures.  if the slap triad format is give
c       as input then this routine transforms it into slap column
c       format.  the way this routine tells which format is given as
c       input is to look at ja(n+1).  if ja(n+1) = nelt+1 then we
c       have the slap column format.  if that equality does not hold
c       then it is assumed that the ia, ja, a arrays contain the 
c       slap triad format.
c
c***references  (none)
c***routines called  qs2i1r
c***end prologue  ss2y
      integer n, nelt, ia(nelt), ja(nelt), isym
      integer i, itemp, ibgn, iend, icol, j
      real    a(nelt), temp
c
c         check to see if the (ia,ja,a) arrays are in slap column 
c         format.  if it's not then transform from slap triad.
c***first executable statement  ss2lt
      if( ja(n+1).eq.nelt+1 ) return
c
c         sort into ascending order by column (on the ja array).
c         this will line up the columns.
c
      call qs2i1r( ja, ia, a, nelt, 1 )
c         
c         loop over each column to see where the column indicies change 
c         in the column index array ja.  this marks the beginning of the 
c         next column.
c         
cvd$r novector
      ja(1) = 1
      do 20 icol = 1, n-1
         do 10 j = ja(icol)+1, nelt
            if( ja(j).ne.icol ) then
               ja(icol+1) = j
               goto 20
            endif
 10      continue
 20   continue
      ja(n+1) = nelt+1
c         
c         mark the n+2 element so that future calls to a slap routine 
c         utilizing the ysmp-column storage format will be able to tell.
c         
      ja(n+2) = 0
c
c         now loop thru the ia(i) array making sure that the diagonal
c         matrix element appears first in the column.  then sort the
c         rest of the column in ascending order.
c
      do 70 icol = 1, n
         ibgn = ja(icol)
         iend = ja(icol+1)-1
         do 30 i = ibgn, iend
            if( ia(i).eq.icol ) then
c         swap the diag element with the first element in the column.
               itemp = ia(i)
               ia(i) = ia(ibgn)
               ia(ibgn) = itemp
               temp = a(i)
               a(i) = a(ibgn)
               a(ibgn) = temp
               goto 40
            endif
 30      continue
 40      ibgn = ibgn + 1
         if( ibgn.lt.iend ) then
            do 60 i = ibgn, iend
               do 50 j = i+1, iend
                  if( ia(i).gt.ia(j) ) then
                     itemp = ia(i)
                     ia(i) = ia(j)
                     ia(j) = itemp
                     temp = a(i)
                     a(i) = a(j)
                     a(j) = temp
                  endif
 50            continue
 60         continue
         endif
 70   continue

      return
c------------- last line of ss2y follows ----------------------------
      end



      subroutine schkw( name, lociw, leniw, locw, lenw,
     $     ierr, iter, err )

c***begin prologue  schkw
c***date written   880225   (yymmdd)
c***revision date  881213   (yymmdd)
c***category no.  r2
c***keywords  library=slatec(slap),
c             type=single precision(schkw-s),
c             slap, error checking, workspace checking
c***author  seager, mark k., (llnl)
c             lawrence livermore national laboratory
c             po box 808, l-300
c             livermore, ca 94550 (415) 423-3141
c             seager@lll-crg.llnl.gov
c***purpose  slap work/iwork array bounds checker.
c            this routine checks the work array lengths  and  inter-
c            faces to the slatec  error  handler  if  a  problem  is 
c            found.
c***description
c *usage:
c     character*(*) name
c     integer lociw, leniw, locw, lenw, ierr, iter
c     real    err
c
c     call schkw( name, lociw, leniw, locw, lenw, ierr, iter, err )
c
c *arguments:
c name   :in       character*(*).
c         name of the calling routine.  this is used in the output
c         message, if an error is detected.
c lociw  :in       integer.
c         location of the first free element in the integer workspace
c         array.
c leniw  :in       integer.
c         length of the integer workspace array.
c locw   :in       integer.
c         location of the first free element in the real workspace
c         array.
c lenrw  :in       integer.
c         length of the real workspace array.
c ierr   :out      integer.
c         return error flag.
c               ierr = 0 => all went well.
c               ierr = 1 => insufficient storage allocated for 
c                           work or iwork.
c iter   :out      integer.
c         set to 0 if an error is detected.
c err    :out      real.
c         set to a very large number if an error is detected.
c
c *precision:           single precision
c
c***references  (none)
c***routines called  r1mach, xerrwv
c***end prologue  schkw
      character*(*) name
      character*72 mesg
      integer lociw, leniw, locw, lenw, ierr, iter
      real    err, r1mach
      external r1mach, xerrwv
c
c         check the integer workspace situation.
c***first executable statement  schkw
      ierr = 0
      if( lociw.gt.leniw ) then
         ierr = 1
         iter = 0
         err = r1mach(2)
         mesg = name // ': integer work array too short. '//
     $        ' iwork needs i1: have allocated i2.'
         call xerrwv( mesg, len(mesg), 1, 1, 2, lociw, leniw,
     $        0, 0.0, 0.0 )
      endif
c
c         check the real workspace situation.
      if( locw.gt.lenw ) then
         ierr = 1
         iter = 0
         err = r1mach(2)
         mesg = name // ': real work array too short. '//
     $        ' rwork needs i1: have allocated i2.'
         call xerrwv( mesg, len(mesg), 1, 1, 2, locw, lenw,
     $        0, 0.0, 0.0 )
      endif

      return
c------------- last line of schkw follows ----------------------------
      end


      subroutine sslui(n, b, x, nelt, ia, ja, a, isym, rwork, iwork)


c***begin prologue  sslui
c***date written   871119   (yymmdd)
c***revision date  881213   (yymmdd)
c***category no.  d2a4
c***keywords  library=slatec(slap),
c             type=single precision(sslui-s),
c             non-symmetric linear system solve, sparse, 
c             iterative precondition
c***author  greenbaum, anne, courant institute
c           seager, mark k., (llnl)
c             lawrence livermore national laboratory
c             po box 808, l-300
c             livermore, ca 94550 (415) 423-3141
c             seager@lll-crg.llnl.gov
c***purpose  slap msolve for ldu factorization.
c            this routine  acts as an  interface between  the   slap
c            generic mslove calling convention and the routine  that 
c            actually computes:     -1
c                              (ldu)  b = x.
c***description
c       see the "description" of sslui2 for the gory details.
c***routines called  sslui2
c***end prologue  sslui
      integer n, nelt, ia(nelt), ja(nelt), isym, iwork(*)
      integer locl, locdin, locu, locju, locil, locjl, lociu
      real    b(n), x(n), a(nelt), rwork(*)
c
c         pull out the locations of the arrays holding the ilu
c         factorization.
c***first executable statement  sslui
      locil = iwork(1)
      locjl = iwork(2)
      lociu = iwork(3)
      locju = iwork(4)
      locl = iwork(5)
      locdin = iwork(6)
      locu = iwork(7)
c
c         solve the system lux = b
      call sslui2(n, b, x, iwork(locil), iwork(locjl), rwork(locl),
     $     rwork(locdin), iwork(lociu), iwork(locju), rwork(locu) )
c         

      return
c------------- last line of sslui follows ----------------------------
      end


      subroutine sslui2(n, b, x, il, jl, l, dinv, iu, ju, u )


c***begin prologue  sslui2
c***date written   871119   (yymmdd)
c***revision date  881213   (yymmdd)
c***category no.  d2a4
c***keywords  library=slatec(slap),
c             type=single precision(sslui2-s),
c             non-symmetric linear system solve, sparse, 
c             iterative precondition
c***author  greenbaum, anne, courant institute
c           seager, mark k., (llnl)
c             lawrence livermore national laboratory
c             po box 808, l-300
c             livermore, ca 94550 (415) 423-3141
c             seager@lll-crg.llnl.gov
c***purpose  slap back solve for ldu factorization.
c            routine  to  solve a system of the form  l*d*u x  =  b,
c            where l is a unit  lower  triangular  matrix,  d  is  a 
c            diagonal matrix, and u is a unit upper triangular matrix.
c***description
c *usage:
c     integer n, il(n+1), jl(nl), iu(nu), ju(n+1)
c     real    b(n), x(n), l(nl), dinv(n), u(nu)
c
c     call sslui2( n, b, x, il, jl, l, dinv, iu, ju, u )
c
c *arguments:
c n      :in       integer
c         order of the matrix.
c b      :in       real b(n).
c         right hand side.
c x      :out      real x(n).
c         solution of l*d*u x = b.
c nel    :in       integer.
c         number of non-zeros in the el array.
c il     :in       integer il(n+1).
c jl     :in       integer jl(nl).
c  l     :in       real     l(nl).
c         il, jl, l contain the unit  lower triangular factor of the
c         incomplete decomposition of some matrix stored in slap row
c         format.  the diagonal of ones *is* stored.  this structure
c         can   be   set up  by   the  ssilus routine.   see 
c         "description", below  for more   details about   the  slap
c         format.
c dinv   :in       real dinv(n).
c         inverse of the diagonal matrix d.
c nu     :in       integer.
c         number of non-zeros in the u array.     
c iu     :in       integer iu(n+1).
c ju     :in       integer ju(nu).
c u      :in       real     u(nu).
c         iu, ju, u contain the unit upper triangular factor  of the
c         incomplete decomposition  of  some  matrix stored in  slap
c         column format.   the diagonal of ones  *is* stored.   this
c         structure can be set up  by the ssilus routine.  see
c         "description", below   for  more   details about  the slap
c         format.
c
c *description:
c       this routine is supplied with  the slap package as a routine
c       to  perform  the  msolve operation  in   the  sir and   sbcg
c       iteration routines for  the  drivers ssilur and sslubc.   it
c       must  be called  via   the  slap  msolve  calling   sequence
c       convention interface routine sslui.
c         **** this routine itself does not conform to the ****
c               **** slap msolve calling convention ****
c
c       il, jl, l should contain the unit lower triangular factor of
c       the incomplete decomposition of the a matrix  stored in slap
c       row format.  iu, ju, u should contain  the unit upper factor
c       of the  incomplete decomposition of  the a matrix  stored in
c       slap column format this ilu factorization can be computed by
c       the ssilus routine.  the diagonals (which is all one's) are
c       stored.
c
c       =================== s l a p column format ==================
c       this routine  requires that  the matrix a  be stored in  the
c       slap column format.  in this format the non-zeros are stored
c       counting down columns (except  for the diagonal entry, which
c       must appear first in each  "column") and  are stored  in the
c       real array a.  in other words, for each column in the matrix
c       put the diagonal entry in a.  then put in the other non-zero
c       elements going down   the  column (except  the diagonal)  in
c       order.  the ia array holds the row  index for each non-zero.
c       the ja array holds the offsets into the ia, a arrays for the
c       beginning of   each    column.    that  is,    ia(ja(icol)),
c       a(ja(icol)) points to the beginning of the icol-th column in
c       ia and  a.  ia(ja(icol+1)-1),  a(ja(icol+1)-1) points to the
c       end  of   the icol-th  column.  note   that  we  always have
c       ja(n+1) = nelt+1, where  n  is the number of columns in  the
c       matrix and  nelt   is the number of non-zeros in the matrix.
c       
c       here is an example of the  slap column  storage format for a
c       5x5 matrix (in the a and ia arrays '|'  denotes the end of a 
c       column):
c
c           5x5 matrix      slap column format for 5x5 matrix on left.
c                              1  2  3    4  5    6  7    8    9 10 11
c       |11 12  0  0 15|   a: 11 21 51 | 22 12 | 33 53 | 44 | 55 15 35
c       |21 22  0  0  0|  ia:  1  2  5 |  2  1 |  3  5 |  4 |  5  1  3
c       | 0  0 33  0 35|  ja:  1  4  6    8  9   12
c       | 0  0  0 44  0|
c       |51  0 53  0 55|
c
c       ==================== s l a p row format ====================
c       this routine requires  that the matrix a  be  stored  in the
c       slap  row format.   in this format  the non-zeros are stored
c       counting across  rows (except for the diagonal  entry, which
c       must appear first in each "row") and  are stored in the real
c       array a.  in other words, for each row in the matrix put the
c       diagonal entry in  a.   then   put  in the   other  non-zero
c       elements   going  across the  row (except   the diagonal) in
c       order.   the  ja array  holds   the column   index for  each
c       non-zero.   the ia  array holds the  offsets into  the ja, a
c       arrays  for   the   beginning  of   each  row.   that    is,
c       ja(ia(irow)),  a(ia(irow)) points  to  the beginning  of the
c       irow-th row in ja and a.   ja(ia(irow+1)-1), a(ia(irow+1)-1)
c       points to the  end of the  irow-th row.  note that we always
c       have ia(n+1) =  nelt+1, where  n  is  the number of rows  in
c       the matrix  and nelt  is the  number   of  non-zeros in  the
c       matrix.
c       
c       here is an example of the slap row storage format for a  5x5
c       matrix (in the a and ja arrays '|' denotes the end of a row):
c
c           5x5 matrix         slap row format for 5x5 matrix on left.
c                              1  2  3    4  5    6  7    8    9 10 11
c       |11 12  0  0 15|   a: 11 12 15 | 22 21 | 33 35 | 44 | 55 51 53
c       |21 22  0  0  0|  ja:  1  2  5 |  2  1 |  3  5 |  4 |  5  1  3
c       | 0  0 33  0 35|  ia:  1  4  6    8  9   12
c       | 0  0  0 44  0|  
c       |51  0 53  0 55|  
c
c       with  the slap  format  the "inner  loops" of  this  routine
c       should vectorize   on machines with   hardware  support  for
c       vector gather/scatter operations.  your compiler may require
c       a  compiler directive  to  convince   it that there  are  no
c       implicit vector  dependencies.  compiler directives  for the
c       alliant fx/fortran and cri cft/cft77 compilers  are supplied
c       with the standard slap distribution.
c
c *precision:           single precision
c *see also:
c       ssilus
c***references  (none)
c***routines called  (none)
c***end prologue  sslui2
      integer n, il(*), jl(*), iu(*), ju(*)
      integer i, icol, irow, j, jbgn, jend
      real    b(n), x(n), l(*), dinv(n), u(*)
c         
c         solve  l*y = b,  storing result in x, l stored by rows.
c***first executable statement  sslui2
      do 10 i = 1, n
         x(i) = b(i)
 10   continue
      do 30 irow = 2, n
         jbgn = il(irow)
         jend = il(irow+1)-1
         if( jbgn.le.jend ) then
clll. option assert (nohazard)
cdir$ ivdep
cvd$ assoc
cvd$ nodepchk
            do 20 j = jbgn, jend
               x(irow) = x(irow) - l(j)*x(jl(j))
 20         continue
         endif
 30   continue
c         
c         solve  d*z = y,  storing result in x.
      do 40 i=1,n
         x(i) = x(i)*dinv(i)
 40   continue
c         
c         solve  u*x = z, u stored by columns.
      do 60 icol = n, 2, -1
         jbgn = ju(icol)
         jend = ju(icol+1)-1
         if( jbgn.le.jend ) then
clll. option assert (nohazard)
cdir$ ivdep
cvd$ nodepchk
            do 50 j = jbgn, jend
               x(iu(j)) = x(iu(j)) - u(j)*x(icol)
 50         continue
         endif
 60   continue
c         

      return
c------------- last line of sslui2 follows ----------------------------
      end


      subroutine ssilus(n, nelt, ia, ja, a, isym, nl, il, jl,
     $     l, dinv, nu, iu, ju, u, nrow, ncol)



c***begin prologue  ssilus
c***date written   871119   (yymmdd)
c***revision date  881213   (yymmdd)
c***category no.  d2a4, d2b4
c***keywords  library=slatec(slap),
c             type=single precision(ssilus-s),
c             non-symmetric linear system, sparse, 
c             iterative precondition, incomplete lu factorization
c***author  greenbaum, anne, courant institute
c           seager, mark k., (llnl)
c             lawrence livermore national laboratory
c             po box 808, l-300
c             livermore, ca 94550 (415) 423-3141
c             seager@lll-crg.llnl.gov
c***purpose  incomplete lu decomposition preconditioner slap set up.
c            routine to generate the incomplete ldu decomposition of a 
c            matrix.  the  unit lower triangular factor l is stored by 
c            rows and the  unit upper triangular factor u is stored by 
c            columns.  the inverse of the diagonal matrix d is stored.
c            no fill in is allowed.
c***description
c *usage:
c     integer n, nelt, ia(nelt), ja(nelt), isym
c     integer nl, il(n+1), jl(nl), nu, iu(n+1), ju(nu)
c     integer nrow(n), ncol(n)
c     real    a(nelt), l(nl), u(nu), dinv(n)
c
c     call ssilus( n, nelt, ia, ja, a, isym, nl, il, jl, l, 
c    $    dinv, nu, iu, ju, u, nrow, ncol )
c
c *arguments:
c n      :in       integer

c         order of the matrix.
c nelt   :in       integer.
c         number of elements in arrays ia, ja, and a.
c ia     :in       integer ia(nelt).
c ja     :in       integer ja(nelt).
c a      :in       real a(nelt).
c         these arrays should hold the matrix a in the slap column
c         format.  see "description", below. 
c isym   :in       integer.
c         flag to indicate symmetric storage format.
c         if isym=0, all nonzero entries of the matrix are stored.
c         if isym=1, the matrix is symmetric, and only the lower 
c         triangle of the matrix is stored.
c nl     :out      integer.
c         number of non-zeros in the el array.
c il     :out      integer il(n+1).
c jl     :out      integer jl(nl).
c l      :out      real     l(nl).
c         il, jl, l  contain the unit ower  triangular factor of  the
c         incomplete decomposition  of some  matrix stored  in   slap
c         row format.     the   diagonal  of ones  *is*  stored.  see
c         "description", below for more details about the slap format.
c nu     :out      integer.
c         number of non-zeros in the u array.     
c iu     :out      integer iu(n+1).
c ju     :out      integer ju(nu).
c u      :out      real     u(nu).
c         iu, ju, u contain   the unit upper triangular factor of the
c         incomplete  decomposition    of some matrix  stored in slap
c         column  format.   the diagonal of ones   *is*  stored.  see 
c         "description", below  for  more  details  about  the   slap 
c         format.
c nrow   :work     integer nrow(n).
c         nrow(i) is the number of non-zero elements in the i-th row
c         of l.
c ncol   :work     integer ncol(n).
c         ncol(i) is the number of non-zero elements in the i-th 
c         column of u.
c
c *description
c       il, jl, l should contain the unit  lower triangular factor of
c       the incomplete decomposition of the a matrix  stored in slap
c       row format.  iu, ju, u should contain  the unit upper factor
c       of the  incomplete decomposition of  the a matrix  stored in
c       slap column format this ilu factorization can be computed by
c       the ssilus routine.  the diagonals (which is all one's) are
c       stored.
c
c *precision:           single precision
c *see also:
c       silur
c***references  1. gene golub & charles van loan, "matrix computations",
c                 john hopkins university press; 3 (1983) ibsn 
c                 0-8018-3010-9.
c***routines called  (none)
c***end prologue  ssilus
      integer n, nelt, ia(nelt), ja(nelt), isym, nl, il(nl), jl(nl)
      integer nu, iu(nu), ju(nu), nrow(n), ncol(n)
      integer i, ibgn, iend, j, jbgn, jend, icol, irow
      integer itemp , jtemp, indx, indx1, indx2, indxr1, indxr2
      integer indxc2, indxc1, k, kc, kr
      real    a(nelt), l(nl), dinv(n), u(nu), temp

c         
c         count number of elements in each row of the lower triangle.
c***first executable statement  ssilus
      !write(*,*) 'ssilus:  counting'
      do 10 i=1,n
         nrow(i) = 0
         ncol(i) = 0
 10   continue
cvd$r noconcur
cvd$r novector
      do 30 icol = 1, n
         jbgn = ja(icol)+1
         jend = ja(icol+1)-1
         if( jbgn.le.jend ) then
            do 20 j = jbgn, jend
               if( ia(j).lt.icol ) then
                  ncol(icol) = ncol(icol) + 1
               else
                  nrow(ia(j)) = nrow(ia(j)) + 1
                  if( isym.ne.0 ) ncol(ia(j)) = ncol(ia(j)) + 1
               endif
 20         continue
         endif
 30   continue
      ju(1) = 1
      il(1) = 1
      do 40 icol = 1, n
         il(icol+1) = il(icol) + nrow(icol)
         ju(icol+1) = ju(icol) + ncol(icol)
         nrow(icol) = il(icol)
         ncol(icol) = ju(icol)
 40   continue
c         
c         copy the matrix a into the l and u structures.
      !write(*,*) 'ssilus:  copying'
      do 60 icol = 1, n
         dinv(icol) = a(ja(icol))
         jbgn = ja(icol)+1
         jend = ja(icol+1)-1
         if( jbgn.le.jend ) then
            do 50 j = jbgn, jend
               irow = ia(j)
               if( irow.lt.icol ) then
c         part of the upper triangle.
                  iu(ncol(icol)) = irow
                  u(ncol(icol)) = a(j)
                  ncol(icol) = ncol(icol) + 1
               else
c         part of the lower triangle (stored by row).
                  jl(nrow(irow)) = icol
                  l(nrow(irow)) = a(j)
                  nrow(irow) = nrow(irow) + 1
                  if( isym.ne.0 ) then
c         symmetric...copy lower triangle into upper triangle as well.
                     iu(ncol(irow)) = icol
                     u(ncol(irow)) = a(j)
                     ncol(irow) = ncol(irow) + 1
                  endif
               endif
 50         continue
         endif
 60   continue
c
c         sort the rows of l and the columns of u.
      !write(*,*) 'ssilus:  sorting'
      do 110 k = 2, n
         jbgn = ju(k)
         jend = ju(k+1)-1
         if( jbgn.lt.jend ) then
            do 80 j = jbgn, jend-1
               do 70 i = j+1, jend
                  if( iu(j).gt.iu(i) ) then
                     itemp = iu(j)
                     iu(j) = iu(i)
                     iu(i) = itemp
                     temp = u(j)
                     u(j) = u(i)
                     u(i) = temp
                  endif
 70            continue
 80         continue
         endif
         ibgn = il(k)
         iend = il(k+1)-1
         if( ibgn.lt.iend ) then
            do 100 i = ibgn, iend-1
               do 90 j = i+1, iend
                  if( jl(i).gt.jl(j) ) then
                     jtemp = ju(i)
                     ju(i) = ju(j)
                     ju(j) = jtemp
                     temp = l(i)
                     l(i) = l(j)
                     l(j) = temp
                  endif
 90            continue
 100        continue
         endif
 110  continue
c
c         perform the incomplete ldu decomposition.
      !write(*,*) 'ssilus:  factoring'
      do 300 i=2,n
c         
c           i-th row of l
         indx1 = il(i)
         indx2 = il(i+1) - 1
         if(indx1 .gt. indx2) go to 200
         do 190 indx=indx1,indx2
            if(indx .eq. indx1) go to 180
            indxr1 = indx1
            indxr2 = indx - 1
            indxc1 = ju(jl(indx))
            indxc2 = ju(jl(indx)+1) - 1
            if(indxc1 .gt. indxc2) go to 180
 160        kr = jl(indxr1)
 170        kc = iu(indxc1)
            if(kr .gt. kc) then
               indxc1 = indxc1 + 1
               if(indxc1 .le. indxc2) go to 170
            elseif(kr .lt. kc) then
               indxr1 = indxr1 + 1
               if(indxr1 .le. indxr2) go to 160
            elseif(kr .eq. kc) then
               l(indx) = l(indx) - l(indxr1)*dinv(kc)*u(indxc1)
               indxr1 = indxr1 + 1
               indxc1 = indxc1 + 1
               if(indxr1 .le. indxr2 .and. indxc1 .le. indxc2) go to 160
            endif
 180        l(indx) = l(indx)/dinv(jl(indx))
 190     continue
c         
c         ith column of u
 200     indx1 = ju(i)
         indx2 = ju(i+1) - 1
         if(indx1 .gt. indx2) go to 260
         do 250 indx=indx1,indx2
            if(indx .eq. indx1) go to 240
            indxc1 = indx1
            indxc2 = indx - 1
            indxr1 = il(iu(indx))
            indxr2 = il(iu(indx)+1) - 1
            if(indxr1 .gt. indxr2) go to 240
 210        kr = jl(indxr1)
 220        kc = iu(indxc1)
            if(kr .gt. kc) then
               indxc1 = indxc1 + 1
               if(indxc1 .le. indxc2) go to 220
            elseif(kr .lt. kc) then
               indxr1 = indxr1 + 1
               if(indxr1 .le. indxr2) go to 210
            elseif(kr .eq. kc) then
               u(indx) = u(indx) - l(indxr1)*dinv(kc)*u(indxc1)
               indxr1 = indxr1 + 1
               indxc1 = indxc1 + 1
               if(indxr1 .le. indxr2 .and. indxc1 .le. indxc2) go to 210
            endif
 240        u(indx) = u(indx)/dinv(iu(indx))
 250     continue
c         
c         ith diagonal element
 260     indxr1 = il(i)
         indxr2 = il(i+1) - 1
         if(indxr1 .gt. indxr2) go to 300
         indxc1 = ju(i)
         indxc2 = ju(i+1) - 1
         if(indxc1 .gt. indxc2) go to 300
 270     kr = jl(indxr1)
 280     kc = iu(indxc1)
         if(kr .gt. kc) then
            indxc1 = indxc1 + 1
            if(indxc1 .le. indxc2) go to 280
         elseif(kr .lt. kc) then
            indxr1 = indxr1 + 1
            if(indxr1 .le. indxr2) go to 270
         elseif(kr .eq. kc) then
            dinv(i) = dinv(i) - l(indxr1)*dinv(kc)*u(indxc1)
            indxr1 = indxr1 + 1
            indxc1 = indxc1 + 1
            if(indxr1 .le. indxr2 .and. indxc1 .le. indxc2) go to 270
         endif
c         
 300  continue
c         
c         replace diagonal lts by their inverses.
cvd$ vector
      do 430 i=1,n
         dinv(i) = 1./dinv(i)
 430  continue
c         

      return
c------------- last line of ssilus follows ----------------------------
      end


      subroutine sgmres(n, b, x, nelt, ia, ja, a, isym, matvec,
     $	   msolve,
     $     itol, tol, itmax, iter, err, ierr, iunit, sb, sx, 
     $     rgwk, lrgw, igwk, ligw, rwork, iwork )


      integer  n, nelt, ia(nelt), ja(nelt), isym, itol, itmax, iter
      integer  iunit, lrgw, ligw, igwk(ligw), iwork(*)
      real     b(n), x(n), tol, err, sb(n), sx(n), a(nelt) 
      real     rgwk(lrgw), rwork(*)
      integer  jpre, kmp, maxl, nms, maxlp1, nmsl, nrsts, nrmax
      integer  i, iflag, lr, ldl, lhes, lgmr, lq, lv, lw
      integer  lz, ierr, lzm1, lxl, jscal
      real     bnrm, rhol, sum, snrm2, r1mach
      external matvec, msolve

c
c***first executable statement  sgmres
      ierr = 0
c   ---------------------------------------------------------------
c         load method parameters with user values or defaults.
c   --------------------------------------------------------------
      maxl = igwk(1)
      if (maxl .eq. 0) maxl = 10 
      if (maxl .gt. n) maxl = n
      kmp = igwk(2)
      if (kmp .eq. 0) kmp = maxl
      if (kmp .gt. maxl) kmp = maxl
      jscal = igwk(3)
      jpre = igwk(4)
c         check for consistent values of itol and jpre.
      if( itol.eq.1 .and. jpre.lt.0 ) goto 650
      if( itol.eq.2 .and. jpre.ge.0 ) goto 650
      nrmax = igwk(5)
      if( nrmax.eq.0 ) nrmax = 10
c         if nrmax .eq. -1, then set nrmax = 0 to 
c		turn off restarting.
      if( nrmax.eq.-1 ) nrmax = 0
c         if input value of tol is zero, set it to its 
c		default value.
      if( tol.eq.0.0e0 ) tol = 500.0*r1mach(3)
c
c         initialize counters.
      iter = 0
      nms = 0
      nrsts = 0
c   ---------------------------------------------------------------
c         form work array segment pointers.
c   --------------------------------------------------------------
      maxlp1 = maxl + 1
      lv = 1
      lr = lv + n*maxlp1
      lhes = lr + n + 1
      lq = lhes + maxl*maxlp1
      ldl = lq + 2*maxl
      lw = ldl + n
      lxl = lw + n
      lz = lxl + n
c
c     load igwk(6) with required minimum length of the rgwk array.
      igwk(6) = lz + n - 1
      if( lz+n-1.gt.lrgw ) goto 640
c   --------------------------------------------------------------
c         calculate scaled-preconditioned norm of rhs vector b.
c   --------------------------------------------------------------
      if (jpre .lt. 0) then
         call msolve(n, b, rgwk(lr), nelt, ia, ja, a, isym,
     $        rwork, iwork)
         nms = nms + 1
      else
         call scopy(n, b, 1, rgwk(lr), 1)
      endif
      if( jscal.eq.2 .or. jscal.eq.3 ) then
         sum = 0.e0
         do 10 i = 1,n
            sum = sum + (rgwk(lr-1+i)*sb(i))**2
 10      continue
         bnrm = sqrt(sum)
      else
         bnrm = snrm2(n,rgwk(lr),1)
      !write(*,*) 'sgmres: jpre, jscal =', jpre, jscal
      !write(*,*) 'sgmres: bnrm, norm(b) =', bnrm, snrm2(n,b,1)
      endif
c   -------------------------------------------------------------
c         calculate initial residual.
c   -------------------------------------------------------------
      call matvec(n, x, rgwk(lr), nelt, ia, ja, a, isym)
      do 50 i = 1,n
         rgwk(lr-1+i) = b(i) - rgwk(lr-1+i)
 50   continue
c   -------------------------------------------------------------
c         if performing restarting, then load the residual into the 
c         correct location in the rgwk array.
c   --------------------------------------------------------------
 100  continue
      if( nrsts.gt.nrmax ) goto 610
      if( nrsts.gt.0 ) then
c    copy the curr residual to different loc in the rgwk array.
         call scopy(n, rgwk(ldl), 1, rgwk(lr), 1)
      endif
c   ------------------------------------------------------------
c         use the spigmr algorithm to solve the linear system a*z = r.
c   -------------------------------------------------------------
      call spigmr(n, rgwk(lr), sb, sx, jscal, maxl, maxlp1, kmp,
     $       nrsts, jpre, matvec, msolve, nmsl, rgwk(lz), rgwk(lv),
     $       rgwk(lhes), rgwk(lq), lgmr, rwork, iwork, rgwk(lw),
     $       rgwk(ldl), rhol, nrmax, b, bnrm, x, rgwk(lxl), itol,
     $       tol, nelt, ia, ja, a, isym, iunit, iflag, err)
      !write(*,*) 'sgmres: rhol =', rhol
      iter = iter + lgmr
      nms = nms + nmsl
c
c         increment x by the current approximate solution z of a*z = r.
c
      lzm1 = lz - 1
      do 110 i = 1,n
         x(i) = x(i) + rgwk(lzm1+i)
 110  continue
      if( iflag.eq.0 ) goto 600
      if( iflag.eq.1 ) then
         nrsts = nrsts + 1
         goto 100
      endif
      if( iflag.eq.2 ) goto 620
c   ------------------------------------------------------------------
c         all returns are made through this section.
c   ------------------------------------------------------------------
c         the iteration has converged.
c
 600  continue
      igwk(7) = nms
      rgwk(1) = rhol
      ierr = 0
      return
c
c         max number((nrmax+1)*maxl) of linear iterations performed.
 610  continue
      igwk(7) = nms
      rgwk(1) = rhol
      ierr = 1
      return
c
c         gmres failed to reduce last residual in maxl iterations.
c         the iteration has stalled.
 620  continue
      igwk(7) = nms
      rgwk(1) = rhol
      ierr = 2
      return
c         error return.  insufficient length for rgwk array.
 640  continue
      err = tol
      ierr = -1
      return
c         error return.  inconsistent itol and jpre values.
 650  continue
      err = tol
      ierr = -2

      return
c------------- last line of sgmres follows ----------------------------
      end


      subroutine scopy(n,sx,incx,sy,incy)

c
c     copies a vector, x, to a vector, y.
c     uses unrolled loops for increments equal to 1.
c     jack dongarra, linpack, 3/11/78.
c
      real sx(*),sy(*)
      integer i,incx,incy,ix,iy,m,mp1,n
c
      if(n.le.0)return
      if(incx.eq.1.and.incy.eq.1)go to 20
c
c        code for unequal increments or equal increments
c          not equal to 1
c
      ix = 1
      iy = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      if(incy.lt.0)iy = (-n+1)*incy + 1
      do 10 i = 1,n
        sy(iy) = sx(ix)
        ix = ix + incx
        iy = iy + incy
   10 continue
      return
c
c        code for both increments equal to 1
c
c
c        clean-up loop
c
   20 m = mod(n,7)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        sy(i) = sx(i)
   30 continue
      if( n .lt. 7 ) return
   40 mp1 = m + 1
      do 50 i = mp1,n,7
        sy(i) = sx(i)
        sy(i + 1) = sx(i + 1)
        sy(i + 2) = sx(i + 2)
        sy(i + 3) = sx(i + 3)
        sy(i + 4) = sx(i + 4)
        sy(i + 5) = sx(i + 5)
        sy(i + 6) = sx(i + 6)
   50 continue

      return
      end


      subroutine qs2i1r( ia, ja, a, n, kflag )


c***begin prologue  qs2i1r
c***date written   761118   (yymmdd)
c***revision date  890125   (yymmdd)
c***category no.  n6a2a
c***keywords  library=slatec(slap),
c             type=integer(qs2i1r-i),
c             quicksort,singleton quicksort,sort,sorting
c***author  jones, r. e., (snla)
c           kahaner, d. k., (nbs)
c           seager, m. k., (llnl) seager@lll-crg.llnl.gov
c           wisniewski, j. a., (snla)
c***purpose  sort an integer array also moving an integer and real array
c            this routine sorts the integer array ia and makes the same
c            interchanges in the integer array ja and the real array a.
c            the array ia may be sorted in increasing order or decreas-
c            ing order. a slightly modified quicksort algorithm is used.
c
c***description
c     written by rondall e jones
c     modified by john a. wisniewski to use the singleton quicksort
c     algorithm. date 18 november 1976.
c
c     further modified by david k. kahaner
c     national bureau of standards
c     august, 1981
c
c     even further modification made to bring the code up to the 
c     fortran 77 level and make it more readable and to carry
c     along one integer array and one real array during the sort by
c     mark k. seager
c     lawrence livermore national laboratory
c     november, 1987
c     this routine was adapted from the isort routine.
c
c     abstract
c         this routine sorts an integer array ia and makes the same
c         interchanges in the integer array ja and the real array a.  
c         the array a may be sorted in increasing order or decreasing 
c         order.  a slightly modified quicksort algorithm is used.
c
c     description of parameters
c        ia - integer array of values to be sorted.
c        ja - integer array to be carried along.
c         a - real array to be carried along.
c         n - number of values in integer array ia to be sorted.
c     kflag - control parameter
c           = 1 means sort ia in increasing order.
c           =-1 means sort ia in decreasing order.
c
c***references
c     singleton, r. c., algorithm 347, "an efficient algorithm for 
c     sorting with minimal storage", cacm, vol. 12, no. 3, 1969, 
c     pp. 185-187.
c***routines called  xerror
c***end prologue  qs2i1r
cvd$r novector
cvd$r noconcur
      dimension il(21),iu(21)
      integer   ia(n),ja(n),it,iit,jt,jjt, k
      integer   kflag, ij, iu, il, l, j, nn, n, m, i, kk
      real      a(n), ta, tta, r
c
c***first executable statement  qs2i1r
      nn = n
      if (nn.lt.1) then
         call xerror ( 'qs2i1r- the number of values to be sorted was no
     $t positive.',59,1,1)
         return
      endif
      if( n.eq.1 ) return
      kk = iabs(kflag)
      if ( kk.ne.1 ) then
         call xerror ( 'qs2i1r- the sort control parameter, k, was not 1
     $ or -1.',55,2,1)
         return
      endif
c
c     alter array ia to get decreasing order if needed.
c
      if( kflag.lt.1 ) then
         do 20 i=1,nn
            ia(i) = -ia(i)
 20      continue
      endif
c
c     sort ia and carry ja and a along.
c     and now...just a little black magic...
      m = 1
      i = 1
      j = nn
      r = .375
 210  if( r.le.0.5898437 ) then
         r = r + 3.90625e-2
      else
         r = r-.21875
      endif
 225  k = i
c
c     select a central element of the array and save it in location 
c     it, jt, at.
c
      ij = i + ifix (float (j-i) *r)
      it = ia(ij)
      jt = ja(ij)
      ta = a(ij)
c
c     if first element of array is greater than it, interchange with it.
c
      if( ia(i).gt.it ) then
         ia(ij) = ia(i)
         ia(i)  = it
         it     = ia(ij)
         ja(ij) = ja(i)
         ja(i)  = jt
         jt     = ja(ij)
         a(ij)  = a(i)
         a(i)   = ta
         ta     = a(ij)
      endif
      l=j
c                           
c     if last element of array is less than it, swap with it.
c
      if( ia(j).lt.it ) then
         ia(ij) = ia(j)
         ia(j)  = it
         it     = ia(ij)
         ja(ij) = ja(j)
         ja(j)  = jt
         jt     = ja(ij)
         a(ij)  = a(j)
         a(j)   = ta
         ta     = a(ij)
c
c     if first element of array is greater than it, swap with it.
c
         if ( ia(i).gt.it ) then
            ia(ij) = ia(i)
            ia(i)  = it
            it     = ia(ij)
            ja(ij) = ja(i)
            ja(i)  = jt
            jt     = ja(ij)
            a(ij)  = a(i)
            a(i)   = ta
            ta     = a(ij)
         endif
      endif
c
c     find an element in the second half of the array which is 
c     smaller than it.
c
  240 l=l-1
      if( ia(l).gt.it ) go to 240
c
c     find an element in the first half of the array which is 
c     greater than it.
c
  245 k=k+1
      if( ia(k).lt.it ) go to 245
c
c     interchange these elements.
c
      if( k.le.l ) then
         iit   = ia(l)
         ia(l) = ia(k)
         ia(k) = iit
         jjt   = ja(l)
         ja(l) = ja(k)
         ja(k) = jjt
         tta   = a(l)
         a(l)  = a(k)
         a(k)  = tta
         goto 240
      endif
c
c     save upper and lower subscripts of the array yet to be sorted.
c
      if( l-i.gt.j-k ) then
         il(m) = i
         iu(m) = l
         i = k
         m = m+1
      else
         il(m) = k
         iu(m) = j
         j = l
         m = m+1
      endif
      go to 260
c
c     begin again on another portion of the unsorted array.
c                                  
  255 m = m-1
      if( m.eq.0 ) go to 300
      i = il(m)
      j = iu(m)
  260 if( j-i.ge.1 ) go to 225
      if( i.eq.j ) go to 255
      if( i.eq.1 ) go to 210
      i = i-1
  265 i = i+1
      if( i.eq.j ) go to 255
      it = ia(i+1)
      jt = ja(i+1)
      ta =  a(i+1)
      if( ia(i).le.it ) go to 265
      k=i
  270 ia(k+1) = ia(k)
      ja(k+1) = ja(k)
      a(k+1)  =  a(k)
      k = k-1
      if( it.lt.ia(k) ) go to 270
      ia(k+1) = it
      ja(k+1) = jt
      a(k+1)  = ta
      go to 265
c
c     clean up, if necessary.
c
  300 if( kflag.lt.1 ) then
         do 310 i=1,nn
            ia(i) = -ia(i)
 310     continue
      endif

      return
c------------- last line of qs2i1r follows ----------------------------
      end

      subroutine xerrwv(messg,nmessg,nerr,level,ni,i1,i2,nr,r1,r2)


c***begin prologue  xerrwv
c***date written   800319   (yymmdd)
c***revision date  851111   (yymmdd)
c***category no.  r3c
c***keywords  error,xerror package
c***author  jones, r. e., (snla)
c***purpose  process an error message allowing 2 integer and 2 real
c            values to be included in the message.
c***description
c
c     abstract
c        xerrwv processes a diagnostic message, in a manner
c        determined by the value of level and the current value
c        of the library error control flag, kontrl.
c        (see subroutine xsetf for details.)
c        in addition, up to two integer values and two real
c        values may be printed along with the message.
c
c     description of parameters
c      --input--
c        messg - the hollerith message to be processed.
c        nmessg- the actual number of characters in messg.
c        nerr  - the error number associated with this message.
c                nerr must not be zero.
c        level - error category.
c                =2 means this is an unconditionally fatal error.
c                =1 means this is a recoverable error.  (i.e., it is
c                   non-fatal if xsetf has been appropriately called.)
c                =0 means this is a warning message only.
c                =-1 means this is a warning message which is to be
c                   printed at most once, regardless of how many
c                   times this call is executed.
c        ni    - number of integer values to be printed. (0 to 2)
c        i1    - first integer value.
c        i2    - second integer value.
c        nr    - number of real values to be printed. (0 to 2)
c        r1    - first real value.
c        r2    - second real value.
c
c     examples
c        call xerrwv('smooth -- num (=i1) was zero.',29,1,2,
c    1   1,num,0,0,0.,0.)
c        call xerrwv('quadxy -- requested error (r1) less than minimum (
c    1r2).,54,77,1,0,0,0,2,errreq,errmin)
c
c     latest revision ---  1 august 1985
c     written by ron jones, with slatec common math library subcommittee
c***references  jones r.e., kahaner d.k., 'xerror, the slatec error-
c                 handling package', sand82-0800, sandia laboratories,
c                 1982.
c***routines called  fdump,i1mach,j4save,xerabt,xerctl,xerprt,xersav,
c                    xgetua
c***end prologue  xerrwv
      character*(*) messg
      character*20 lfirst
      character*37 form
      integer      lun(5), nunit, i1mach, isizei, lerr, llevel
      integer	   isizef, ifatal, i, kunit, iunit, lmessg
      integer	   i1, i2, nr, ni, nmessg, nerr, level
      integer      lkntrl, maxmes, j4save, junk, mkntrl
      integer	   kount, kdummy
      real	   r1, r2
c     get flags
c***first executable statement  xerrwv
      lkntrl = j4save(2,0,.false.)
      maxmes = j4save(4,0,.false.)
c     check for valid input
      if ((nmessg.gt.0).and.(nerr.ne.0).and.
     1    (level.ge.(-1)).and.(level.le.2)) go to 10
         if (lkntrl.gt.0) call xerprt('fatal error in...',17)
         call xerprt('xerror -- invalid input',23)
c        if (lkntrl.gt.0) call fdump
         if (lkntrl.gt.0) call xerprt('job abort due to fatal error.',
     1  29)
         if (lkntrl.gt.0) call xersav(' ',0,0,0,kdummy)
         call xerabt('xerror -- invalid input',23)
         return
   10 continue
c     record message
      junk = j4save(1,nerr,.true.)
      call xersav(messg,nmessg,nerr,level,kount)
c     let user override
      lfirst = messg
      lmessg = nmessg
      lerr = nerr
      llevel = level
      call xerctl(lfirst,lmessg,lerr,llevel,lkntrl)
c     reset to original values
      lmessg = nmessg
      lerr = nerr
      llevel = level
      lkntrl = max0(-2,min0(2,lkntrl))
      mkntrl = iabs(lkntrl)
c     decide whether to print message
      if ((llevel.lt.2).and.(lkntrl.eq.0)) go to 100
      if (((llevel.eq.(-1)).and.(kount.gt.min0(1,maxmes)))
     1.or.((llevel.eq.0)   .and.(kount.gt.maxmes))
     2.or.((llevel.eq.1)   .and.(kount.gt.maxmes).and.(mkntrl.eq.1))
     3.or.((llevel.eq.2)   .and.(kount.gt.max0(1,maxmes)))) go to 100
         if (lkntrl.le.0) go to 20
            call xerprt(' ',1)
c           introduction
            if (llevel.eq.(-1)) call xerprt
     1('warning message...this message will only be printed once.',57)
            if (llevel.eq.0) call xerprt('warning in...',13)
            if (llevel.eq.1) call xerprt
     1      ('recoverable error in...',23)
            if (llevel.eq.2) call xerprt('fatal error in...',17)
   20    continue
c        message
         call xerprt(messg,lmessg)
         call xgetua(lun,nunit)
         isizei = log10(float(i1mach(9))) + 1.0
         isizef = log10(float(i1mach(10))**i1mach(11)) + 1.0
         do 50 kunit=1,nunit
            iunit = lun(kunit)
            if (iunit.eq.0) iunit = i1mach(4)
            do 22 i=1,min(ni,2)
               write (form,21) i,isizei
   21          format ('(11x,21hin above message, i',i1,'=,i',i2,')   ')
               if (i.eq.1) write (iunit,form) i1
               if (i.eq.2) write (iunit,form) i2
   22       continue
            do 24 i=1,min(nr,2)
               write (form,23) i,isizef+10,isizef
   23          format ('(11x,21hin above message, r',i1,'=,e',
     1         i2,'.',i2,')')
               if (i.eq.1) write (iunit,form) r1
               if (i.eq.2) write (iunit,form) r2
   24       continue
            if (lkntrl.le.0) go to 40
c              error number
               write (iunit,30) lerr
   30          format (15h error number =,i10)
   40       continue
   50    continue
c        trace-back
c        if (lkntrl.gt.0) call fdump
  100 continue
      ifatal = 0
      if ((llevel.eq.2).or.((llevel.eq.1).and.(mkntrl.eq.2)))
     1ifatal = 1
c     quit here if message is not fatal
      if (ifatal.le.0) return
      if ((lkntrl.le.0).or.(kount.gt.max0(1,maxmes))) go to 120
c        print reason for abort
         if (llevel.eq.1) call xerprt
     1   ('job abort due to unrecovered error.',35)
         if (llevel.eq.2) call xerprt
     1   ('job abort due to fatal error.',29)
c        print error summary
         call xersav(' ',-1,0,0,kdummy)
  120 continue
c     abort
      if ((llevel.eq.2).and.(kount.gt.max0(1,maxmes))) lmessg = 0
      call xerabt(messg,lmessg)

      return
      end

      integer function i1mach(i)

c
c  i/o unit numbers.
c
c    i1mach( 1) = the standard input unit.
c
c    i1mach( 2) = the standard output unit.
c
c    i1mach( 3) = the standard punch unit.
c
c    i1mach( 4) = the standard error message unit.
c
c  words.
c
c    i1mach( 5) = the number of bits per integer storage unit.
c
c    i1mach( 6) = the number of characters per integer storage unit.
c
c  integers.
c
c    assume integers are represented in the s-digit, base-a form
c
c               sign ( x(s-1)*a**(s-1) + ... + x(1)*a + x(0) )
c
c               where 0 .le. x(i) .lt. a for i=0,...,s-1.
c
c    i1mach( 7) = a, the base.
c
c    i1mach( 8) = s, the number of base-a digits.
c
c    i1mach( 9) = a**s - 1, the largest magnitude.
c
c  floating-point numbers.
c
c    assume floating-point numbers are represented in the t-digit,
c    base-b form
c
c               sign (b**e)*( (x(1)/b) + ... + (x(t)/b**t) )
c
c               where 0 .le. x(i) .lt. b for i=1,...,t,
c               0 .lt. x(1), and emin .le. e .le. emax.
c
c    i1mach(10) = b, the base.
c
c  single-precision
c
c    i1mach(11) = t, the number of base-b digits.
c
c    i1mach(12) = emin, the smallest exponent e.
c
c    i1mach(13) = emax, the largest exponent e.
c
c  double-precision
c
c    i1mach(14) = t, the number of base-b digits.
c
c    i1mach(15) = emin, the smallest exponent e.
c
c    i1mach(16) = emax, the largest exponent e.
c

      integer imach(16),output,i
c
      equivalence (imach(4),output)
c

c     machine constants for the ibm 360/370 series,
c     the xerox sigma 5/7/9 and the sel systems 85/86.
c
      data imach( 1) /   5 /
      data imach( 2) /   6 /
      data imach( 3) /   7 /
      data imach( 4) /   6 /
      data imach( 5) /  32 /
      data imach( 6) /   4 /
      data imach( 7) /   2 /
      data imach( 8) /  31 /
      data imach( 9) / z7fffffff /
      data imach(10) /  16 /
      data imach(11) /   6 /
      data imach(12) / -64 /
      data imach(13) /  63 /
      data imach(14) /  14 /
      data imach(15) / -64 /
      data imach(16) /  63 /

      if (i .lt. 1  .or.  i .gt. 16) go to 999
      i1mach=imach(i)

      return
  999 write(output,1999) i
 1999 format(' i1mach - i out of bounds',i10)
      stop
      end


      real function r1mach(i)
c
c  single-precision machine constants
c
c  r1mach(1) = b**(emin-1), the smallest positive magnitude.
c
c  r1mach(2) = b**emax*(1 - b**(-t)), the largest magnitude.
c
c  r1mach(3) = b**(-t), the smallest relative spacing.
c
c  r1mach(4) = b**(1-t), the largest relative spacing.
c
c  r1mach(5) = log10(b)
c
c  to alter this function for a particular environment,
c  the desired set of data statements should be activated by
c  removing the c from column 1.
c  on rare machines a static statement may need to be added.
c  (but probably more systems prohibit it than require it.)
c
c  where possible, octal or hexadecimal constants have been used
c  to specify the constants exactly which has in some cases
c  required the use of equivalent integer arrays.
c
      integer small(2)
      integer large(2)
      integer right(2)
      integer diver(2)
      integer log10(2)
      integer i	         ! put this in myself
      integer i1mach
c
      real rmach(5)
c
      equivalence (rmach(1),small(1))
      equivalence (rmach(2),large(1))
      equivalence (rmach(3),right(1))
      equivalence (rmach(4),diver(1))
      equivalence (rmach(5),log10(1))

c     machine constants for the ibm 360/370 series,
c     the xerox sigma 5/7/9 and the sel systems 85/86.
c
      data rmach(1) / z00100000 /
      data rmach(2) / z7fffffff /
      data rmach(3) / z3b100000 /
      data rmach(4) / z3c100000 /
      data rmach(5) / z41134413 /

      if (i .lt. 1  .or.  i .gt. 5) goto 999
      r1mach = rmach(i)
      return
  999 write(i1mach(2),1999) i
 1999 format(' r1mach - i out of bounds',i10)
      stop
      end


      function j4save(iwhich,ivalue,iset)


c***begin prologue  j4save
c***refer to  xerror
c***routines called  (none)
c***description
c
c     abstract
c        j4save saves and recalls several global variables needed
c        by the library error handling routines.
c
c     description of parameters
c      --input--
c        iwhich - index of item desired.
c                = 1 refers to current error number.
c                = 2 refers to current error control flag.
c                 = 3 refers to current unit number to which error
c                    messages are to be sent.  (0 means use standard.)
c                 = 4 refers to the maximum number of times any
c                     message is to be printed (as set by xermax).
c                 = 5 refers to the total number of units to which
c                     each error message is to be written.
c                 = 6 refers to the 2nd unit for error messages
c                 = 7 refers to the 3rd unit for error messages
c                 = 8 refers to the 4th unit for error messages
c                 = 9 refers to the 5th unit for error messages
c        ivalue - the value to be set for the iwhich-th parameter,
c                 if iset is .true. .
c        iset   - if iset=.true., the iwhich-th parameter will be
c                 given the value, ivalue.  if iset=.false., the
c                 iwhich-th parameter will be unchanged, and ivalue
c                 is a dummy parameter.
c      --output--
c        the (old) value of the iwhich-th parameter will be returned
c        in the function value, j4save.
c
c     written by ron jones, with slatec common math library subcommittee
c    adapted from bell laboratories port library error handler
c     latest revision ---  1 august 1985
c***references  jones r.e., kahaner d.k., 'xerror, the slatec error-
c                 handling package', sand82-0800, sandia laboratories,
c                 1982.
c***end prologue  j4save
      logical iset
      integer iparam(9), iwhich, ivalue, j4save
      save iparam
      data iparam(1),iparam(2),iparam(3),iparam(4)/0,2,0,10/
      data iparam(5)/1/
      data iparam(6),iparam(7),iparam(8),iparam(9)/0,0,0,0/
c***first executable statement  j4save
      j4save = iparam(iwhich)
      if (iset) iparam(iwhich) = ivalue

      return
      end


*deck xerclr
      subroutine xerclr


c***begin prologue  xerclr
c***date written   790801   (yymmdd)
c***revision date  851111   (yymmdd)
c***category no.  r3c
c***keywords  error,xerror package
c***author  jones, r. e., (snla)
c***purpose  reset current error number to zero.
c***description
c
c     abstract
c        this routine simply resets the current error number to zero.
c        this may be necessary to do in order to determine that
c        a certain error has occurred again since the last time
c        numxer was referenced.
c
c     written by ron jones, with slatec common math library subcommittee
c***references  jones r.e., kahaner d.k., 'xerror, the slatec error-
c                 handling package', sand82-0800, sandia laboratories,
c                 1982.
c***routines called  j4save
c***end prologue  xerclr
c***first executable statement  xerclr
      integer      junk, j4save

      junk = j4save(1,0,.true.)

      return
      end


      subroutine spigmr(n, r0, sr, sz, jscal, maxl, maxlp1, kmp, 
     $     nrsts, jpre, matvec, msolve, nmsl, z, v, hes, q, lgmr,
     $     rpar, ipar, wk, dl, rhol, nrmax, b, bnrm, x, xl,
     $     itol, tol, nelt, ia, ja, a, isym, iunit, iflag, err)


      integer  n,maxl,maxlp1,kmp,jpre,nmsl,lgmr,iflag,jscal,nrsts
      integer  nrmax,itol,nelt,isym
      real     rhol,bnrm,tol
      real     r0(*), sr(*), sz(*), z(*), v(n,*), hes(maxlp1,*)
      real     q(*), rpar(*), wk(*), dl(*)
      real     a(*), b(*), x(*), xl(*)
      integer  ipar(*), ia(*), ja(*)
      real     snrm2
c
c         local variables.
c
      integer    i, info, ip1, i2, j, k, ll, llp1
      real       r0nrm,c,dlnrm,prod,rho,s,snormw,tem, err
      integer	 iter, iunit, itmax, issgmr
      external   matvec, msolve

c
c         zero out the z array.
c***first executable statement  spigmr
      do 5 i = 1,n
         z(i) = 0.0e0
 5    continue
c
      iflag = 0
      lgmr = 0
      nmsl = 0
c         load itmax, the maximum number of iterations.
      itmax =(nrmax+1)*maxl
c   -------------------------------------------------------------------
c         the initial residual is the vector r0.
c         apply left precon. if jpre < 0 and this is not a restart.
c         apply scaling to r0 if jscal = 2 or 3.
c   -------------------------------------------------------------------
      if ((jpre .lt. 0) .and.(nrsts .eq. 0)) then
         call scopy(n, r0, 1, wk, 1)
         call msolve(n, wk, r0, nelt, ia, ja, a, isym, rpar, ipar)
         nmsl = nmsl + 1
      endif
      if (((jscal.eq.2) .or.(jscal.eq.3)) .and.(nrsts.eq.0)) then
         do 10 i = 1,n
            v(i,1) = r0(i)*sr(i)
 10      continue
      else
         do 20 i = 1,n
            v(i,1) = r0(i)
 20      continue
      endif
      r0nrm = snrm2(n, v, 1)
      iter = nrsts*maxl
c
c         call stopping routine issgmr.
c
      if (issgmr(n, b, x, xl, nelt, ia, ja, a, isym, msolve,
     $    nmsl, itol, tol, itmax, iter, err, iunit, v(1,1), z, wk,
     $    rpar, ipar, r0nrm, bnrm, sr, sz, jscal,
     $    kmp, lgmr, maxl, maxlp1, v, q, snormw, prod, r0nrm,
     $    hes, jpre) .ne. 0) return
      tem = 1.0e0/r0nrm
      call sscal(n, tem, v(1,1), 1)
c
c         zero out the hes array.
c
      do 50 j = 1,maxl
         do 40 i = 1,maxlp1
            hes(i,j) = 0.0e0
 40      continue
 50   continue
c   -------------------------------------------------------------------
c         main loop to compute the vectors v(*,2) to v(*,maxl).
c         the running product prod is needed for the convergence test.
c   -------------------------------------------------------------------
      prod = 1.0e0
      do 90 ll = 1,maxl
         lgmr = ll
c   -------------------------------------------------------------------
c        unscale  the  current v(ll)  and store  in wk.  call routine
c        msolve    to   compute(m-inverse)*wk,   where    m   is  the
c        preconditioner matrix.  save the answer in z.   call routine
c        matvec to compute  vnew  = a*z,  where  a is  the the system
c        matrix.  save the answer in  v(ll+1).  scale v(ll+1).   call
c        routine sorth  to  orthogonalize the    new vector vnew   =
c        v(*,ll+1).  call routine sheqr to update the factors of hes.
c   -------------------------------------------------------------------
	!write(*,*) 'jscal =', jscal
        if ((jscal .eq. 1) .or.(jscal .eq. 3)) then
           do 60 i = 1,n
              wk(i) = v(i,ll)/sz(i)
 60        continue
        else
           call scopy(n, v(1,ll), 1, wk, 1)
	   !write(*,*) 'v(:,ll)=', (v(i,ll),i=1,20)
        endif
        if (jpre .gt. 0) then
           call msolve(n, wk, z, nelt, ia, ja, a, isym, rpar, ipar)
	   !write(*,*) '1:  z(:) =', (z(i),i=1,20)
           nmsl = nmsl + 1
           call matvec(n, z, v(1,ll+1), nelt, ia, ja, a, isym)
	   !write(*,*) '1: v(:,ll+1)=', (v(i+1,ll+1),i=1,20)
        else
           call matvec(n, wk, v(1,ll+1), nelt, ia, ja, a, isym)
	   !write(*,*) '2: v(:,ll+1)=', (v(i+1,ll+1),i=1,20)
        endif
        if (jpre .lt. 0) then
           call scopy(n, v(1,ll+1), 1, wk, 1)
           call msolve(n,wk,v(1,ll+1),nelt,ia,ja,a,isym,rpar,ipar)
	   !write(*,*) '3: v(:,ll+1)=', (v(i+1,ll+1),i=1,20)
           nmsl = nmsl + 1
        endif
        if ((jscal .eq. 2) .or.(jscal .eq. 3)) then
           do 65 i = 1,n
              v(i,ll+1) = v(i,ll+1)*sr(i)
 65        continue
	   !write(*,*) '4: v(:,ll+1)=', (v(i+1,ll+1),i=1,20)
        endif
	!write(*,*) '1: maxlp1, ll, (hes(i,ll),i=1,maxlp1) :'
	!write(*,*) maxlp1, ll, (hes(i,ll),i=1,maxlp1)
        call sorth(v(1,ll+1), v, hes, n, ll, maxlp1, kmp, snormw)
        hes(ll+1,ll) = snormw
	!write(*,*) '2: maxlp1, ll, (hes(i,ll),i=1,maxlp1) :'
	!write(*,*) maxlp1, ll, (hes(i,ll),i=1,maxlp1)
        call sheqr(hes, maxlp1, ll, q, info, ll)
	!write(*,*) 'info =', info
        if (info .eq. ll) go to 120
c   -------------------------------------------------------------------
c         update rho, the estimate of the norm of the residual r0-a*zl.
c         if kmp <  maxl, then the vectors v(*,1),...,v(*,ll+1) are not
c         necessarily orthogonal for ll > kmp.  the vector dl must then
c         be computed, and its norm used in the calculation of rho.
c   -------------------------------------------------------------------
	!write(*,*) 'prod 1 =', prod
	!write(*,*) '2*maxl, ll, q(2*ll) =', 2*maxl, ll, q(2*ll)
        prod = prod*q(2*ll)
	!write(*,*) 'prod 2 =', prod
        rho = abs(prod*r0nrm)
	!write(*,*) 'rho 1 =', rho
        if ((ll.gt.kmp) .and.(kmp.lt.maxl)) then
           if (ll .eq. kmp+1) then
              call scopy(n, v(1,1), 1, dl, 1)
              do 75 i = 1,kmp
                 ip1 = i + 1
                 i2 = i*2
                 s = q(i2)
                 c = q(i2-1)
                 do 70 k = 1,n
                    dl(k) = s*dl(k) + c*v(k,ip1)
 70              continue
 75           continue
           endif
           s = q(2*ll)
           c = q(2*ll-1)/snormw
           llp1 = ll + 1
           do 80 k = 1,n
              dl(k) = s*dl(k) + c*v(k,llp1)
 80        continue
           dlnrm = snrm2(n, dl, 1)
           rho = rho*dlnrm
	!write(*,*) 'rho 2 =', rho
        endif
        rhol = rho
c   -------------------------------------------------------------------
c         test for convergence.  if passed, compute approximation zl.
c         if failed and ll < maxl, then continue iterating.
c   -------------------------------------------------------------------
        iter = nrsts*maxl + lgmr
	!write(*,*) 'spigmr calling issgmr: rhol =', rhol
        if (issgmr(n, b, x, xl, nelt, ia, ja, a, isym, msolve,
     $      nmsl, itol, tol, itmax, iter, err, iunit, dl, z, wk,
     $      rpar, ipar, rhol, bnrm, sr, sz, jscal,
     $      kmp, lgmr, maxl, maxlp1, v, q, snormw, prod, r0nrm,
     $      hes, jpre) .ne. 0) go to 200
        if (ll .eq. maxl) go to 100
c   -------------------------------------------------------------------
c         rescale so that the norm of v(1,ll+1) is one.
c   -------------------------------------------------------------------
        tem = 1.0e0/snormw
        call sscal(n, tem, v(1,ll+1), 1)
 90   continue
 100  continue
      if (rho .lt. r0nrm) go to 150
 120  continue
      iflag = 2
c
c         load approximate solution with zero.
c
      do 130 i = 1,n
         z(i) = 0.e0
 130  continue
      return
 150  iflag = 1
c
c         tolerance not met, but residual norm reduced.
c
      if (nrmax .gt. 0) then
c
c        if performing restarting (nrmax > 0)  calculate the residual
c        vector rl and  store it in the dl  array.  if the incomplete
c        version is being used (kmp < maxl) then dl has  already been
c        calculated up to a scaling factor.   use srlcal to calculate
c        the scaled residual vector.
c
         call srlcal(n, kmp, maxl, maxl, v, q, dl, snormw, prod,
     $        r0nrm)
      endif
c   -------------------------------------------------------------------
c         compute the approximation zl to the solution.  since the 
c         vector z was used as work space, and the initial guess
c         of the linear iteration is zero, z must be reset to zero.
c   -------------------------------------------------------------------
 200  continue
      ll = lgmr
      llp1 = ll + 1
      do 210 k = 1,llp1
         r0(k) = 0.0e0
 210  continue
      r0(1) = r0nrm
      call shels(hes, maxlp1, ll, q, r0)
      do 220 k = 1,n
         z(k) = 0.0e0
 220  continue
      do 230 i = 1,ll
         call saxpy(n, r0(i), v(1,i), 1, z, 1)
 230  continue
      if ((jscal .eq. 1) .or.(jscal .eq. 3)) then
         do 240 i = 1,n
            z(i) = z(i)/sz(i)
 240     continue
      endif
      if (jpre .gt. 0) then
         call scopy(n, z, 1, wk, 1)
         call msolve(n, wk, z, nelt, ia, ja, a, isym, rpar, ipar)
         nmsl = nmsl + 1
      endif

      return
c------------- last line of spigmr follows ----------------------------
      end

      subroutine xerror(messg,nmessg,nerr,level)


c***begin prologue  xerror
c***date written   790801   (yymmdd)
c***revision date  851111   (yymmdd)
c***category no.  r3c
c***keywords  error,xerror package
c***author  jones, r. e., (snla)
c***purpose  process an error (diagnostic) message.
c***description
c
c     abstract
c        xerror processes a diagnostic message, in a manner
c        determined by the value of level and the current value
c        of the library error control flag, kontrl.
c        (see subroutine xsetf for details.)
c
c     description of parameters
c      --input--
c        messg - the hollerith message to be processed, containing
c                no more than 72 characters.
c        nmessg- the actual number of characters in messg.
c        nerr  - the error number associated with this message.
c                nerr must not be zero.
c        level - error category.
c                =2 means this is an unconditionally fatal error.
c                =1 means this is a recoverable error.  (i.e., it is
c                   non-fatal if xsetf has been appropriately called.)
c                =0 means this is a warning message only.
c                =-1 means this is a warning message which is to be
c                   printed at most once, regardless of how many
c                   times this call is executed.
c
c     examples
c        call xerror('smooth -- num was zero.',23,1,2)
c        call xerror('integ  -- less than full accuracy achieved.',
c    1                43,2,1)
c        call xerror('rooter -- actual zero of f found before interval f
c    1ully collapsed.',65,3,0)
c        call xerror('exp    -- underflows being set to zero.',39,1,-1)
c
c     written by ron jones, with slatec common math library subcommittee
c***references  jones r.e., kahaner d.k., 'xerror, the slatec error-
c                 handling package', sand82-0800, sandia laboratories,
c                 1982.
c***routines called  xerrwv
c***end prologue  xerror
      character*(*) messg
      integer       level, nerr, nmessg
c***first executable statement  xerror
      call xerrwv(messg,nmessg,nerr,level,0,0,0,0,0.,0.)

      return
      end

      subroutine xerabt(messg,nmessg)


c***begin prologue  xerabt
c***date written   790801   (yymmdd)
c***revision date  851111   (yymmdd)
c***category no.  r3c
c***keywords  error,xerror package
c***author  jones, r. e., (snla)
c***purpose  abort program execution and print error message.
c***description
c
c     abstract
c        ***note*** machine dependent routine
c        xerabt aborts the execution of the program.
c        the error message causing the abort is given in the calling
c        sequence, in case one needs it for printing on a dayfile,
c        for example.
c
c     description of parameters
c        messg and nmessg are as in xerror, except that nmessg may
c        be zero, in which case no message is being supplied.
c
c     written by ron jones, with slatec common math library subcommittee
c     latest revision ---  1 august 1982
c***references  jones r.e., kahaner d.k., 'xerror, the slatec error-
c                 handling package', sand82-0800, sandia laboratories,
c                 1982.
c***routines called  (none)
c***end prologue  xerabt
      character*72 messg
      integer      nmessg
c      dimension messg(nmessg)
c***first executable statement  xerabt
      nmessg = 72
      call exit(1)
      end


      subroutine xerctl(messg1,nmessg,nerr,level,kontrl)
c***begin prologue  xerctl
c***date written   790801   (yymmdd)
c***revision date  851111   (yymmdd)
c***category no.  r3c
c***keywords  error,xerror package
c***author  jones, r. e., (snla)
c***purpose  allow user control over handling of errors.
c***description
c
c     abstract
c        allows user control over handling of individual errors.
c        just after each message is recorded, but before it is
c        processed any further (i.e., before it is printed or
c        a decision to abort is made), a call is made to xerctl.
c        if the user has provided his own version of xerctl, he
c        can then override the value of kontrol used in processing
c        this message by redefining its value.
c        kontrl may be set to any value from -2 to 2.
c        the meanings for kontrl are the same as in xsetf, except
c        that the value of kontrl changes only for this message.
c        if kontrl is set to a value outside the range from -2 to 2,
c        it will be moved back into that range.
c
c     description of parameters
c
c      --input--
c        messg1 - the first word (only) of the error message.
c        nmessg - same as in the call to xerror or xerrwv.
c        nerr   - same as in the call to xerror or xerrwv.
c        level  - same as in the call to xerror or xerrwv.
c        kontrl - the current value of the control flag as set
c                 by a call to xsetf.
c
c      --output--
c        kontrl - the new value of kontrl.  if kontrl is not
c                 defined, it will remain at its original value.
c                 this changed value of control affects only
c                 the current occurrence of the current message.
c***references  jones r.e., kahaner d.k., 'xerror, the slatec error-
c                 handling package', sand82-0800, sandia laboratories,
c                 1982.
c***routines called  (none)
c***end prologue  xerctl
      character*20 messg1
      integer      nmessg,nerr, level, kontrl
c***first executable statement  xerctl
      return
      end

      subroutine xerprt(messg,nmessg)
c***begin prologue  xerprt
c***date written   790801   (yymmdd)
c***revision date  851213   (yymmdd)
c***category no.  r3
c***keywords  error,xerror package
c***author  jones, r. e., (snla)
c***purpose  print error messages.
c***description
c
c     abstract
c        print the hollerith message in messg, of length nmessg,
c        on each file indicated by xgetua.
c     latest revision ---  1 august 1985
c***references  jones r.e., kahaner d.k., 'xerror, the slatec error-
c                 handling package', sand82-0800, sandia laboratories,
c                 1982.
c***routines called  i1mach,xgetua
c***end prologue  xerprt
      integer lun(5), i1mach, iunit, ichar, last
      integer nunit, nmessg, kunit, lenmssg, lenmes
      character*(*) messg
c     obtain unit numbers and write line to each unit
c***first executable statement  xerprt
      call xgetua(lun,nunit)
      lenmes = len(messg)
      do 20 kunit=1,nunit
         iunit = lun(kunit)
         if (iunit.eq.0) iunit = i1mach(4)
         do 10 ichar=1,lenmes,72
            last = min0(ichar+71 , lenmes)
            write (iunit,'(1x,a)') messg(ichar:last)
   10    continue
   20 continue

      return
      end


      subroutine xersav(messg,nmessg,nerr,level,icount)


c***begin prologue  xersav
c***date written   800319   (yymmdd)
c***revision date  851213   (yymmdd)
c***category no.  r3
c***keywords  error,xerror package
c***author  jones, r. e., (snla)
c***purpose  record that an error has occurred.
c***description
c
c     abstract
c        record that this error occurred.
c
c     description of parameters
c     --input--
c       messg, nmessg, nerr, level are as in xerror,
c       except that when nmessg=0 the tables will be
c       dumped and cleared, and when nmessg is less than zero the
c       tables will be dumped and not cleared.
c     --output--
c       icount will be the number of times this message has
c       been seen, or zero if the table has overflowed and
c       does not contain this message specifically.
c       when nmessg=0, icount will not be altered.
c
c     written by ron jones, with slatec common math library subcommittee
c     latest revision ---  1 august 1985
c***references  jones r.e., kahaner d.k., 'xerror, the slatec error-
c                 handling package', sand82-0800, sandia laboratories,
c                 1982.
c***routines called  i1mach,xgetua
c***end prologue  xersav
      integer lun(5), i1mach, iunit, kunit, ii, i, level, nerr
      integer nmessg, nunit, icount, kountx
      character*(*) messg
      character*20 mestab(10),mes
      integer      nertab(10),levtab(10),kount(10)
      save mestab,nertab,levtab,kount,kountx
c     next two data statements are necessary to provide a blank
c     error table initially
      data kount(1),kount(2),kount(3),kount(4),kount(5),
     1     kount(6),kount(7),kount(8),kount(9),kount(10)
     2     /0,0,0,0,0,0,0,0,0,0/
      data kountx/0/
c***first executable statement  xersav
      if (nmessg.gt.0) go to 80
c     dump the table
         if (kount(1).eq.0) return
c        print to each unit
         call xgetua(lun,nunit)
         do 60 kunit=1,nunit
            iunit = lun(kunit)
            if (iunit.eq.0) iunit = i1mach(4)
c           print table header
            write (iunit,10)
   10       format (32h0          error message summary/
     1      51h message start             nerr     level     count)
c           print body of table
            do 20 i=1,10
               if (kount(i).eq.0) go to 30
               write (iunit,15) mestab(i),nertab(i),levtab(i),kount(i)
   15          format (1x,a20,3i10)
   20       continue
   30       continue
c           print number of other errors
            if (kountx.ne.0) write (iunit,40) kountx
   40       format (41h0other errors not individually tabulated=,i10)
            write (iunit,50)
   50       format (1x)
   60    continue
         if (nmessg.lt.0) return
c        clear the error tables
         do 70 i=1,10
   70       kount(i) = 0
         kountx = 0
         return
   80 continue
c     process a message...
c     search for this messg, or else an empty slot for this messg,
c     or else determine that the error table is full.
      mes = messg
      do 90 i=1,10
         ii = i
         if (kount(i).eq.0) go to 110
         if (mes.ne.mestab(i)) go to 90
         if (nerr.ne.nertab(i)) go to 90
         if (level.ne.levtab(i)) go to 90
         go to 100
   90 continue
c     three possible cases...
c     table is full
         kountx = kountx+1
         icount = 1
         return
c     message found in table
  100    kount(ii) = kount(ii) + 1
         icount = kount(ii)
         return
c     empty slot found for new message
  110    mestab(ii) = mes
         nertab(ii) = nerr
         levtab(ii) = level
         kount(ii)  = 1
         icount = 1

         return
      end


      subroutine xgetua(iunita,n)


c***begin prologue  xgetua
c***date written   790801   (yymmdd)
c***revision date  851111   (yymmdd)
c***category no.  r3c
c***keywords  error,xerror package
c***author  jones, r. e., (snla)
c***purpose  return unit number(s) to which error messages are being
c            sent.
c***description
c
c     abstract
c        xgetua may be called to determine the unit number or numbers
c        to which error messages are being sent.
c        these unit numbers may have been set by a call to xsetun,
c        or a call to xsetua, or may be a default value.
c
c     description of parameters
c      --output--
c        iunit - an array of one to five unit numbers, depending
c                on the value of n.  a value of zero refers to the
c                default unit, as defined by the i1mach machine
c                constant routine.  only iunit(1),...,iunit(n) are
c                defined by xgetua.  the values of iunit(n+1),...,
c                iunit(5) are not defined (for n .lt. 5) or altered
c                in any way by xgetua.
c        n     - the number of units to which copies of the
c                error messages are being sent.  n will be in the
c                range from 1 to 5.
c
c     latest revision ---  19 mar 1980
c     written by ron jones, with slatec common math library subcommittee
c***references  jones r.e., kahaner d.k., 'xerror, the slatec error-
c                 handling package', sand82-0800, sandia laboratories,
c                 1982.
c***routines called  j4save
c***end prologue  xgetua
      integer     iunita(5), n, j4save, index, i 
c***first executable statement  xgetua
      n = j4save(5,0,.false.)
      do 30 i=1,n
         index = i+4
         if (i.eq.1) index = 3
         iunita(i) = j4save(index,0,.false.)
   30 continue

      return
      end


      subroutine sscal(n,sa,sx,incx)

c
c     scales a vector by a constant.
c     uses unrolled loops for increment equal to 1.
c     jack dongarra, linpack, 3/11/78.
c     modified to correct problem with negative increments, 9/29/88.
c
      real sa,sx(*)
      integer i,ix,incx,m,mp1,n
c
      if(n.le.0)return
      if(incx.eq.1)go to 20
c
c        code for increment not equal to 1
c
      ix = 1 
      if(incx.lt.0)ix = (-n+1)*incx + 1 
      do 10 i = 1,n 
        sx(ix) = sa*sx(ix)
        ix = ix + incx 
   10 continue
      return
c
c        code for increment equal to 1
c
c
c        clean-up loop
c
   20 m = mod(n,5)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        sx(i) = sa*sx(i)
   30 continue
      if( n .lt. 5 ) return
   40 mp1 = m + 1
      do 50 i = mp1,n,5
        sx(i) = sa*sx(i)
        sx(i + 1) = sa*sx(i + 1)
        sx(i + 2) = sa*sx(i + 2)
        sx(i + 3) = sa*sx(i + 3)
        sx(i + 4) = sa*sx(i + 4)
   50 continue

      return
      end


      subroutine sorth(vnew, v, hes, n, ll, ldhes, kmp, snormw)


      integer n, ll, ldhes, kmp
      real vnew, v, hes, snormw
      dimension vnew(*), v(n,*), hes(ldhes,*)
      real	snrm2, sdot
c
c         internal variables.
c
      integer i, i0
      real arg, sumdsq, tem, vnrm
c
c         get norm of unaltered vnew for later use.
c***first executable statement  sorth
      vnrm = snrm2(n, vnew, 1)
      !write(*,*) 'sorth:  vnrm=', vnrm
      !write(*,*) 'vnew(1:20) =', (vnew(i),i=1,20)
c   -------------------------------------------------------------------
c         perform the modified gram-schmidt procedure on vnew =a*v(ll).
c         scaled inner products give new column of hes.
c         projections of earlier vectors are subtracted from vnew.
c   -------------------------------------------------------------------
      i0 = max0(1,ll-kmp+1)
      !write(*,*) 'sorth:  i0, ll =',  i0, ll
      do 10 i = i0,ll
         hes(i,ll) = sdot(n, v(1,i), 1, vnew, 1)
	 !write(*,*) 'i =', i
	 !write(*,*) 'v(:,i) =', (v(k,i),k=1,n)
	 !write(*,*) 'sorth:  hes(i,ll) =', hes(i,ll)
	 !write(*,*) 'sorth: stop!'
         tem = -hes(i,ll)
         call saxpy(n, tem, v(1,i), 1, vnew, 1)
 10   continue
c   -------------------------------------------------------------------
c         compute snormw = norm of vnew.  if vnew is small compared 
c         to its input value (in norm), then reorthogonalize vnew to 
c         v(*,1) through v(*,ll).  correct if relative correction 
c         exceeds 1000*(unit roundoff).  finally, correct snormw using 
c         the dot products involved.
c   -------------------------------------------------------------------
      snormw = snrm2(n, vnew, 1)
      if (vnrm + 0.001e0*snormw .ne. vnrm) return
      sumdsq = 0.0e0
      do 30 i = i0,ll
         tem = -sdot(n, v(1,i), 1, vnew, 1)
         if (hes(i,ll) + 0.001e0*tem .eq. hes(i,ll)) go to 30
         hes(i,ll) = hes(i,ll) - tem
         call saxpy(n, tem, v(1,i), 1, vnew, 1)
         sumdsq = sumdsq + tem**2
 30   continue
      if (sumdsq .eq. 0.0e0) return
      arg = amax1(0.0e0,snormw**2 - sumdsq)
      snormw = sqrt(arg)
c

      return
c------------- last line of sorth follows ----------------------------
      end


      subroutine sheqr(a, lda, n, q, info, ijob)


      integer lda, n, info, ijob
      real a(lda,*), q(*)
c
c         local variables.
c
      integer i, iq, j, k, km1, kp1, nm1
      real c, s, t, t1, t2
c
c***first executable statement  sheqr
      if (ijob .gt. 1) go to 70
c   -------------------------------------------------------------------
c         a new facorization is desired.
c   -------------------------------------------------------------------
c         qr decomposition without pivoting.
c
      info = 0
      !write(*,*) 'sheqr: n =', n
      !write(*,*) '1: (q(i),i=1,20) =',  (q(i),i=1,20)
      do 60 k = 1, n
         km1 = k - 1
         kp1 = k + 1
c
c           compute k-th column of r.
c           first, multiply the k-th column of a by the previous
c           k-1 givens rotations.
c
         if (km1 .lt. 1) go to 20
         do 10 j = 1, km1
            i = 2*(j-1) + 1
            t1 = a(j,k)
            t2 = a(j+1,k)
            c = q(i)
            s = q(i+1)
            a(j,k) = c*t1 - s*t2
            a(j+1,k) = s*t1 + c*t2
 10      continue
c
c         compute givens components c and s.
c
 20      continue
         iq = 2*km1 + 1
         t1 = a(k,k)
         t2 = a(kp1,k)
	 !write(*,*) 'k =', k
	 !write(*,*) 't1, t2 =', t1, t2
         if( t2.eq.0.0e0 ) then
            c = 1.0e0
            s = 0.0e0
         elseif( abs(t2).ge.abs(t1) ) then
            t = t1/t2
            s = -1.0e0/sqrt(1.0e0+t*t)
            c = -s*t
         else
            t = t2/t1
            c = 1.0e0/sqrt(1.0e0+t*t)
            s = -c*t
         endif
         q(iq) = c
         q(iq+1) = s
	 !write(*,*) '1: c,s =', c, s
	 !write(*,*) 'iq+1, q(iq+1) =',  iq+1, q(iq+1)
         a(k,k) = c*t1 - s*t2
         if( a(k,k).eq.0.0e0 ) info = k
 60   continue
      !write(*,*) '2: (q(i),i=1,20) =',  (q(i),i=1,20)
      return
c   -------------------------------------------------------------------
c         the old factorization of a will be updated.  a row and a 
c         column has been added to the matrix a.  n by n-1 is now 
c         the old size of the matrix.
c   -------------------------------------------------------------------
 70   continue
      !write(*,*) 'sheqr 2: n =', n
      nm1 = n - 1
c   -------------------------------------------------------------------
c         multiply the new column by the n previous givens rotations.
c   -------------------------------------------------------------------
      do 100 k = 1,nm1
         i = 2*(k-1) + 1
         t1 = a(k,n)
         t2 = a(k+1,n)
         c = q(i)
         s = q(i+1)
	 !write(*,*) '2: c,s =', c, s
	 !write(*,*) 'iq+1, q(iq+1) =',  iq+1, q(iq+1)
         a(k,n) = c*t1 - s*t2
         a(k+1,n) = s*t1 + c*t2
 100  continue
c   -------------------------------------------------------------------
c         complete update of decomposition by forming last givens 
c         rotation, and multiplying it times the column 
c         vector(a(n,n),a(np1,n)).
c   -------------------------------------------------------------------
      info = 0
      t1 = a(n,n)
      t2 = a(n+1,n)
      if ( t2.eq.0.0e0 ) then
         c = 1.0e0
         s = 0.0e0
      elseif( abs(t2).ge.abs(t1) ) then
         t = t1/t2
         s = -1.0e0/sqrt(1.0e0+t*t)
         c = -s*t
      else
         t = t2/t1
         c = 1.0e0/sqrt(1.0e0+t*t)
         s = -c*t
      endif
      iq = 2*n - 1
      q(iq) = c
      q(iq+1) = s
      a(n,n) = c*t1 - s*t2
	 !write(*,*) '3: c,s =', c, s
	 !write(*,*) 'iq+1, q(iq+1) =',  iq+1, q(iq+1)
      !write(*,*) '3: (q(i),i=1,20) =',  (q(i),i=1,20)
      if (a(n,n) .eq. 0.0e0) info = n

      return
c------------- last line of sheqr follows ----------------------------
      end


       subroutine srlcal(n, kmp, ll, maxl, v, q, rl, snormw, prod,
     $     r0nrm)


      integer n, kmp, ll, maxl
      real v, q, rl, snormw
      dimension v(n,*), q(*), rl(n)
c
c         internal variables.
c
      integer i, ip1, i2, k, llp1, llm1
      real    c, s, tem, prod, r0nrm
c
c***first executable statement  srlcal
      if (kmp .eq. maxl) then
c
c         calculate rl.  start by copying v(*,1) into rl.
c
         call scopy(n, v(1,1), 1, rl, 1)
         llm1 = ll - 1
         do 20 i = 1,llm1
            ip1 = i + 1
            i2 = i*2
            s = q(i2)
            c = q(i2-1)
            do 10 k = 1,n
               rl(k) = s*rl(k) + c*v(k,ip1)
 10         continue
 20      continue
         s = q(2*ll)
         c = q(2*ll-1)/snormw
         llp1 = ll + 1
         do 30 k = 1,n
            rl(k) = s*rl(k) + c*v(k,llp1)
 30      continue
      endif
c
c         when kmp < maxl, rl vector already partially calculated. 
c         scale rl by r0nrm*prod to obtain the residual rl.
c
      tem = r0nrm*prod
      call sscal(n, tem, rl, 1)

      return
c------------- last line of srlcal follows ----------------------------
      end


      subroutine shels(a, lda, n, q, b)


      integer lda, n
      real a(lda,*), b(*), q(*)
c
c         local variables.
c
      integer iq, k, kb, kp1
      real c, s, t, t1, t2
c
c         minimize(b-a*x,b-a*x).  first form q*b.
c
      do 20 k = 1, n
         kp1 = k + 1
         iq = 2*(k-1) + 1
         c = q(iq)
         s = q(iq+1)
         t1 = b(k)
         t2 = b(kp1)
         b(k) = c*t1 - s*t2
         b(kp1) = s*t1 + c*t2
 20   continue
c
c         now solve  r*x = q*b.
c
      do 40 kb = 1, n
         k = n + 1 - kb
         b(k) = b(k)/a(k,k)
         t = -b(k)
         call saxpy(k-1, t, a(1,k), 1, b(1), 1)
 40   continue

      return
c------------- last line of shels follows ----------------------------
      end


      subroutine saxpy(n,sa,sx,incx,sy,incy)

c
c     constant times a vector plus a vector.
c     uses unrolled loop for increments equal to one.
c     jack dongarra, linpack, 3/11/78.
c
      real sx(*),sy(*),sa
      integer i,incx,incy,ix,iy,m,mp1,n
c
      if(n.le.0)return
      if (sa .eq. 0.0) return
      if(incx.eq.1.and.incy.eq.1)go to 20
c
c        code for unequal increments or equal increments
c          not equal to 1
c
      ix = 1
      iy = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      if(incy.lt.0)iy = (-n+1)*incy + 1
      do 10 i = 1,n
        sy(iy) = sy(iy) + sa*sx(ix)
        ix = ix + incx
        iy = iy + incy
   10 continue
      return
c
c        code for both increments equal to 1
c
c
c        clean-up loop
c
   20 m = mod(n,4)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        sy(i) = sy(i) + sa*sx(i)
   30 continue
      if( n .lt. 4 ) return
   40 mp1 = m + 1
      do 50 i = mp1,n,4
        sy(i) = sy(i) + sa*sx(i)
        sy(i + 1) = sy(i + 1) + sa*sx(i + 1)
        sy(i + 2) = sy(i + 2) + sa*sx(i + 2)
        sy(i + 3) = sy(i + 3) + sa*sx(i + 3)
   50 continue

      return
      end

      subroutine ssmv( n, x, y, nelt, ia, ja, a, isym )



c***begin prologue  ssmv
c***date written   871119   (yymmdd)
c***revision date  881213   (yymmdd)
c***category no.  d2a4, d2b4
c***keywords  library=slatec(slap),
c             type=single precision(ssmv-s),
c             matrix vector multiply, sparse
c***author  greenbaum, anne, courant institute
c           seager, mark k., (llnl)
c             lawrence livermore national laboratory
c             po box 808, l-300
c             livermore, ca 94550 (415) 423-3141
c             seager@lll-crg.llnl.gov
c***purpose  slap column format sparse matrix vector product.
c            routine to calculate the sparse matrix vector product:
c            y = a*x.
c***description
c *usage:
c     integer  n, nelt, ia(nelt), ja(n+1), isym
c     real     x(n), y(n), a(nelt)
c
c     call ssmv(n, x, y, nelt, ia, ja, a, isym )
c         
c *arguments:
c n      :in       integer.
c         order of the matrix.
c x      :in       real x(n).
c         the vector that should be multiplied by the matrix.
c y      :out      real y(n).
c         the product of the matrix and the vector.
c nelt   :in       integer.
c         number of non-zeros stored in a.
c ia     :in       integer ia(nelt).
c ja     :in       integer ja(n+1).
c a      :in       integer a(nelt).
c         these arrays should hold the matrix a in the slap column
c         format.  see "description", below. 
c isym   :in       integer.
c         flag to indicate symmetric storage format.
c         if isym=0, all nonzero entries of the matrix are stored.
c         if isym=1, the matrix is symmetric, and only the upper
c         or lower triangle of the matrix is stored.
c
c *precision:           single precision
c *cautions:
c     this   routine   assumes  that  the matrix a is stored in slap 
c     column format.  it does not check  for  this (for  speed)  and 
c     evil, ugly, ornery and nasty things  will happen if the matrix 
c     data  structure  is,  in fact, not slap column.  beware of the 
c     wrong data structure!!!
c
c *see also:
c       ssmtv
c***references  (none)
c***routines called  (none)
c***end prologue  ssmv
      integer n, nelt, ia(nelt), ja(nelt), isym
      integer i, ibgn, iend, j, jbgn, jend, irow, icol
      real    a(nelt), x(n), y(n)
c
c         zero out the result vector.
c***first executable statement  ssmv
      do 10 i = 1, n
         y(i) = 0.0
 10   continue
c
c         multiply by a.
c
cvd$r noconcur
      do 30 icol = 1, n
         ibgn = ja(icol)
         iend = ja(icol+1)-1
clll. option assert (nohazard)
cdir$ ivdep
cvd$ nodepchk
         do 20 i = ibgn, iend
            y(ia(i)) = y(ia(i)) + a(i)*x(icol)
 20      continue
 30   continue
c
      if( isym.eq.1 ) then
c
c         the matrix is non-symmetric.  need to get the other half in...
c         this loops assumes that the diagonal is the first entry in
c         each column.
c
         do 50 irow = 1, n
            jbgn = ja(irow)+1
            jend = ja(irow+1)-1
            if( jbgn.gt.jend ) goto 50
            do 40 j = jbgn, jend
               y(irow) = y(irow) + a(j)*x(ia(j))
 40         continue
 50      continue
      endif

      return
c------------- last line of ssmv follows ----------------------------
      end


      real function sdot(n,sx,incx,sy,incy)

c
c     forms the dot product of two vectors.
c     uses unrolled loops for increments equal to one.
c     jack dongarra, linpack, 3/11/78.
c
      real sx(*),sy(*),stemp
      integer i,incx,incy,ix,iy,m,mp1,n
c
      stemp = 0.0e0
      sdot = 0.0e0
      if(n.le.0)return
      if(incx.eq.1.and.incy.eq.1)go to 20
c
c        code for unequal increments or equal increments
c          not equal to 1
c
      ix = 1
      iy = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      if(incy.lt.0)iy = (-n+1)*incy + 1
      do 10 i = 1,n
        stemp = stemp + sx(ix)*sy(iy)
        ix = ix + incx
        iy = iy + incy
   10 continue
      sdot = stemp
      return
c
c        code for both increments equal to 1
c
c
c        clean-up loop
c
   20 m = mod(n,5)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        stemp = stemp + sx(i)*sy(i)
   30 continue
      if( n .lt. 5 ) go to 60
   40 mp1 = m + 1
      do 50 i = mp1,n,5
        stemp = stemp + sx(i)*sy(i) + sx(i + 1)*sy(i + 1) +
     *   sx(i + 2)*sy(i + 2) + sx(i + 3)*sy(i + 3) + sx(i + 4)*sy(i + 4)
   50 continue
   60 sdot = stemp

      return
      end


      real function snrm2 ( n, sx, incx)


      integer          next, i, j, n, nn, incx
      real   sx(*),  cutlo, cuthi, hitest, sum, xmax, zero, one
      data   zero, one /0.0e0, 1.0e0/
c
c     euclidean norm of the n-vector stored in sx() with storage
c     increment incx .
c     if    n .le. 0 return with result = 0.
c     if n .ge. 1 then incx must be .ge. 1
c
c           c.l.lawson, 1978 jan 08
c
c     four phase method     using two built-in constants that are
c     hopefully applicable to all machines.
c         cutlo = maximum of  sqrt(u/eps)  over all known machines.
c         cuthi = minimum of  sqrt(v)      over all known machines.
c     where
c         eps = smallest no. such that eps + 1. .gt. 1.
c         u   = smallest positive no.   (underflow limit)
c         v   = largest  no.            (overflow  limit)
c
c     brief outline of algorithm..
c
c     phase 1    scans zero components.
c     move to phase 2 when a component is nonzero and .le. cutlo
c     move to phase 3 when a component is .gt. cutlo
c     move to phase 4 when a component is .ge. cuthi/m
c     where m = n for x() real and m = 2*n for complex.
c
c     values for cutlo and cuthi..
c     from the environmental parameters listed in the imsl converter
c     document the limiting values are as follows..
c     cutlo, s.p.   u/eps = 2**(-102) for  honeywell.  close seconds are
c                   univac and dec at 2**(-103)
c                   thus cutlo = 2**(-51) = 4.44089e-16
c     cuthi, s.p.   v = 2**127 for univac, honeywell, and dec.
c                   thus cuthi = 2**(63.5) = 1.30438e19
c     cutlo, d.p.   u/eps = 2**(-67) for honeywell and dec.
c                   thus cutlo = 2**(-33.5) = 8.23181d-11
c     cuthi, d.p.   same as s.p.  cuthi = 1.30438d19
c     data cutlo, cuthi / 8.232d-11,  1.304d19 /
c     data cutlo, cuthi / 4.441e-16,  1.304e19 /
      data cutlo, cuthi / 4.441e-16,  1.304e19 /
c
      if(n .gt. 0) go to 10
         snrm2  = zero
         go to 300
c
   10 assign 30 to next
      sum = zero
      nn = n * incx
c                                                 begin main loop
      i = 1
   20    go to next,(30, 50, 70, 110)
   30 if( abs(sx(i)) .gt. cutlo) go to 85
      assign 50 to next
      xmax = zero
c
c                        phase 1.  sum is zero
c
   50 if( sx(i) .eq. zero) go to 200
      if( abs(sx(i)) .gt. cutlo) go to 85
c
c                                prepare for phase 2.
      assign 70 to next
      go to 105
c
c                                prepare for phase 4.
c
  100 i = j
      assign 110 to next
      sum = (sum / sx(i)) / sx(i)
  105 xmax = abs(sx(i))
      go to 115
c
c                   phase 2.  sum is small.
c                             scale to avoid destructive underflow.
c
   70 if( abs(sx(i)) .gt. cutlo ) go to 75
c
c                     common code for phases 2 and 4.
c                     in phase 4 sum is large.  scale to avoid overflow.
c
  110 if( abs(sx(i)) .le. xmax ) go to 115
         sum = one + sum * (xmax / sx(i))**2
         xmax = abs(sx(i))
         go to 200
c
  115 sum = sum + (sx(i)/xmax)**2
      go to 200
c
c
c                  prepare for phase 3.
c
   75 sum = (sum * xmax) * xmax
c
c
c     for real or d.p. set hitest = cuthi/n
c     for complex      set hitest = cuthi/(2*n)
c
   85 hitest = cuthi/float( n )
c
c                   phase 3.  sum is mid-range.  no scaling.
c
      do 95 j =i,nn,incx
      if(abs(sx(j)) .ge. hitest) go to 100
   95    sum = sum + sx(j)**2
      snrm2 = sqrt( sum )
      go to 300
c
  200 continue
      i = i + incx
      if ( i .le. nn ) go to 20
c
c              end of main loop.
c
c              compute square root and adjust for scaling.
c
      snrm2 = xmax * sqrt(sum)
  300 continue

      return
      end


       function issgmr(n, b, x, xl, nelt, ia, ja, a, isym, msolve,
     $     nmsl, itol, tol, itmax, iter, err, iunit, r, z, dz,
     $     rwork, iwork, rnrm, bnrm, sb, sx, jscal,
     $     kmp, lgmr, maxl, maxlp1, v, q, snormw, prod, r0nrm,
     $     hes, jpre)



      integer   kmp, lgmr, maxl, maxlp1, jpre, nmsl, n, nelt
      real      dxnrm, rnrm, r0nrm, snormw, solnrm, prod
      real      snrm2, r1mach, sb(*), sx(*), q(*), v(n,*)
      real      b(*), x(*), r(*), z(*), dz(*), rwork(*)
      real      hes(maxlp1,*), xl(*), a(nelt)
      integer   ia(nelt), ja(nelt), iwork(*)

c
c         local variables.
c
      integer    i, itol, iter, itmax, issgmr, iunit, ielmax
      integer    jscal, isym
      real       tol, err, bnrm, fuzz, ratmax, rat
      real       c,dlnrm,rho,s,tem

c      common /solblk/ soln(1)
c      save solnrm

      external   msolve

c         
c***first executable statement issgmr
      issgmr = 0
      if ( itol.eq.0 ) then
c
c       use input from spigmr to determine if stop conditions are met.
c
         err = rnrm/bnrm
      endif
      if ( (itol.gt.0) .and. (itol.le.3) ) then
c
c       use srlcal to calculate the scaled residual vector. 
c       store answer in r.
c
         if ( lgmr.ne.0 ) call srlcal(n, kmp, lgmr, maxl, v, q, r,
     $                                snormw, prod, r0nrm)
         if ( itol.le.2 ) then
c         err = ||residual||/||righthandside||(2-norms).
            err = snrm2(n, r, 1)/bnrm
c
c         unscale r by r0nrm*prod when kmp < maxl.
c
            if ( (kmp.lt.maxl) .and. (lgmr.ne.0) ) then
               tem = 1.0e0/(r0nrm*prod)
               call sscal(n, tem, r, 1)
            endif
         elseif ( itol.eq.3 ) then
c         err = max |(minv*residual)(i)/x(i)|
c         when jpre .lt. 0, r already contains minv*residual.
            if ( jpre.gt.0 ) then
               call msolve(n, r, dz, nelt, ia, ja, a, isym, rwork,
     $              iwork)
               nmsl = nmsl + 1
            endif
c
c         unscale r by r0nrm*prod when kmp < maxl.
c
            if ( (kmp.lt.maxl) .and. (lgmr.ne.0) ) then
               tem = 1.0e0/(r0nrm*prod)
               call sscal(n, tem, r, 1)
            endif
c
            fuzz = r1mach(1)
            ielmax = 1
            ratmax = abs(dz(1))/amax1(abs(x(1)),fuzz)
            do 25 i = 2, n
               rat = abs(dz(i))/amax1(abs(x(i)),fuzz)
               if( rat.gt.ratmax ) then
                  ielmax = i
                  ratmax = rat
               endif
 25         continue
            err = ratmax
            if( ratmax.le.tol ) issgmr = 1
            if( iunit.gt.0 ) write(iunit,1020) iter, ielmax, ratmax
            return
         endif
      endif
c      if ( itol.eq.11 ) then
c
c       use sxlcal to calculate the approximate solution xl.
c
c         if ( (lgmr.ne.0) .and. (iter.gt.0) ) then
c            call sxlcal(n, lgmr, x, xl, xl, hes, maxlp1, q, v,
c     $		 r0nrm,
c     $           dz, sx, jscal, jpre, msolve, nmsl, rwork, iwork,
c     $           nelt, ia, ja, a, isym)
c         elseif ( iter.eq.0 ) then
c         copy x to xl to check if initial guess is good enough.
c            call scopy(n, x, 1, xl, 1)
c         else
c         return since this is the first call to spigmr on a restart.
c            return
c         endif
c
c         if ((jscal .eq. 0) .or.(jscal .eq. 2)) then
c         err = ||x-truesolution||/||truesolution||(2-norms).
c            if ( iter.eq.0 ) solnrm = snrm2(n, soln, 1)
c            do 30 i = 1, n
c               dz(i) = xl(i) - soln(i)
c 30         continue
c            err = snrm2(n, dz, 1)/solnrm
c         else
c            if (iter .eq. 0) then
c               solnrm = 0.e0
c               do 40 i = 1,n
c                  solnrm = solnrm + (sx(i)*soln(i))**2
c 40            continue
c               solnrm = sqrt(solnrm)
c            endif
c            dxnrm = 0.e0
c            do 50 i = 1,n
c               dxnrm = dxnrm + (sx(i)*(xl(i)-soln(i)))**2
c 50         continue
c            dxnrm = sqrt(dxnrm)
c            err = dxnrm/solnrm
c         endif
c      endif
c         
      if( iunit.ne.0 ) then
         if( iter.eq.0 ) then
            write(iunit,1000) maxl, kmp, n, itol
         endif
c	 write(6,*) 'itol, iter =', itol, iter
c	 write(6,*) 'rnrm, bnrm =', rnrm, bnrm
         write(iunit,1010) iter, rnrm/bnrm, err
      endif
      if ( err.le.tol ) issgmr = 1
c         
 1000 format(' generalized minimum residual(',i3,i3,') for ',
     $     'n, itol = ',i6, i6,
     $     /' iter','   natral err est','   error estimate')
 1010 format(1x,i4,1x,e16.7,1x,e16.7)
 1020 format(1x,' iter = ',i5, ' ielmax = ',i5,
     $     ' |r(ielmax)/x(ielmax)| = ',e12.5)

c------------- last line of issgmr follows ----------------------

c
      return
      end
      subroutine solve (n)

c
c=======================================================================
c     solve for tracer distribution after diffusion using SLAP
c     based on code by a.fanning
c
c     input:
c       n    = tracer number
c
c     author:   m.eby   e-mail: eby@uvic.ca
c=======================================================================
c
c====================== include file "param.h" =========================
c
c     main parameter file which sets ocean characteristics:
c
c     "size.h" sets model size "imt", "jmt", and "km"
c
c====================== include file "size.h" ==========================
c                                                                       
c-----------------------------------------------------------------------
c     USER INPUT: 
c-----------------------------------------------------------------------
c
c     imt    = number of grid points in the longitudinal direction
c              (calculated points are from 2 through imt-1. End points
c               are boundaries)          
c
c     jmt    = number of grid points (latitude rows) in the latitudinal
c              direction (calculated points are from 2 through jmt-1.           
c              End points are boundaries)   
c                                
c     km     = number of grid points in the vertical direction          
c              (calculated points are from 1 through km)
c
c     nt     = number of tracers (temperature, salinity, ...)
c
c     mnisle = maximum number of islands (unconnected land masses)
c
c     maxipp = maximum number of all island perimeter points
c-----------------------------------------------------------------------
c                                                                       
      parameter (imt=  92, jmt=  61, km= 15)
      parameter (nt=2)
      parameter (nat=2)
      parameter (mnisle=50, maxipp=5000)
c

c






c
c-----------------------------------------------------------------------
c     END USER INPUT
c-----------------------------------------------------------------------
c                                                                       
c-----------------------------------------------------------------------
c     By default, the MW (memory window) is 2nd order except for the
c     following options which require a 4th order MW 
c
c     for 2nd order schemes, the minimum sized MW is 3 latitude rows
c     for 4th order schemes, the minimum sized MW is 4 latitude rows
c                            (5 if using coarse_grained_parallelism)
c-----------------------------------------------------------------------
c













c
c-----------------------------------------------------------------------
c     set MW (memory window) size "jmw" 
c-----------------------------------------------------------------------
c                                                                       

c
c     for UNI-TASKING: "jmw" is set to the minimum for each option class 
c     "jmw" may be increased up to "jmt" 
c

      parameter (jmw=jmt)


c
c-----------------------------------------------------------------------
c     set first and last calculated row within the MW. other rows
c     are used as buffers
c-----------------------------------------------------------------------
c
c     jsmw   = 1st calculated row within the MW     
c     jemw   = last calculated row within the MW
c
      parameter (jsmw=2, jemw=jmw-1)
c
c
c     jextra = extra buffer rows needed for coarse_grained_parallelism.
c              "jextra" rows are added to the top and bottom of the MW
c              so the MW size increases by 2*jextra       
c

          parameter (jextra = 0)




c
c     nvar   = number of prognostic variables
c     lseg   = maximum number of longitudinal stream function segments
c     nlatpr = maximum number of latitudes for matrix printouts
c              on diagnostic time steps
c     nhreg  = number of regions in the horizontal used for averaging
c              tracers.
c     nvreg  = number of regions in the vertical used for term balance
c              calculations. note "nvreg" isn`t used for tracer averages
c     numreg = total number of regions ( = product of nhreg & nvreg)
c              used for term balance calculations
c
      parameter (lseg=5, nlatpr=10)

      parameter (nhreg=5, nvreg=2, numreg=nhreg*nvreg)

      parameter (nvar=nt+2)
c

c
      parameter (imtm1=imt-1, kmm1=km-1)                                
      parameter (imtp1=imt+1, imtm2=imt-2
     &,          jmtp1=jmt+1, jmtm1=jmt-1, jmtm2=jmt-2

     &,          jscan=jmtm2

     &,          kmp1=km+1, kmp2=km+2
     &,          imtkm=imt*km, nwds=imt*jmt, nkflds=2
     &,          nslab=imt*nvar*km, ntmin2=nt+1/nt)
c
c     include parameter constants
c
c====================== include file "pconst.h" ========================
c
c
c     rules for parameter constants
c
c     use prefix of "c" for whole real numbers (eg: c57 for 57.0)
c     use "m" after prefix to designate negative values (minus sign)
c       (eg: cm7 for -7.0)
c     use prefix of "p" for non repeating fractions (eg: p5 for 0.5)
c     use prefix of "r" for reciprocals (eg: r3 for 1/3.0)
c     combine use of prefix above and "e" for scientific notation, with
c       (eg: c5e4 for 5.0e4, c1em10 for 1.0e-10)
c
      parameter (c0=0.0, c1=1.0, c2=2.0, c3=3.0, c4=4.0, c5=5.0, c7=7.0)
      parameter (c8=8.0)
      parameter (c14=14.0, c16=16.0, c360=360.0)
      parameter (p125=0.125, p25=0.25, p5=0.5, p75=0.75)
      parameter (epsln=1.0e-20)
c
      parameter (c24=24.0, c60=60.0, c1440=1440.0)
      parameter (r24=c1/c24, r60=c1/c60, r1440=c1/c1440)
      parameter (secday=c1/(c60*c1440))
c
c     include standard I/O units
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c
c     ncrows = number of calculated rows within the MW.
c              (the remaining rows are buffer rows). 
c


      parameter (ncrows = jmw - 2)


c====================== include file "slap.h" ==========================
c
c     variables needed for the energy balance model solution technique
c
c     5-point stencil
c     max number non-zeros: total, upper and lower triangles (with diag)
c
      parameter  (maxnelt = (jmt+2)*(3*imt) + 2*(imt+2)*(jmt+1))
      parameter  (maxneltu = 3*(jmt+2)*(imt+2) - imt - jmt)
      parameter  (maxneltl = maxneltu)
c
c     number direction vectors to orthogonalize against
c
      parameter  (nsave = 10)
c
c     work space
c
      parameter  (lenw = 1 + (imt)*(jmt)*(nsave+7) + 
     &	         nsave*(nsave+3) + maxneltu + maxneltl)
      parameter  (leniw =  (imt)*(jmt)*4+maxneltu + maxneltl + 32)
      real       rwork(lenw)
      integer    iwork(leniw)
c
c     the tracer matrix
c
      integer    slapia(maxnelt,2,nat), slapja(maxnelt,2,nat)
      integer    nelt, orda
c
      real       slapam(maxnelt,2,nat), slaprhs(imt*jmt,nat)
      real       slaplhs(imt*jmt,nat), sltol(nat)
c
      common /slapmats/ slapia, slapja, nelt, orda
     &,	                slapam, slaprhs, slaplhs, sltol
c
c     index maps
c
      integer    indexgrid(imt,jmt), gridrow(imt*jmt)
      integer    gridcol(imt*jmt)
c
      common /slapmaps/ indexgrid, gridrow, gridcol
c
c====================== include file "atm.h" ===========================
c
c     arrays for the energy-moisture balance model
c
c     note: units for heat flux are in g/cm**2/s**3/cm**2 or (mW/m**2)
c           units for fresh water flux are in cm/s
c           downward is into the surface (ocean, ice or land)
c           upward is into the bottom of the atmosphere
c           outward is out of the top of the atmosphere
c           inward is into the top of the atmosphere
c
c     outlwr(imt,jmt)	 = outgoing atmosphere longwave flux
c     at(imt,jmt,2,nat)	 = tracers (previous and most recent)
c     surf(imt,jmt,nat)	 = surface values (1=temperature, 2=humidity)
c     flux(imt,jmt,nat)	 = downward flux (1=heat, 2=fresh water)
c     precip(imt,jmt)	 = precipitation
c     evap(imt,jmt)	 = evaporation
c     dnswr(imt,jmt)  	 = downward surface shortwave flux
c     uplwr(imt,jmt)  	 = upward surface longwave flux
c     upsens(imt,jmt)	 = upward surface sensible heat flux
c     upltnt(imt,jmt)    = upward surface latent heat flux
c     ssh(imt,jmt) 	 = saturation specific humidity
c     spd(imt,jmt) 	 = wind speed (cm/sec)
c     da(jmt,nat)	 = tracer diffusivity parameterization
c     coalbedo(jmt)	 = planetary coalbedo
c     solins(jmt)	 = solar insolation (units of solarconst)
c     esatm(jmt)	 = atmosphere emissivity times Stefan's constant
c     scatter(jmt)	 = solar scattering into atmosphere





c     cori(jmt,2)	 = Coriolis parameter

c
      real outlwr(imt,jmt), at(imt,jmt,3,nat), surf(imt,jmt,nat)
      real flux(imt,jmt,nat), precip(imt,jmt), evap(imt,jmt)
      real dnswr(imt,jmt), uplwr(imt,jmt), upsens(imt,jmt)
      real upltnt(imt,jmt), ssh(imt,jmt), spd(imt,jmt), da(jmt,nat)
      real coalbedo(jmt), solins(jmt), esatm(jmt), scatter(jmt)





      real cori(jmt,2)
c
      common /atm/ outlwr, at, surf, flux, precip, evap, dnswr, uplwr
     &,            upsens, upltnt, spd, ssh, da, coalbedo, solins
     &,            esatm, scatter





     &,            cori
c
c====================== include file "cembm.h" =========================
c
c     parameters for use in the energy balance model (also see atm.h)
c
c     addflux		= logical flag for adding only even mode fluxes
c     nats		= number of atmospheric time steps since mixing
c     namix		= time steps between mixing (set in atmos.in)
c     lf		= time step flag (1=>leapfrog, 2=>forward)
c     pyear		= calendar year (set in atmos.in, -/+ = BC/AD)
c     dtatm 		= time step for atmosphere (set in atmos.in)
c     dts		= time step (2*dtatm=>leapfrog, dtatm=>forward)
c     co2ccn		= CO2 concentration
c     anthro		= radiative forcing by CO2
c     co2ccni		= initial CO2 concentration
c     co2yri		= last year of initial CO2 concentration
c     co2ccnf		= final CO2 concentration
c     co2yrf		= first year of final CO2 concentration
c     solarconst	= solar constant (g/s**3)
c     ssp		= sea surface pressure (g/cm/s**2)
c     cdatm 		= drag coefficient (dimensionless)
c     cpatm		= atmospheric heat capacity (cm**2/s**2/K)
c     ht		= scale height for temperature
c     hq		= scale height for specific humidity
c     rhoatm		= density of air at sea surface (g/cm**3)
c     rhoocn		= representative sea surface density
c     esocn		= ocean emissivity times Stefan's constant 
c     vlocn		= latent heat of vaporization of water
c     socn		= constant ocean salinity
c     cdice 		= drag coefficient (dimensionless)
c     rhoice		= ice density (g/cm**3)
c     esice		= ice emissivity times Stefan's constant 
c     slice		= latent heat of sublimation of ice
c     flice		= latent heat of fusion of ice (cm**2/s**2)
c     condice		= ice conductivity (g*cm/s**3/K)
c     kadv		= time step divider for ice advection
c     ntats		= time step counter for time averaging
c     avetime		= time for averaging fluxes
c     totaltime		= total time for long term averages
c
      logical addflux
c
      common /cembm/ addflux
      common /cembm/ nats, namix, lf, kadv, ntats
      common /cembm/ pyear, dtatm, dts, co2ccn, anthro, co2ccni, co2yri
     &,              co2ccnf, co2yrf, solarconst, ssp, cdatm, cpatm, ht
     &,              hq, rhoatm, rhoocn, esocn, vlocn, socn, cdice
     &,              rhoice, esice, slice, flice, condice, avetime 
     &,              totaltime
c
c
c
c-----------------------------------------------------------------------
c     move previous solution in time
c-----------------------------------------------------------------------
c
      do j=1,jmt
        do i=1,imt
          at(i,j,1,n) = at(i,j,2,n)
          at(i,j,2,n) = 0.0
        enddo
      enddo
c
c-----------------------------------------------------------------------
c     if solving for temperature add in latent heat from precipitation
c-----------------------------------------------------------------------
c
      if (n .eq. 1) then 
        fa = dts*vlocn*rhoocn/(cpatm*rhoatm*ht)
        do j=2,jmtm1
          do i=2,imtm1
            k = indexgrid(i,j)
            slaprhs(k,n) = slaprhs(k,n) + fa*precip(i,j)
          enddo
        enddo
      endif
c
      tol = sltol(n)
c
      isym = 0      !zero for non-symmetric, one for symmetric
      itol = 0      !stopping criterion selector
      itmax = 900   !max number of iterations
      iunit = 0     !output unit number: zero for no monitoring
c
c-----------------------------------------------------------------------
c     solve for tracer using "slap"
c-----------------------------------------------------------------------
c
      call sslugm(orda, slaprhs(1,n), slaplhs(1,n), nelt
     &,           slapia(1,lf,n), slapja(1,lf,n), slapam(1,lf,n)
     &,           isym, nsave, itol, tol, itmax, iter, err
     &,           ierr, iunit, rwork, lenw, iwork, leniw)
c
      if (ierr .ne. 0) write(*,*) 'iter, ierr, n =', iter, ierr, n
c
c-----------------------------------------------------------------------
c     copy new solution from left hand side
c-----------------------------------------------------------------------
c
      do k=1,orda
        i = gridcol(k)
        j = gridrow(k)
        at(i,j,2,n) = slaplhs(k,n)
      enddo
c
c-----------------------------------------------------------------------
c     set boundary conditions
c-----------------------------------------------------------------------
c
      call embmbc (at(1,1,2,n))
c
      return 
      end


      subroutine indexmaps
c
c=======================================================================
c     produces maps from interior tracer points on grid to vector of
c     unknowns and back again. cyclic and closed N/S conditions handled
c     implicitly so only use 2:imtm1, 2:jmtm1     
c     based on code by a.fanning
c
c     author:   m.eby   e-mail: eby@uvic.ca
c=======================================================================
c
c====================== include file "param.h" =========================
c
c     main parameter file which sets ocean characteristics:
c
c     "size.h" sets model size "imt", "jmt", and "km"
c
c====================== include file "size.h" ==========================
c                                                                       
c-----------------------------------------------------------------------
c     USER INPUT: 
c-----------------------------------------------------------------------
c
c     imt    = number of grid points in the longitudinal direction
c              (calculated points are from 2 through imt-1. End points
c               are boundaries)          
c
c     jmt    = number of grid points (latitude rows) in the latitudinal
c              direction (calculated points are from 2 through jmt-1.           
c              End points are boundaries)   
c                                
c     km     = number of grid points in the vertical direction          
c              (calculated points are from 1 through km)
c
c     nt     = number of tracers (temperature, salinity, ...)
c
c     mnisle = maximum number of islands (unconnected land masses)
c
c     maxipp = maximum number of all island perimeter points
c-----------------------------------------------------------------------
c                                                                       
      parameter (imt=  92, jmt=  61, km= 15)
      parameter (nt=2)
      parameter (nat=2)
      parameter (mnisle=50, maxipp=5000)
c

c






c
c-----------------------------------------------------------------------
c     END USER INPUT
c-----------------------------------------------------------------------
c                                                                       
c-----------------------------------------------------------------------
c     By default, the MW (memory window) is 2nd order except for the
c     following options which require a 4th order MW 
c
c     for 2nd order schemes, the minimum sized MW is 3 latitude rows
c     for 4th order schemes, the minimum sized MW is 4 latitude rows
c                            (5 if using coarse_grained_parallelism)
c-----------------------------------------------------------------------
c













c
c-----------------------------------------------------------------------
c     set MW (memory window) size "jmw" 
c-----------------------------------------------------------------------
c                                                                       

c
c     for UNI-TASKING: "jmw" is set to the minimum for each option class 
c     "jmw" may be increased up to "jmt" 
c

      parameter (jmw=jmt)


c
c-----------------------------------------------------------------------
c     set first and last calculated row within the MW. other rows
c     are used as buffers
c-----------------------------------------------------------------------
c
c     jsmw   = 1st calculated row within the MW     
c     jemw   = last calculated row within the MW
c
      parameter (jsmw=2, jemw=jmw-1)
c
c
c     jextra = extra buffer rows needed for coarse_grained_parallelism.
c              "jextra" rows are added to the top and bottom of the MW
c              so the MW size increases by 2*jextra       
c

          parameter (jextra = 0)




c
c     nvar   = number of prognostic variables
c     lseg   = maximum number of longitudinal stream function segments
c     nlatpr = maximum number of latitudes for matrix printouts
c              on diagnostic time steps
c     nhreg  = number of regions in the horizontal used for averaging
c              tracers.
c     nvreg  = number of regions in the vertical used for term balance
c              calculations. note "nvreg" isn`t used for tracer averages
c     numreg = total number of regions ( = product of nhreg & nvreg)
c              used for term balance calculations
c
      parameter (lseg=5, nlatpr=10)

      parameter (nhreg=5, nvreg=2, numreg=nhreg*nvreg)

      parameter (nvar=nt+2)
c

c
      parameter (imtm1=imt-1, kmm1=km-1)                                
      parameter (imtp1=imt+1, imtm2=imt-2
     &,          jmtp1=jmt+1, jmtm1=jmt-1, jmtm2=jmt-2

     &,          jscan=jmtm2

     &,          kmp1=km+1, kmp2=km+2
     &,          imtkm=imt*km, nwds=imt*jmt, nkflds=2
     &,          nslab=imt*nvar*km, ntmin2=nt+1/nt)
c
c     include parameter constants
c
c====================== include file "pconst.h" ========================
c
c
c     rules for parameter constants
c
c     use prefix of "c" for whole real numbers (eg: c57 for 57.0)
c     use "m" after prefix to designate negative values (minus sign)
c       (eg: cm7 for -7.0)
c     use prefix of "p" for non repeating fractions (eg: p5 for 0.5)
c     use prefix of "r" for reciprocals (eg: r3 for 1/3.0)
c     combine use of prefix above and "e" for scientific notation, with
c       (eg: c5e4 for 5.0e4, c1em10 for 1.0e-10)
c
      parameter (c0=0.0, c1=1.0, c2=2.0, c3=3.0, c4=4.0, c5=5.0, c7=7.0)
      parameter (c8=8.0)
      parameter (c14=14.0, c16=16.0, c360=360.0)
      parameter (p125=0.125, p25=0.25, p5=0.5, p75=0.75)
      parameter (epsln=1.0e-20)
c
      parameter (c24=24.0, c60=60.0, c1440=1440.0)
      parameter (r24=c1/c24, r60=c1/c60, r1440=c1/c1440)
      parameter (secday=c1/(c60*c1440))
c
c     include standard I/O units
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c
c     ncrows = number of calculated rows within the MW.
c              (the remaining rows are buffer rows). 
c


      parameter (ncrows = jmw - 2)


c====================== include file "slap.h" ==========================
c
c     variables needed for the energy balance model solution technique
c
c     5-point stencil
c     max number non-zeros: total, upper and lower triangles (with diag)
c
      parameter  (maxnelt = (jmt+2)*(3*imt) + 2*(imt+2)*(jmt+1))
      parameter  (maxneltu = 3*(jmt+2)*(imt+2) - imt - jmt)
      parameter  (maxneltl = maxneltu)
c
c     number direction vectors to orthogonalize against
c
      parameter  (nsave = 10)
c
c     work space
c
      parameter  (lenw = 1 + (imt)*(jmt)*(nsave+7) + 
     &	         nsave*(nsave+3) + maxneltu + maxneltl)
      parameter  (leniw =  (imt)*(jmt)*4+maxneltu + maxneltl + 32)
      real       rwork(lenw)
      integer    iwork(leniw)
c
c     the tracer matrix
c
      integer    slapia(maxnelt,2,nat), slapja(maxnelt,2,nat)
      integer    nelt, orda
c
      real       slapam(maxnelt,2,nat), slaprhs(imt*jmt,nat)
      real       slaplhs(imt*jmt,nat), sltol(nat)
c
      common /slapmats/ slapia, slapja, nelt, orda
     &,	                slapam, slaprhs, slaplhs, sltol
c
c     index maps
c
      integer    indexgrid(imt,jmt), gridrow(imt*jmt)
      integer    gridcol(imt*jmt)
c
      common /slapmaps/ indexgrid, gridrow, gridcol
c
c
c
      orda = 0
      do j=2,jmtm1
        do i=2,imtm1
          orda = orda + 1
          indexgrid(i,j) = orda
          gridrow(orda) = j
          gridcol(orda) = i
        enddo
      enddo
c
      return
      end


      subroutine newrhs
c
c=======================================================================
c     calculate new right hand side
c     based on code by a.fanning
c
c     author:   m.eby   e-mail: eby@uvic.ca
c=======================================================================
c
c====================== include file "param.h" =========================
c
c     main parameter file which sets ocean characteristics:
c
c     "size.h" sets model size "imt", "jmt", and "km"
c
c====================== include file "size.h" ==========================
c                                                                       
c-----------------------------------------------------------------------
c     USER INPUT: 
c-----------------------------------------------------------------------
c
c     imt    = number of grid points in the longitudinal direction
c              (calculated points are from 2 through imt-1. End points
c               are boundaries)          
c
c     jmt    = number of grid points (latitude rows) in the latitudinal
c              direction (calculated points are from 2 through jmt-1.           
c              End points are boundaries)   
c                                
c     km     = number of grid points in the vertical direction          
c              (calculated points are from 1 through km)
c
c     nt     = number of tracers (temperature, salinity, ...)
c
c     mnisle = maximum number of islands (unconnected land masses)
c
c     maxipp = maximum number of all island perimeter points
c-----------------------------------------------------------------------
c                                                                       
      parameter (imt=  92, jmt=  61, km= 15)
      parameter (nt=2)
      parameter (nat=2)
      parameter (mnisle=50, maxipp=5000)
c

c






c
c-----------------------------------------------------------------------
c     END USER INPUT
c-----------------------------------------------------------------------
c                                                                       
c-----------------------------------------------------------------------
c     By default, the MW (memory window) is 2nd order except for the
c     following options which require a 4th order MW 
c
c     for 2nd order schemes, the minimum sized MW is 3 latitude rows
c     for 4th order schemes, the minimum sized MW is 4 latitude rows
c                            (5 if using coarse_grained_parallelism)
c-----------------------------------------------------------------------
c













c
c-----------------------------------------------------------------------
c     set MW (memory window) size "jmw" 
c-----------------------------------------------------------------------
c                                                                       

c
c     for UNI-TASKING: "jmw" is set to the minimum for each option class 
c     "jmw" may be increased up to "jmt" 
c

      parameter (jmw=jmt)


c
c-----------------------------------------------------------------------
c     set first and last calculated row within the MW. other rows
c     are used as buffers
c-----------------------------------------------------------------------
c
c     jsmw   = 1st calculated row within the MW     
c     jemw   = last calculated row within the MW
c
      parameter (jsmw=2, jemw=jmw-1)
c
c
c     jextra = extra buffer rows needed for coarse_grained_parallelism.
c              "jextra" rows are added to the top and bottom of the MW
c              so the MW size increases by 2*jextra       
c

          parameter (jextra = 0)




c
c     nvar   = number of prognostic variables
c     lseg   = maximum number of longitudinal stream function segments
c     nlatpr = maximum number of latitudes for matrix printouts
c              on diagnostic time steps
c     nhreg  = number of regions in the horizontal used for averaging
c              tracers.
c     nvreg  = number of regions in the vertical used for term balance
c              calculations. note "nvreg" isn`t used for tracer averages
c     numreg = total number of regions ( = product of nhreg & nvreg)
c              used for term balance calculations
c
      parameter (lseg=5, nlatpr=10)

      parameter (nhreg=5, nvreg=2, numreg=nhreg*nvreg)

      parameter (nvar=nt+2)
c

c
      parameter (imtm1=imt-1, kmm1=km-1)                                
      parameter (imtp1=imt+1, imtm2=imt-2
     &,          jmtp1=jmt+1, jmtm1=jmt-1, jmtm2=jmt-2

     &,          jscan=jmtm2

     &,          kmp1=km+1, kmp2=km+2
     &,          imtkm=imt*km, nwds=imt*jmt, nkflds=2
     &,          nslab=imt*nvar*km, ntmin2=nt+1/nt)
c
c     include parameter constants
c
c====================== include file "pconst.h" ========================
c
c
c     rules for parameter constants
c
c     use prefix of "c" for whole real numbers (eg: c57 for 57.0)
c     use "m" after prefix to designate negative values (minus sign)
c       (eg: cm7 for -7.0)
c     use prefix of "p" for non repeating fractions (eg: p5 for 0.5)
c     use prefix of "r" for reciprocals (eg: r3 for 1/3.0)
c     combine use of prefix above and "e" for scientific notation, with
c       (eg: c5e4 for 5.0e4, c1em10 for 1.0e-10)
c
      parameter (c0=0.0, c1=1.0, c2=2.0, c3=3.0, c4=4.0, c5=5.0, c7=7.0)
      parameter (c8=8.0)
      parameter (c14=14.0, c16=16.0, c360=360.0)
      parameter (p125=0.125, p25=0.25, p5=0.5, p75=0.75)
      parameter (epsln=1.0e-20)
c
      parameter (c24=24.0, c60=60.0, c1440=1440.0)
      parameter (r24=c1/c24, r60=c1/c60, r1440=c1/c1440)
      parameter (secday=c1/(c60*c1440))
c
c     include standard I/O units
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c
c     ncrows = number of calculated rows within the MW.
c              (the remaining rows are buffer rows). 
c


      parameter (ncrows = jmw - 2)


c====================== include file "slap.h" ==========================
c
c     variables needed for the energy balance model solution technique
c
c     5-point stencil
c     max number non-zeros: total, upper and lower triangles (with diag)
c
      parameter  (maxnelt = (jmt+2)*(3*imt) + 2*(imt+2)*(jmt+1))
      parameter  (maxneltu = 3*(jmt+2)*(imt+2) - imt - jmt)
      parameter  (maxneltl = maxneltu)
c
c     number direction vectors to orthogonalize against
c
      parameter  (nsave = 10)
c
c     work space
c
      parameter  (lenw = 1 + (imt)*(jmt)*(nsave+7) + 
     &	         nsave*(nsave+3) + maxneltu + maxneltl)
      parameter  (leniw =  (imt)*(jmt)*4+maxneltu + maxneltl + 32)
      real       rwork(lenw)
      integer    iwork(leniw)
c
c     the tracer matrix
c
      integer    slapia(maxnelt,2,nat), slapja(maxnelt,2,nat)
      integer    nelt, orda
c
      real       slapam(maxnelt,2,nat), slaprhs(imt*jmt,nat)
      real       slaplhs(imt*jmt,nat), sltol(nat)
c
      common /slapmats/ slapia, slapja, nelt, orda
     &,	                slapam, slaprhs, slaplhs, sltol
c
c     index maps
c
      integer    indexgrid(imt,jmt), gridrow(imt*jmt)
      integer    gridcol(imt*jmt)
c
      common /slapmaps/ indexgrid, gridrow, gridcol
c
c====================== include file "cembm.h" =========================
c
c     parameters for use in the energy balance model (also see atm.h)
c
c     addflux		= logical flag for adding only even mode fluxes
c     nats		= number of atmospheric time steps since mixing
c     namix		= time steps between mixing (set in atmos.in)
c     lf		= time step flag (1=>leapfrog, 2=>forward)
c     pyear		= calendar year (set in atmos.in, -/+ = BC/AD)
c     dtatm 		= time step for atmosphere (set in atmos.in)
c     dts		= time step (2*dtatm=>leapfrog, dtatm=>forward)
c     co2ccn		= CO2 concentration
c     anthro		= radiative forcing by CO2
c     co2ccni		= initial CO2 concentration
c     co2yri		= last year of initial CO2 concentration
c     co2ccnf		= final CO2 concentration
c     co2yrf		= first year of final CO2 concentration
c     solarconst	= solar constant (g/s**3)
c     ssp		= sea surface pressure (g/cm/s**2)
c     cdatm 		= drag coefficient (dimensionless)
c     cpatm		= atmospheric heat capacity (cm**2/s**2/K)
c     ht		= scale height for temperature
c     hq		= scale height for specific humidity
c     rhoatm		= density of air at sea surface (g/cm**3)
c     rhoocn		= representative sea surface density
c     esocn		= ocean emissivity times Stefan's constant 
c     vlocn		= latent heat of vaporization of water
c     socn		= constant ocean salinity
c     cdice 		= drag coefficient (dimensionless)
c     rhoice		= ice density (g/cm**3)
c     esice		= ice emissivity times Stefan's constant 
c     slice		= latent heat of sublimation of ice
c     flice		= latent heat of fusion of ice (cm**2/s**2)
c     condice		= ice conductivity (g*cm/s**3/K)
c     kadv		= time step divider for ice advection
c     ntats		= time step counter for time averaging
c     avetime		= time for averaging fluxes
c     totaltime		= total time for long term averages
c
      logical addflux
c
      common /cembm/ addflux
      common /cembm/ nats, namix, lf, kadv, ntats
      common /cembm/ pyear, dtatm, dts, co2ccn, anthro, co2ccni, co2yri
     &,              co2ccnf, co2yrf, solarconst, ssp, cdatm, cpatm, ht
     &,              hq, rhoatm, rhoocn, esocn, vlocn, socn, cdice
     &,              rhoice, esice, slice, flice, condice, avetime 
     &,              totaltime
c
c====================== include file "atm.h" ===========================
c
c     arrays for the energy-moisture balance model
c
c     note: units for heat flux are in g/cm**2/s**3/cm**2 or (mW/m**2)
c           units for fresh water flux are in cm/s
c           downward is into the surface (ocean, ice or land)
c           upward is into the bottom of the atmosphere
c           outward is out of the top of the atmosphere
c           inward is into the top of the atmosphere
c
c     outlwr(imt,jmt)	 = outgoing atmosphere longwave flux
c     at(imt,jmt,2,nat)	 = tracers (previous and most recent)
c     surf(imt,jmt,nat)	 = surface values (1=temperature, 2=humidity)
c     flux(imt,jmt,nat)	 = downward flux (1=heat, 2=fresh water)
c     precip(imt,jmt)	 = precipitation
c     evap(imt,jmt)	 = evaporation
c     dnswr(imt,jmt)  	 = downward surface shortwave flux
c     uplwr(imt,jmt)  	 = upward surface longwave flux
c     upsens(imt,jmt)	 = upward surface sensible heat flux
c     upltnt(imt,jmt)    = upward surface latent heat flux
c     ssh(imt,jmt) 	 = saturation specific humidity
c     spd(imt,jmt) 	 = wind speed (cm/sec)
c     da(jmt,nat)	 = tracer diffusivity parameterization
c     coalbedo(jmt)	 = planetary coalbedo
c     solins(jmt)	 = solar insolation (units of solarconst)
c     esatm(jmt)	 = atmosphere emissivity times Stefan's constant
c     scatter(jmt)	 = solar scattering into atmosphere





c     cori(jmt,2)	 = Coriolis parameter

c
      real outlwr(imt,jmt), at(imt,jmt,3,nat), surf(imt,jmt,nat)
      real flux(imt,jmt,nat), precip(imt,jmt), evap(imt,jmt)
      real dnswr(imt,jmt), uplwr(imt,jmt), upsens(imt,jmt)
      real upltnt(imt,jmt), ssh(imt,jmt), spd(imt,jmt), da(jmt,nat)
      real coalbedo(jmt), solins(jmt), esatm(jmt), scatter(jmt)





      real cori(jmt,2)
c
      common /atm/ outlwr, at, surf, flux, precip, evap, dnswr, uplwr
     &,            upsens, upltnt, spd, ssh, da, coalbedo, solins
     &,            esatm, scatter





     &,            cori
c
c====================== include file "levind.h" ========================
c
c     vertical level indicators which define model geometry & bottom
c     topography:
c
c     kmt = number of vertical boxes over "t" points
c     kmu = number of vertical boxes over "u,v" points
c
      common /levind/ kmt(imt,jmt), kmu(imt,jmt)
c
c
c-----------------------------------------------------------------------
c     air temperature
c-----------------------------------------------------------------------
c
      fa = dts/(cpatm*rhoatm*ht)
      do j=2,jmtm1
c       incoming swr absorbed by the atmosphere is fc*dnswr
        fc = scatter(j)/(1.0 - scatter(j))
        do i=2,imtm1
          k = indexgrid(i,j)
          if (kmt(i,j) .gt. 0) then
            slaprhs(k,1) = at(i,j,lf,1) + fa*(fc*dnswr(i,j)
     &                   - outlwr(i,j) + uplwr(i,j) + upsens(i,j))
          else
            slaprhs(k,1) = at(i,j,lf,1) + fa*(fc*dnswr(i,j) 
     &                   - outlwr(i,j) + dnswr(i,j))
          endif
        enddo
      enddo
c
c-----------------------------------------------------------------------
c     specific humidity
c-----------------------------------------------------------------------
c
      fa = dts*rhoocn/(rhoatm*hq)
      do j=2,jmtm1
        do i=2,imtm1
          k = indexgrid(i,j)
          if (kmt(i,j) .gt. 0) then
            slaprhs(k,2) = at(i,j,lf,2) + fa*evap(i,j)
          else
            slaprhs(k,2) = at(i,j,lf,2)
          endif
        enddo
      enddo
c
c-----------------------------------------------------------------------
c     add other tracer source and sink terms here
c-----------------------------------------------------------------------
c
      do n=3,nat
        do j=2,jmtm1
          do i=2,imtm1
            k = indexgrid(i,j)
            slaprhs(k,n) = at(i,j,lf,n)
          enddo
        enddo
      enddo
c
      return
      end


      subroutine coef (n)
c
c=======================================================================
c     compute matrix coefficients
c       coefficient storage
c       non-zero element A(i,j) is stored in AM(pos)
c       row index i             is stored in ia(pos)
c       column index j          is stored in ja(pos)
c       coefficients for a single grid point are stored as a group
c	these form one row of the coefficient matrix
c     based on code by a.fanning
c
c     input:
c       n    = tracer number
c
c     author:   m.eby   e-mail: eby@uvic.ca
c=======================================================================
c
c====================== include file "param.h" =========================
c
c     main parameter file which sets ocean characteristics:
c
c     "size.h" sets model size "imt", "jmt", and "km"
c
c====================== include file "size.h" ==========================
c                                                                       
c-----------------------------------------------------------------------
c     USER INPUT: 
c-----------------------------------------------------------------------
c
c     imt    = number of grid points in the longitudinal direction
c              (calculated points are from 2 through imt-1. End points
c               are boundaries)          
c
c     jmt    = number of grid points (latitude rows) in the latitudinal
c              direction (calculated points are from 2 through jmt-1.           
c              End points are boundaries)   
c                                
c     km     = number of grid points in the vertical direction          
c              (calculated points are from 1 through km)
c
c     nt     = number of tracers (temperature, salinity, ...)
c
c     mnisle = maximum number of islands (unconnected land masses)
c
c     maxipp = maximum number of all island perimeter points
c-----------------------------------------------------------------------
c                                                                       
      parameter (imt=  92, jmt=  61, km= 15)
      parameter (nt=2)
      parameter (nat=2)
      parameter (mnisle=50, maxipp=5000)
c

c






c
c-----------------------------------------------------------------------
c     END USER INPUT
c-----------------------------------------------------------------------
c                                                                       
c-----------------------------------------------------------------------
c     By default, the MW (memory window) is 2nd order except for the
c     following options which require a 4th order MW 
c
c     for 2nd order schemes, the minimum sized MW is 3 latitude rows
c     for 4th order schemes, the minimum sized MW is 4 latitude rows
c                            (5 if using coarse_grained_parallelism)
c-----------------------------------------------------------------------
c













c
c-----------------------------------------------------------------------
c     set MW (memory window) size "jmw" 
c-----------------------------------------------------------------------
c                                                                       

c
c     for UNI-TASKING: "jmw" is set to the minimum for each option class 
c     "jmw" may be increased up to "jmt" 
c

      parameter (jmw=jmt)


c
c-----------------------------------------------------------------------
c     set first and last calculated row within the MW. other rows
c     are used as buffers
c-----------------------------------------------------------------------
c
c     jsmw   = 1st calculated row within the MW     
c     jemw   = last calculated row within the MW
c
      parameter (jsmw=2, jemw=jmw-1)
c
c
c     jextra = extra buffer rows needed for coarse_grained_parallelism.
c              "jextra" rows are added to the top and bottom of the MW
c              so the MW size increases by 2*jextra       
c

          parameter (jextra = 0)




c
c     nvar   = number of prognostic variables
c     lseg   = maximum number of longitudinal stream function segments
c     nlatpr = maximum number of latitudes for matrix printouts
c              on diagnostic time steps
c     nhreg  = number of regions in the horizontal used for averaging
c              tracers.
c     nvreg  = number of regions in the vertical used for term balance
c              calculations. note "nvreg" isn`t used for tracer averages
c     numreg = total number of regions ( = product of nhreg & nvreg)
c              used for term balance calculations
c
      parameter (lseg=5, nlatpr=10)

      parameter (nhreg=5, nvreg=2, numreg=nhreg*nvreg)

      parameter (nvar=nt+2)
c

c
      parameter (imtm1=imt-1, kmm1=km-1)                                
      parameter (imtp1=imt+1, imtm2=imt-2
     &,          jmtp1=jmt+1, jmtm1=jmt-1, jmtm2=jmt-2

     &,          jscan=jmtm2

     &,          kmp1=km+1, kmp2=km+2
     &,          imtkm=imt*km, nwds=imt*jmt, nkflds=2
     &,          nslab=imt*nvar*km, ntmin2=nt+1/nt)
c
c     include parameter constants
c
c====================== include file "pconst.h" ========================
c
c
c     rules for parameter constants
c
c     use prefix of "c" for whole real numbers (eg: c57 for 57.0)
c     use "m" after prefix to designate negative values (minus sign)
c       (eg: cm7 for -7.0)
c     use prefix of "p" for non repeating fractions (eg: p5 for 0.5)
c     use prefix of "r" for reciprocals (eg: r3 for 1/3.0)
c     combine use of prefix above and "e" for scientific notation, with
c       (eg: c5e4 for 5.0e4, c1em10 for 1.0e-10)
c
      parameter (c0=0.0, c1=1.0, c2=2.0, c3=3.0, c4=4.0, c5=5.0, c7=7.0)
      parameter (c8=8.0)
      parameter (c14=14.0, c16=16.0, c360=360.0)
      parameter (p125=0.125, p25=0.25, p5=0.5, p75=0.75)
      parameter (epsln=1.0e-20)
c
      parameter (c24=24.0, c60=60.0, c1440=1440.0)
      parameter (r24=c1/c24, r60=c1/c60, r1440=c1/c1440)
      parameter (secday=c1/(c60*c1440))
c
c     include standard I/O units
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c
c     ncrows = number of calculated rows within the MW.
c              (the remaining rows are buffer rows). 
c


      parameter (ncrows = jmw - 2)


c====================== include file "slap.h" ==========================
c
c     variables needed for the energy balance model solution technique
c
c     5-point stencil
c     max number non-zeros: total, upper and lower triangles (with diag)
c
      parameter  (maxnelt = (jmt+2)*(3*imt) + 2*(imt+2)*(jmt+1))
      parameter  (maxneltu = 3*(jmt+2)*(imt+2) - imt - jmt)
      parameter  (maxneltl = maxneltu)
c
c     number direction vectors to orthogonalize against
c
      parameter  (nsave = 10)
c
c     work space
c
      parameter  (lenw = 1 + (imt)*(jmt)*(nsave+7) + 
     &	         nsave*(nsave+3) + maxneltu + maxneltl)
      parameter  (leniw =  (imt)*(jmt)*4+maxneltu + maxneltl + 32)
      real       rwork(lenw)
      integer    iwork(leniw)
c
c     the tracer matrix
c
      integer    slapia(maxnelt,2,nat), slapja(maxnelt,2,nat)
      integer    nelt, orda
c
      real       slapam(maxnelt,2,nat), slaprhs(imt*jmt,nat)
      real       slaplhs(imt*jmt,nat), sltol(nat)
c
      common /slapmats/ slapia, slapja, nelt, orda
     &,	                slapam, slaprhs, slaplhs, sltol
c
c     index maps
c
      integer    indexgrid(imt,jmt), gridrow(imt*jmt)
      integer    gridcol(imt*jmt)
c
      common /slapmaps/ indexgrid, gridrow, gridcol
c
c====================== include file "grdvar.h" ========================
c
c     variables which are functions of the grid defined by "coord.h"
c
c     dxt     = longitudinal width of "t" grid box at the 
c               equator (in cm)
c     dxtr    = reciprocal of "dxt"
c     dxt2r   = reciprocal of "2*dxt"
c     dxt4r   = reciprocal of "4*dxt"
c     dxu     = longitudinal width of "u,v" grid box at the 
c               equator (in cm)
c     dxur    = reciprocal of "dxu"
c     dxu2r   = reciprocal of "2*dxu"
c     dxu4r   = reciprocal of "4*dxu"
c     dxmetr  = reciprocal of "(dxt(i)+dxt(i+1))"
c     duw     = xu(i) - xt(i)
c     due     = xt(i+1) - xu(i)
c     dus     = yu(jrow) - yt(jrow)
c     dun     = yt(jrow+1) - yu(jrow)
c
c     dyt     = latitudinal height of "t" grid box (in cm)
c     dytr    = reciprocal of "dyt"
c     dyt2r   = reciprocal of "2*dyt"
c     dyt4r   = reciprocal of "4*dyt"
c     dyu     = latitudinal height of "u,v" grid box (in cm)
c     dyur    = reciprocal of "dyu"
c     dyu2r   = reciprocal of "2*dyu"
c     dyu4r   = reciprocal of "4*dyu"
c
c     csu     = cosine of "u,v" grid point latitude
c     csur    = reciprocal of "csu"
c     cst     = cosine of "t" grid point latitude
c     cstr    = reciprocal of "cst"
c     phi     = latitude of "u,v" grid point in radians
c     phit    = latitude of "t" grid point in radians
c     sine    = sine of "u,v" grid point latitude
c     tng     = tan of "u,v" grid point latitude
c     fcor    = 2*omega*sine(j)
c
c     c2dzt(k)= "2*dzt"
c     dztr(k) = reciprocal of dzt ("t" cell vertical resolution)
c     dzt2r(k)= reciprocal of "2*dzt"
c     dzwr(k) = reciprocal of dzw ("w" cell vertical resolution)
c     dzw2r(k)= reciprocal of "2*dzw"
c     dztur(k)= upper diffusion grid factor = 1.0/(dzw(k-1)*dzt(k))
c     dztlr(k)= lower diffusion grid factor = 1.0/(dzw(k)*dzt(k))
c     dzwur(k)= upper diffusion grid factor = 1.0/(dzt(k)*dzw(k))
c     dzwlr(k)= lower diffusion grid factor = 1.0/(dzt(k+1)*dzw(k))
c     
      common /grdvar/ dxt(imt),  dxtr(imt),  dxt2r(imt), dxu(imt)
      common /grdvar/ dxur(imt), dxu2r(imt), dxu4r(imt), dxt4r(imt)
      common /grdvar/ dyt(jmt),  dytr(jmt),  dyt2r(jmt), dyu(jmt)
      common /grdvar/ dyur(jmt), dyu2r(jmt), dyu4r(jmt), dyt4r(jmt)
      common /grdvar/ csu(jmt),  csur(jmt),  cst(jmt),   cstr(jmt)
      common /grdvar/ cstdytr(jmt), cstdyt2r(jmt)
      common /grdvar/ csudyur(jmt), csudyu2r(jmt)
      common /grdvar/ cst_dytr(jmt), csu_dyur(jmt)
      common /grdvar/ phi(jmt),  phit(jmt),  sine(jmt),  tng(jmt)
      common /grdvar/ fcor(jmt), c2dzt(km),  dztr(km),   dzt2r(km) 
      common /grdvar/ dzwr(0:km), dzw2r(0:km)
      common /grdvar/ dxmetr(imt), duw(imt), due(imt)
      common /grdvar/ dun(jmt), dus(jmt)


c

c====================== include file "cembm.h" =========================
c
c     parameters for use in the energy balance model (also see atm.h)
c
c     addflux		= logical flag for adding only even mode fluxes
c     nats		= number of atmospheric time steps since mixing
c     namix		= time steps between mixing (set in atmos.in)
c     lf		= time step flag (1=>leapfrog, 2=>forward)
c     pyear		= calendar year (set in atmos.in, -/+ = BC/AD)
c     dtatm 		= time step for atmosphere (set in atmos.in)
c     dts		= time step (2*dtatm=>leapfrog, dtatm=>forward)
c     co2ccn		= CO2 concentration
c     anthro		= radiative forcing by CO2
c     co2ccni		= initial CO2 concentration
c     co2yri		= last year of initial CO2 concentration
c     co2ccnf		= final CO2 concentration
c     co2yrf		= first year of final CO2 concentration
c     solarconst	= solar constant (g/s**3)
c     ssp		= sea surface pressure (g/cm/s**2)
c     cdatm 		= drag coefficient (dimensionless)
c     cpatm		= atmospheric heat capacity (cm**2/s**2/K)
c     ht		= scale height for temperature
c     hq		= scale height for specific humidity
c     rhoatm		= density of air at sea surface (g/cm**3)
c     rhoocn		= representative sea surface density
c     esocn		= ocean emissivity times Stefan's constant 
c     vlocn		= latent heat of vaporization of water
c     socn		= constant ocean salinity
c     cdice 		= drag coefficient (dimensionless)
c     rhoice		= ice density (g/cm**3)
c     esice		= ice emissivity times Stefan's constant 
c     slice		= latent heat of sublimation of ice
c     flice		= latent heat of fusion of ice (cm**2/s**2)
c     condice		= ice conductivity (g*cm/s**3/K)
c     kadv		= time step divider for ice advection
c     ntats		= time step counter for time averaging
c     avetime		= time for averaging fluxes
c     totaltime		= total time for long term averages
c
      logical addflux
c
      common /cembm/ addflux
      common /cembm/ nats, namix, lf, kadv, ntats
      common /cembm/ pyear, dtatm, dts, co2ccn, anthro, co2ccni, co2yri
     &,              co2ccnf, co2yrf, solarconst, ssp, cdatm, cpatm, ht
     &,              hq, rhoatm, rhoocn, esocn, vlocn, socn, cdice
     &,              rhoice, esice, slice, flice, condice, avetime 
     &,              totaltime
c
c====================== include file "atm.h" ===========================
c
c     arrays for the energy-moisture balance model
c
c     note: units for heat flux are in g/cm**2/s**3/cm**2 or (mW/m**2)
c           units for fresh water flux are in cm/s
c           downward is into the surface (ocean, ice or land)
c           upward is into the bottom of the atmosphere
c           outward is out of the top of the atmosphere
c           inward is into the top of the atmosphere
c
c     outlwr(imt,jmt)	 = outgoing atmosphere longwave flux
c     at(imt,jmt,2,nat)	 = tracers (previous and most recent)
c     surf(imt,jmt,nat)	 = surface values (1=temperature, 2=humidity)
c     flux(imt,jmt,nat)	 = downward flux (1=heat, 2=fresh water)
c     precip(imt,jmt)	 = precipitation
c     evap(imt,jmt)	 = evaporation
c     dnswr(imt,jmt)  	 = downward surface shortwave flux
c     uplwr(imt,jmt)  	 = upward surface longwave flux
c     upsens(imt,jmt)	 = upward surface sensible heat flux
c     upltnt(imt,jmt)    = upward surface latent heat flux
c     ssh(imt,jmt) 	 = saturation specific humidity
c     spd(imt,jmt) 	 = wind speed (cm/sec)
c     da(jmt,nat)	 = tracer diffusivity parameterization
c     coalbedo(jmt)	 = planetary coalbedo
c     solins(jmt)	 = solar insolation (units of solarconst)
c     esatm(jmt)	 = atmosphere emissivity times Stefan's constant
c     scatter(jmt)	 = solar scattering into atmosphere





c     cori(jmt,2)	 = Coriolis parameter

c
      real outlwr(imt,jmt), at(imt,jmt,3,nat), surf(imt,jmt,nat)
      real flux(imt,jmt,nat), precip(imt,jmt), evap(imt,jmt)
      real dnswr(imt,jmt), uplwr(imt,jmt), upsens(imt,jmt)
      real upltnt(imt,jmt), ssh(imt,jmt), spd(imt,jmt), da(jmt,nat)
      real coalbedo(jmt), solins(jmt), esatm(jmt), scatter(jmt)





      real cori(jmt,2)
c
      common /atm/ outlwr, at, surf, flux, precip, evap, dnswr, uplwr
     &,            upsens, upltnt, spd, ssh, da, coalbedo, solins
     &,            esatm, scatter





     &,            cori
c
c
c
      index = 0
c
      do j=2,jmtm1
c
        fa2 = dts*(da(j,n) + da(j-1,n))*dyur(j-1)*csu(j-1)*cstdyt2r(j)
        fc2 = dts*(da(j,n) + da(j+1,n))*dyur(j)*csu(j)*cstdyt2r(j)
c
        do i=2,imtm1
c
          fb3 = dts*da(j,n)*dxur(i)*dxtr(i)*cstr(j)*cstr(j)
          fb1 = dts*da(j,n)*dxur(i-1)*dxtr(i)*cstr(j)*cstr(j)
          fb2 = 1.0 - fa2 - fc2 - fb1 - fb3
c
c         closed N/S bdys:
c
          if (j .eq. 2) fb2 = fb2 + fa2
          if (j .eq. jmtm1) fb2 = fb2 + fc2
c
c         Store the relevant coefficients
c         and their row/col indices in am, ia, ja respect.
c
c         main block diagonal
          itmp = indexgrid(i,j)        ! row and col index of b2
          index = index + 1
          slapam(index,lf,n) = fb2     ! diagonal of block and matrix
          slapia(index,lf,n) = itmp
          slapja(index,lf,n) = itmp
c
          if (i .gt. 2) then           ! first sub diagonal
            index = index + 1
            slapam(index,lf,n) = fb1
            slapia(index,lf,n) = itmp
            slapja(index,lf,n) = itmp-1
          else 
            if (i .eq. 2) then         ! cyclic domain i-1 maps to nx 
              index = index + 1
              slapam(index,lf,n) = fb1
              slapia(index,lf,n) = itmp
              slapja(index,lf,n) = indexgrid(imtm1,j)
            endif
          endif
c
          if (i .lt. imtm1) then       ! first super diagonal
            index = index + 1
            slapam(index,lf,n) = fb3
            slapia(index,lf,n) = itmp
            slapja(index,lf,n) = itmp+1
          else 
            if (i .eq. imtm1) then     ! cyclic domain nx+1 maps to 1 
              index = index + 1
              slapam(index,lf,n) = fb3
              slapia(index,lf,n) = itmp
              slapja(index,lf,n) = indexgrid(2,j)
            endif
          endif
c
c         block sub-diagonal
          if (j .gt. 2) then           ! element in sub-diagonal block
            index = index + 1
            slapam(index,lf,n) = fa2   ! diagonal element (of block)
            slapia(index,lf,n) = itmp
            slapja(index,lf,n) = indexgrid(i,j-1)
          endif
c
c         block super-diagonal
          if (j .lt. jmtm1) then       ! element in sub-diagonal block
            index = index + 1
            slapam(index,lf,n) = fc2   ! diagonal element (of block)
            slapia(index,lf,n) = itmp
            slapja(index,lf,n) = indexgrid(i,j+1)
          endif
c
        enddo
      enddo
c
      nelt = index

c
      return
      end
      subroutine set_time_switches
c
c=======================================================================
c
c               S E T   T I M E   S W I T C H E S

c     Subroutine set_time_switches sets switches in "switch.h"
c     that trigger periodically recurring events in the model
c     such as diagnostics and end-of-run.
c
c     Currently implemented switches include end-of-day, end-of-
c     week, end-of-two-weeks, end-of-month, end-of-year, end-of-
c     run, mid-month, and switches active at prespecified intervals
c     from either start of run, initial conditions, or any other
c     reference time the user chooses.  It is relatively
c     easy to add additional switches by following the models of
c     switches already provided.
c
c     input:
c
c       a switch.h file with all switch intervals in units of days.
c
c     outputs:
c
c       a whole collection of useful logical switches in the
c       switch.h file.
c
c     authors: c. h. goldberg        chg@gfdl.gov
c              d. j. goldberg
c           
c=======================================================================
c
      logical alarm, avg_alarm, timeless, timeequal
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c

c====================== include file "switch.h" ========================
c
c     all time dependent decisions are made by time manager "tmngr.F"
c     and communicated elsewhere to the model via logical switches.
c
c     inputs: (defaulted in "blkdta.F", optionally reset via namelist)
c
c
c     runlen  = integration period (see rununits). note "runlen" should
c               be an integral number of density time steps. if not,
c               then "runlen" is automatically adjusted to insure this.
c               fractional days are supported but not fractional months
c               or years.
c     rununits= units of "runlen". may be "days", "months", or "years".
c               tmngr will convert "runlen" which is in "rununits"
c               to "rundays" in units of days.
c
c     segtim  = the integration time "runlen" is broken into a number of
c               segments each of length "segtim" days. updated surface
c               boundary conditions are applied to MOM every "segtim" 
c               days. this is useful when coupling to atmospheric models
c               in which case both models exchange surface boundary
c               conditions every "segtim" days where "segtim"
c               is 1/(coupling frequency). without an atmospheric model,
c               when getting surface boundary conditions from data, 
c               "segtim" is set to the time step (in days) by mom.F. in
c               either case, "runlen" (in days) should be an integral
c               number of "segtim".     
c
c     nmix    = number of time steps between mixing timesteps. used
c               to damp timestep splitting due to centered leapfrog.
c
c     init    = (true,false)  indicates that this run is a
c               (start from initial conditions, restart)
c
c     restrt  = (true,false) = (do,don`t) write a restart at the end
c               of the run
c
c     eb      = (true,false) configures for the use of a 
c               (euler backward,forward) type mixing timestep
c
c-----------------------------------------------------------------------
c     inputs to tmngr.F: diagnostic intervals
c-----------------------------------------------------------------------
c
c     note: switches are used to control the interval between doing
c           diagnostics. units for all switches are in days. 
c           setting a switch < 0.0 disables whatever the switch is 
c           controlling. setting it = 0.0 causes the diagnostic to be 
c           done every time step, and setting it > 0.0 causes the 
c           diagnostic to be done repeatedly on the specified interval. 
c
c     cmixint = number of days between writing estimated mixing coeffs
c               on faces of T cells and U cells
c
c     crossint = number of days between writing diapycnal and isopycnal
c               components of flow
c
c     fctint = number of days between writing difference between 
c              FCT and leapfrog advection
c
c     densityint = number of days between writing density
c
c     exconvint = number of days between writing temperature rate of
c                 change due to explicit convection
c
c     glenint =  number of days between global energetics integrals.
c
c     trmbint =  number of days between momentum and tracer term
c                balances (global and regional).
c
c     itrmb   = (true,false) = (do,don`t) write regional mask info for
c               the term balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     gyreint =  number of days between calculation of tracer northward
c                transport.
c     igyre   = (true,false) = (do,don`t) write regional mask info for
c               the gyre diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     vmsfint =  number of days between calculation of vertical and
c                meridional stream function.
c
c     tyzint  =  number of days between calculation of zonally averaged
c                tracer components.
c
c     prxzint =  number of days between printouts of x-z data.
c
c     extint  =  number of days between printouts of external mode.
c
c     dspint  =  number of days between surface pressure calculation.
c                Note: only when "diagnostic_surface_height" is enabled.
c     dspper  = averaging period for "diagnostic_surface_height"
c
c     tavgint = number of days between regional tracer averages (under
c               horizontal regions).
c
c     itavg   = (true,false) = (do,don`t) write regional mask info for
c               the tracer average diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     tmbint  = number of days over which tracer equation in averaged
c               in depth and longitude to determine the meridional 
c               balance among storage, divergence, dissipation and 
c               forcing.
c     tmbper  = averaging period for "meridional_tracer_balance"
c
c     itmb    = (true,false) = (do,don`t) write "msktmb" for tracer
c               the meridional balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c
c     tsiint  = number of days between printing of time step integrals.
c
c     stabint = number of days between sampling for various stability
c               criteria.
c
c     snapint = number of days between writing instantaneous samples
c               of data from the MOM grid. note: only when "snapshots"
c               is enabled. see "iounit.h" for more details.
c               all data is at time level "tau" so it is one time step
c               before the date shown in "stamp".
c
c     timavgint= interval (days) for writing time mean data from
c               the "averaging" grid (only when "time_averages" is
c               enabled). if "timavgint" is not an integral number of
c               density time steps,"timavgint" is automatically adjusted
c               to insure this. if the number of days to integrate is
c               not an integral number of "timavgint" then the last
c               averaging period will be less than "timavgint" days.this 
c               may lead to one more averaging period than expected. 
c               see "iounit.h" for more details.
c     timavgper= averaging period for "time_averages"
c
c     xbtint  = averaging period (days) for writing XBT data (only when
c               "xbts" is enabled). if "xbtint" is not an integral
c               number of density time steps, "xbtint" is automatically
c               adjusted to insure this. if the number of days to 
c               integrate is not an integral number of "xbtint" then the
c               last averaging period will be less than "xbtint" days.
c               this may lead to one more averaging period than  
c               expected. see "iounit.h" for more details.
c     xbtper  = averaging period for "xbts"
c
c     zmbcint = number of days between calculation of zonal mean
c               surface boundary conditions (and related  quantities)
c
c     trajint = number of days between writing particle trajectories.
c               particle trajectories are always written on the last
c               time step of the run to allow for restarting.
c
c-----------------------------------------------------------------------
c     outputs from tmngr.F: logical switches
c-----------------------------------------------------------------------
c
c     rundays = integration time in days (from "runlen")
c
c     the following are logical counterparts to the above switches are 
c     set within "tmngr" every time step. logical switches control all
c     decisions about when to do things in MOM.
c
c     cmixts  = (false,true) = (don`t, do) do write estimated mixing
c               coefficients on this time step.
c               based on "cmixint".
c
c     crossts  = (false,true) = (don`t, do) write diapycnal and 
c               isopycnal components of flow on this time step.
c               based on "crossint".
c
c     fctts    = (false,true) = (don`t, do) write difference between 
c               FCT and leapfrog advection on this time step.
c               based on "fctint".
c
c     densityts  = (false,true) = (don`t, do) write density on this time
c               step. based on "densityint".
c               
c
c     exconvts  = (false,true) = (don`t, do) do write temperature change
c               due to explicit convection on this time step.
c               based on "exconvint".
c
c     glents  = (false,true) = (don`t, do) do calculation of global
c               energy integrals on this time step. based on "glenint".
c
c     trmbts  = (false,true) = (don`t, do) do calculation of momentum &
c               tracer term balance on this timestep. based on "trmbint"
c
c     gyrets  = (false,true) = (don`t, do) do calculation of tracer
c               northward transport on this timestep. based on "gyreint"
c
c     vmsfts  = (false,true) = (don`t, do) do calculation of vertical
c               and meridional stream function on this time step.
c               based on "vmsfint"
c
c     tyzts   = (false,true) = (don`t, do) do calculation of zonally
c               averaged tracer components on this time step.
c               based on "tyzint"
c
c     prxzts  = (false,true) = (don`t, do) do printouts of x-z data
c               on this time step. based on "prxzint"
c
c     extts  = (false,true) = (don`t, do) do printout of external mode
c               on this time step. based on "extint"
c
c     dspts  = (false,true) = (don`t, do) do calculation of diagnostic 
c              surface pressure on this time step. based on "dspint"
c               
c
c     stabts  = (false,true) = (don`t, do) test for stability on this
c               time step. based on "stabint"
c
c     tavgts  = (false,true) = (don`t do) do tracer averages on this
c               time step. based on "tavgint"
c
c     tmbts   = (false,true) = (don`t, do) write out tracer meridional .
c               balance on this time step. based on "tmbint"
c
c     tsits   = (false,true) = (don`t, do) print time step integrals
c               on this time step. based on "tsiint"
c
c     zmbcts  = (false,true) = (don`t, do) print zonal mean boundary
c               conditions on this time step.  based on "zmbcint"
c
c     trajts  = (false,true) = (don`t, do) print particle trajectories
c               on this time step. based on "trajint"
c
c     snapts  = (false,true) = (don`t, do) save a snapshot of the data
c               on this time step. based on "snapint"
c
c     timats  = (false,true) = (don`t, do) write time mean data
c               on this time step. based on "timavgint"
c                                          
c     xbtts   = (false,true) = (don`t, do) write averaged XBT data on
c               this time step based on "xbtint"
c
c
c     leapfrog= (false,true) on a (mixing, normal leapfrog) time step
c                based on "nmix"
c                                          
c     euler1  = true on the 1st pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     euler2  = true on the 2nd pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     forward = true on a forward time step. otherwise false
c		(applies when "eb" = false)		  
c                                          
c
c     the following logical switches are based on the model time step. 
c    
c     first   = (true,false) =  when it`s (the first, not the first)
c                               time step of a run
c     eots    = end of a time step. always true except for first
c               pass of an euler backward time step
c     eorun   = last time step of a run. always false except during the
c               last time step of the run.
c
c     eoday   = true when within 1/2 time step of the end of a day
c               else ... false
c     eoweek  = true when within 1/2 time step of the end of a 7 day
c               week (referenced to the start of a year) else ...false
c     eo2wks  = true when within 1/2 time step of the end of two weeks
c               (referenced to the start of a year) else ... false
c     midmon  = true when within 1/2 time step of the middle of a month
c               else ... false
c     eomon   = true when within 1/2 time step of the end of a month
c               else ... false
c     eoyear  = true when within 1/2 time step of the end of a year
c               else ... false
c     osegs   = true on the 1st time step of an ocean segment in mom.F
c               otherwise false.
c     osege  =  true on the last time step of an ocean segment in mom.F
c               otherwise false.
c
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c
c
      logical eb, leapfrog, euler1, euler2, forward, eots
      logical init, first, restrt
      logical itavg, itmb, itrmb, igyre
      character *8 rununits
c
      common /switcc/ rununits
      common /switcr/ runlen, rundays
      common /switci/ nmix
      common /switcl/ eb, leapfrog, euler1, euler2, forward, eots
      common /switcl/ init, first, restrt
      common /switcl/ itavg, itmb, itrmb, igyre
c
      logical          eoday, eoweek, eo2wks
      common /switci/ ieoday,ieoweek,ieo2wks
      common /switcl/  eoday, eoweek, eo2wks
c
      logical          eomon, midmon, eoyear, eorun
      common /switci/ ieomon,imidmon,ieoyear,ieorun
      common /switcl/  eomon, midmon, eoyear, eorun
c
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c     each interval switch needs three variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output (e.g,.  glenint)
c         2) a switch (logical) for the interval (e.g.,  glents )
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c         3) an index (integer)                       (e.g., iglenint)
c
c     the user must specify the interval [e.g., glenint] for diagnostic
c     output in units of days. tmngr sets the corresponding logical  
c     switch [e.g., glents] every time step. It is set to true when  
c     within half a time step of the requested interval, otherwise it is
c     false. All decisions relating to the interval [e.g., glenint]
c     are based on the logical switch [e.g., glents].
c           
c     internal time structures
c
c     The switch index [e.g., iglenint] is used to subsrcipt into  
c     internal arrays maintained by tmngr.F. The switch index is
c     allocated on the first call to function "alarm".
c     The array entry [e.g., iinterval(iglenint)] is a time index to the
c     internal representation of the interval [e.g., glenint].
c     The array entry [e.g., ialarm(iglenint)] is a time index to the
c     next time the alarm will be true.
c-----------------------------------------------------------------------
c
      logical           tavgts,    glents,    trmbts,   prxzts
      common /switcr/   tavgint,   glenint,   trmbint,  prxzint
      common /switci/  itavgint,  iglenint,  itrmbint, iprxzint
      common /switcl/   tavgts,    glents,    trmbts,   prxzts
c
      logical          extts,   trajts,   exconvts,   cmixts
      common /switcr/  extint,  trajint,  exconvint,  cmixint
      common /switci/ iextint, itrajint, iexconvint, icmixint
      common /switcl/  extts,   trajts,   exconvts,   cmixts
c
      logical          vmsfts,   gyrets,    tsits,   snapts,   fctts
      common /switcr/  vmsfint,  gyreint,   tsiint,  snapint,  fctint
      common /switci/ ivmsfint, igyreint,  itsiint, isnapint, ifctint
      common /switcl/  vmsfts,   gyrets,    tsits,   snapts,   fctts
c
      logical          tyzts
      common /switcr/  tyzint
      common /switci/ ityzint
      common /switcl/  tyzts
c
      logical          stabts,   zmbcts,   crossts,   densityts
      common /switcr/  stabint,  zmbcint,  crossint,  densityint
      common /switci/ istabint, izmbcint, icrossint, idensityint
      common /switcl/  stabts,   zmbcts,   crossts,   densityts
c
      logical          osegs,  osege
      common /switcr/          segtim
      common /switci/ iosegs, iosege
      common /switcl/  osegs,  osege
c   
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c              A N D   A V E R A G I N G   P E R I O D
c
c     each averaging period switch needs five variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output    (e.g. xbtint  )   
c         2) a switch (logical) for the interval         (e.g. xbtts   )
c         3) an averaging period (real)                  (e.g. xbtper  )   
c         4) a switch (logical) for accumulating         (e.g. xbtperts)
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switches
c
c         5) an index (integer)                         (e.g. ixbtint  )
c
c     The user must specify the interval [e.g., xbtint] for diagnostic
c     output in units of days and the averaging period [e.g., xbtper] 
c     in units of days. The averaging period may be less than or equal
c     to the interval. For example, if the interval is 30.0 days and the
c     averaging period is 5.0 days, results will be averaged over all
c     time steps within days 26, 27, 28, 29, and 30.  An averaging period
c     of 0.0 days averages over the last time step of the interval (as
c     does xbtper = dt), and an averaging period less than zero turns
c     the switches off for all time steps.  
c
c     The logical switch for writing output at the specified interval 
c     [e.g., xbtts] is set to true on the last time step of the 
c     averaging period. The logical switch for accumulating results
c     [e.g., xbtperts] is true for all time steps within the averaging
c     period, otherwise it is false. 
c
c     internal time structures
c
c     The index [e.g., ixbtint] is allocated on the first call to 
c     function "avg_alarm". The array element iperiod(ixbtint) is an
c     index to the time structure for the internal representation of 
c     "xbtper", and ilastsw(ixbtint) is the index of the switch that 
c     flags the last time step of the accumulation period.
c     Depending on use,  ilastsw(ixbtint) may either be the index
c     of another "named" switch or the index of a new switch
c     allocated on the first time step.
c     In the latter case, iinterval(ilastsw(ixbtint)) is the index of
c     the time structure where "xbtint" is stored in internal form,
c     and ialarm(ilastsw(ixbtint)) is the index of the time when an
c     accumulation period will next end.
c     The variable nextts(ixbtint) is true whenever the next
c     time step will begin the accumulation period.
c
c-----------------------------------------------------------------------
c
      logical         xbtts,     dspts,    tmbts,    timavgts
      logical         xbtperts,  dspperts, tmbperts, timavgperts
      common /switcr/ xbtint,    dspint,   tmbint,   timavgint
      common /switcr/ xbtper,    dspper,   tmbper,   timavgper
      common /switci/ixbtint,   idspint,  itmbint,  itimavgint
      common /switcl/ xbtts,     dspts,    tmbts,    timavgts
      common /switcl/ xbtperts,  dspperts, tmbperts, timavgperts
c
c-----------------------------------------------------------------------
c
c                 S W I T C H E S    B A S E D    O N    
c
c         C A L E N D A R   O R    P R E V I O U S    S W I T C H   
c
c               A N D   A V E R A G I N G    P E R I O D
c
c    
c
c     the following logical switches are based on any calendar or 
c     interval switch and an averaging period (in days). The  averaging
c     period must be less than or equal to the interval. The last
c     time step of the averaging period is at the end of the interval.
c     If the averaging period is set to zero, the averaging period
c     consists only of the last time period of the interval.  If
c     the averaging period is less than zero, these switches are always
c     false.
c
c     each averaging period switch needs four variables in common. For
c     example, if the averaging period is before the end of each month
c     then the calendar switch (eomon), and index (ieomon) are presumed
c     to exist in common and need not be added.
c     
c     Additionally, four items are needed.
c
c       1) an averaging period (real)                  (e.g.  testper  )   
c       2) a switch (logical) for accumulating results (e.g.  testperts)
c       3) a switch (logical) for the end of interval  (e.g.  testts   )
c
c     the fourth is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c       4) an index (integer)                          (e.g.  itestper )
c
c     Suppose it is required to produce averages over all time steps
c     during the last 5 days of each month. Then "testper" = 5.0 and 
c     the following will calculate the accumulating switch.
c
c      testts = avg_alarm(itestper, ihalfstep, 0, testper, iref, ieomon)
c      testperts = on(itestper)
c
c     Note the use of "ieomon" to key off the months.  The switch
c     "testts" will be true whenever "eomon" is true.
c     Also note that when an averaging switch is keyed off another
c     switch, the switch inverval argument is not used, but is 
c     retained for consistency with the form of other averaging
c     switches.
c-----------------------------------------------------------------------
c
      logical           testperts
      logical           testts
      common /switcr/   testint
      common /switcr/   testper
      common /switci/  itestper
      common /switcl/   testts
      common /switcl/   testperts

c
      parameter (maxsw=100)
      logical          on, lastts, nextts
      common /switci/  nsw  
      common /switci/  ialarm(maxsw), iinterval(maxsw), iperiod(maxsw)
     &,                ilastsw(maxsw)
      common /switcl/  on(maxsw), lastts(maxsw), nextts(maxsw)
c
c======================= include file "calendar.h"======================
c
c                       calendar specification arrays
c
c-----------------------------------------------------------------------
c
c     eqyear = true to select a calendar in which each year
c              has the same number of days (i.e., no leap years)
c              false selects a julian calendar
c
c     eqmon  = true to force all months to have the same number of days
c              false => the usual 31, 28, 31, 30, ..., days per month. 
c              only used when eqyear = true 
c
c     dayname = character names of days
c
c     monname = character names of months
c
c     monlen = the length of each month (in days) when eqmon is true
c
c     yrlen  = the length of a typical (non-leap) year in days
c
c     daypm  = array of month lengths in days   (non-leap)
c
c     msum   = array of cumulative days preceding each month
c              (again, non-leap)
c
c-----------------------------------------------------------------------
      logical eqyear, eqmon
      integer daypm, msum, yrlen, monlen
c
      character*10 dayname
      character*12 monname
c
      common /calenc/ dayname(7), monname(12)
      common /calenl/ eqyear, eqmon
      common /caleni/ daypm(12), msum(12), yrlen, monlen


c
c=======================================================================
c     set all time dependent logical switches (except "first")
c=======================================================================
c
c-----------------------------------------------------------------------
c
c      C A L E N D A R     A N D      C L O C K     S W I T C H E S
c
c      here are some examples of setting logicals based on the calendar
c      and clock. "dayoyr" is time in days since the start of a year.
c
c      alarms go off when current time + dt/2 is later then the alarm
c      time.  arguments of alarm routine:
c            1) index to the alarm setting time
c            2) index to the model time+dt/2
c            3) interval of the alarm in real days
c            4) index to the reference time
c-----------------------------------------------------------------------
c
c-----------------------------------------------------------------------
c     is it within 1/2 time step of the end of the day ?
c-----------------------------------------------------------------------
c
      eoday = alarm (ieoday, ihalfstep, 1.0, isunday)
c
c-----------------------------------------------------------------------
c     is it within 1/2 time step of the end of the week ?
c-----------------------------------------------------------------------
c
      eoweek = alarm (ieoweek, ihalfstep, 7.0, isunday)
c
c-----------------------------------------------------------------------
c     is it within 1/2 time step of the end of two weeks ?
c-----------------------------------------------------------------------
c
      eo2wks = alarm (ieo2wks, ihalfstep, 14.0, isunday)
c
c-----------------------------------------------------------------------
c     set initial alarm times in the first time step for the
c     end of month, mid month, end of year, and end of run switches.
c-----------------------------------------------------------------------
c
      if (first) then
c
c-----------------------------------------------------------------------
c       initialize end of month alarm
c-----------------------------------------------------------------------
c
        call getswitch (ieomon)
        call getfulltime (ialarm(ieomon))
        call copyfulltime (itime, ialarm(ieomon))
        month (ialarm(ieomon)) = month (ialarm(ieomon)) + 1
        if (month(ialarm(ieomon)) .gt. 12) then
          month(ialarm(ieomon)) = 1
          year (ialarm(ieomon)) = year(ialarm(ieomon)) + 1
        end if
        day   (ialarm(ieomon)) = 1
        hour  (ialarm(ieomon)) = 0
        minute(ialarm(ieomon)) = 0
        second(ialarm(ieomon)) = 0
        call expandtime (ialarm(ieomon))
c
        call gettime (iinterval(ieomon))
        shortest_mon = daypm(1)
        do i=2,12
          if (daypm(i) .lt. shortest_mon) shortest_mon = daypm(i)
        end do
        call settime3 (iinterval(ieomon), shortest_mon)
c
c-----------------------------------------------------------------------
c       initialize mid month alarm
c-----------------------------------------------------------------------
c
        call getswitch (imidmon)
        call getfulltime (ialarm(imidmon))
        call copyfulltime (itime, ialarm(imidmon))
        day   (ialarm(imidmon)) = daysinmon(ialarm(imidmon))/2 + 1
        hour  (ialarm(imidmon)) = 12*modulo(daysinmon(ialarm(imidmon))
     &                            ,2)
        minute(ialarm(imidmon)) = 0
        second(ialarm(imidmon)) = 0
        call expandtime (ialarm(imidmon))
        if (timeless (ialarm(imidmon), itime)) then
          month (ialarm(imidmon)) = month(ialarm(imidmon)) + 1
          if (month(ialarm(imidmon)) .gt. 12) then
            month(ialarm(imidmon)) = 1
            year (ialarm(imidmon)) = year(ialarm(imidmon)) + 1
          end if
          day   (ialarm(imidmon)) = daysinmon(ialarm(imidmon))/2 + 1
          hour  (ialarm(imidmon)) = 12*modulo(daysinmon(ialarm(imidmon))
     &                              ,2)
          minute(ialarm(imidmon)) = 0
          second(ialarm(imidmon)) = 0
          call expandtime (ialarm(imidmon))
        end if
c
        call gettime (iinterval(imidmon))
        call settime3 (iinterval(imidmon), shortest_mon)
c
c-----------------------------------------------------------------------
c       initialize end of year alarm
c-----------------------------------------------------------------------
c
        call getswitch (ieoyear)
        call getfulltime (ialarm(ieoyear))
        call copyfulltime (itime, ialarm(ieoyear))
        year  (ialarm(ieoyear)) = year(ialarm(ieoyear)) + 1
        month (ialarm(ieoyear)) = 1
        day   (ialarm(ieoyear)) = 1
        hour  (ialarm(ieoyear)) = 0
        minute(ialarm(ieoyear)) = 0
        second(ialarm(ieoyear)) = 0
        call expandtime (ialarm(ieoyear))
c
        call gettime (iinterval(ieoyear))
        call settime3 (iinterval(ieoyear), real(yrlen))
c
      end if
c
c-----------------------------------------------------------------------
c     is it within 1/2 time step of the end of the month ?
c-----------------------------------------------------------------------
c
      eomon = timeless (ialarm(ieomon), ihalfstep)
      on(ieomon) = eomon
      if (eomon) then
        iday(ialarm(ieomon)) = iday(ialarm(ieomon)) + 
     &                         daysinmon(ialarm(ieomon))
        call expandtime2 (ialarm(ieomon))
      end if
c
c-----------------------------------------------------------------------
c     is it within 1/2 time step of the middle of the month ?
c-----------------------------------------------------------------------
c
      midmon = timeless (ialarm(imidmon), ihalfstep)
      on(imidmon) = midmon
      if (midmon) then
        day(ialarm(imidmon)) = 1
        month(ialarm(imidmon)) = month(ialarm(imidmon)) + 1
        if (month(ialarm(imidmon)) .gt. 12) then
          month(ialarm(imidmon)) = 1
          year(ialarm(imidmon))  = year(ialarm(imidmon)) + 1
        end if
        call expandtime (ialarm(imidmon))
        day   (ialarm(imidmon)) = daysinmon(ialarm(imidmon))/2 + 1
        hour  (ialarm(imidmon)) = 12*modulo(daysinmon(ialarm(imidmon))
     &                            , 2)
        minute(ialarm(imidmon)) = 0
        second(ialarm(imidmon)) = 0
        call expandtime (ialarm(imidmon))
      end if
c
c-----------------------------------------------------------------------
c     is it within 1/2 time step of the end of the year ?
c-----------------------------------------------------------------------
c
      eoyear = timeless (ialarm(ieoyear), ihalfstep)
      on(ieoyear) = eoyear
      if (eoyear) then
        iday(ialarm(ieoyear)) = iday(ialarm(ieoyear)) + 
     &                          daysinyear(ialarm(ieoyear))
        call expandtime2 (ialarm(ieoyear))
      endif
c
c-----------------------------------------------------------------------
c     is it the last time step of the run ?
c-----------------------------------------------------------------------
c
      eorun = timeless (ialarm(ieorun), ihalfstep)
      on(ieorun) = eorun
c
c-----------------------------------------------------------------------
c     is time mixing to be done now ?
c-----------------------------------------------------------------------
c
      if (nmix .eq. 0 .or. nmix .eq. 1) then
        leapfrog = .true.
      else
        if (mod(itt,nmix) .eq. 1) then
          leapfrog = .false.
        else
          leapfrog = .true.
        endif
      endif
c
c-----------------------------------------------------------------------
c     is it the first time step of an ocean segment?
c     is it the last time step of an ocean segment?
c-----------------------------------------------------------------------
c
      if (first) then
        osegs = .true.
        call getswitch (iosegs)
        call gettime (iinterval(iosegs))
        call settime3 (iinterval(iosegs), segtim)
      else
        osegs = osege
      endif
      on(iosegs) = osegs
c
      osege = alarm (iosege, ihalfstep, segtim, irunstart)
c
c
c=======================================================================
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c     each interval switch needs three variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output (e.g,.  glenint)
c         2) a switch (logical) for the interval (e.g.,  glents )
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c         3) an index (integer)                       (e.g., iglenint)
c
c     the user must specify the interval [e.g., glenint] for diagnostic
c     output in units of days. set_time_switches sets the corresponding
c     logical switch [e.g., glents] every time step. It is set to true
c     when within half a time step of the requested interval, otherwise
c     it is false. All decisions relating to the interval [e.g., glenint]
c     are based on the logical switch [e.g., glents].
c           
c     internal time structures
c
c     The switch index [e.g., iglenint] is used to subsrcipt into  
c     internal arrays maintained by tmngr.F. The switch index is
c     allocated on the first call to function "alarm".
c     The array entry [e.g., iinterval(iglenint)] is a time index to the
c     internal representation of the interval [e.g., glenint].
c     The array entry [e.g., ialarm(iglenint)] is a time index to the
c     next time the alarm will be true.
c=======================================================================
c


c
c






c

c

c

c

c

c

c

c

c

c

c

c
c
c=======================================================================
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c              A N D   A V E R A G I N G   P E R I O D
c
c     each averaging period switch needs five variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output    (e.g. xbtint  )   
c         2) a switch (logical) for the interval         (e.g. xbtts   )
c         3) an averaging period (real)                  (e.g. xbtper  )   
c         4) a switch (logical) for accumulating         (e.g. xbtperts)
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switches
c
c         5) an index (integer)                         (e.g. ixbtint  )
c
c     The user must specify the interval [e.g., xbtint] for diagnostic
c     output in units of days and the averaging period [e.g., xbtper] 
c     in units of days. The averaging period may be less than or equal
c     to the interval. For example, if the interval is 30.0 days and the
c     averaging period is 5.0 days, results will be averaged over all
c     time steps within days 26, 27, 28, 29, and 30. 
c
c     The logical switch for writing output at the specified interval 
c     [e.g., xbtts] is set to true on the last time step of the 
c     averaging period. The logical switch for accumulating results
c     [e.g., xbtperts] is true for all time steps within the averaging
c     period, otherwise it is false. 
c
c     internal time structures
c
c     The index [e.g., ixbtint] is allocated on the first call to 
c     function "avg_alarm". The array element iperiod(ixbtint) is an
c     index to the time structure for the internal representation of 
c     "xbtper", and ilastsw(ixbtint) is the index of the switch that 
c     flags the last time step of the accumulation period.
c     Depending on use,  ilastsw(ixbtint) may either be the index
c     of another "named" switch or the index of a new switch
c     allocated on the first time step.
c     In the latter case, iinterval(ilastsw(ixbtint)) is the index of
c     the time structure where "xbtint" is stored in internal form,
c     and ialarm(ilastsw(ixbtint)) is the index of the time when an
c     accumulation period will next end.
c     The variable nextts(ixbtint) is true whenever the next
c     time step will begin the accumulation period.
c=======================================================================
c     
c

c

c

c

c
c
c=======================================================================
c
c                 S W I T C H E S    B A S E D    O N    
c
c         C A L E N D A R   O R    P R E V I O U S    S W I T C H   
c
c               A N D   A V E R A G I N G    P E R I O D
c
c    
c
c     the following logical switches are based on any calendar or 
c     interval switch and an averaging period (in days). The  averaging
c     period must be less than or equal to the interval. The last
c     time step of the averaging period is at the end of the interval.
c     If the averaging period is set to zero, the averaging period
c     consists only of the last time period of the interval.  If
c     the averaging period is less than zero, these switches are always
c     false.
c
c     each averaging period switch needs four variables in common. For
c     example, if the averaging period is before the end of each month
c     then the calendar switch (eomon), and index (ieomon) are presumed
c     to exist in common and need not be added.
c     
c     Additionally, four items are needed.
c
c       1) an averaging period (real)                  (e.g.  testper  )   
c       2) a switch (logical) for accumulating results (e.g.  testperts)
c       3) a switch (logical) for the end of interval  (e.g.  testts   )
c
c     the fourth is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c       4) an index (integer)                          (e.g.  itestper )
c
c     Suppose it is required to produce averages over all time steps
c     during the last 5 days of each month. Then "testper" = 5.0 and 
c     the following will calculate the accumulating switch.
c
c      testts = avg_alarm(itestper, ihalfstep, 0, testper, iref, ieomon)
c      testperts = on(itestper)
c
c     Note the use of "ieomon" to key off the months.  The switch
c     "testts" will be true whenever "eomon" is true.
c     Also note that when an averaging switch is keyed off another
c     switch, the switch inverval argument is not used, but is 
c     retained for consistency with the form of other averaging
c     switches.
c=======================================================================
c

c
      return
      end



      function alarm (isw, ihalf, timeint, irefer)
c
c=======================================================================
c     inputs:
c
c     isw     = index to the switch number for this switch. isw is
c               allocated on the first call to avg_alarm. 
c
c     ihalf   = index to the time one half time step ahead of current
c               time
c
c     timeint = specified time interval of interest (in days. eg: 1.0
c               day, 36 hours (1.5 days), a week (7.0 days), two weeks
c               (14.0 days), 365.0 days ... etc)
c
c     irefer  = index to the time to which the alarm is referenced
c
c     outputs:
c
c     alarm:
c       if timeint > 0 then
c         alarm = true when the current time + dt/2 is later than the
c                 alarm time.  The alarm is then incremented
c       if timeint = 0 then
c         alarm = true (i.e., do this option every step)
c       if timeint < 0 then
c         alarm = false (i.e., this option is disabled)
c
c     if first=.T. then alarm sets the initial alarm time
c
c
c     output in common:
c
c     on(isw)      = true whenever alarm is true
c
c
c     internal values in common:
c     the user need not be concerned with these:
c
c     iinterval(isw) = index of time field where timeint is stored in
c                      internal form.
c
c     ialarm(isw)    = index of time when alarm will next be true
c
c     authors: c.h.goldberg          chg@gfdl.gov
c              d.j.goldberg
c
c=======================================================================
c
      logical alarm, timeless
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c

c====================== include file "switch.h" ========================
c
c     all time dependent decisions are made by time manager "tmngr.F"
c     and communicated elsewhere to the model via logical switches.
c
c     inputs: (defaulted in "blkdta.F", optionally reset via namelist)
c
c
c     runlen  = integration period (see rununits). note "runlen" should
c               be an integral number of density time steps. if not,
c               then "runlen" is automatically adjusted to insure this.
c               fractional days are supported but not fractional months
c               or years.
c     rununits= units of "runlen". may be "days", "months", or "years".
c               tmngr will convert "runlen" which is in "rununits"
c               to "rundays" in units of days.
c
c     segtim  = the integration time "runlen" is broken into a number of
c               segments each of length "segtim" days. updated surface
c               boundary conditions are applied to MOM every "segtim" 
c               days. this is useful when coupling to atmospheric models
c               in which case both models exchange surface boundary
c               conditions every "segtim" days where "segtim"
c               is 1/(coupling frequency). without an atmospheric model,
c               when getting surface boundary conditions from data, 
c               "segtim" is set to the time step (in days) by mom.F. in
c               either case, "runlen" (in days) should be an integral
c               number of "segtim".     
c
c     nmix    = number of time steps between mixing timesteps. used
c               to damp timestep splitting due to centered leapfrog.
c
c     init    = (true,false)  indicates that this run is a
c               (start from initial conditions, restart)
c
c     restrt  = (true,false) = (do,don`t) write a restart at the end
c               of the run
c
c     eb      = (true,false) configures for the use of a 
c               (euler backward,forward) type mixing timestep
c
c-----------------------------------------------------------------------
c     inputs to tmngr.F: diagnostic intervals
c-----------------------------------------------------------------------
c
c     note: switches are used to control the interval between doing
c           diagnostics. units for all switches are in days. 
c           setting a switch < 0.0 disables whatever the switch is 
c           controlling. setting it = 0.0 causes the diagnostic to be 
c           done every time step, and setting it > 0.0 causes the 
c           diagnostic to be done repeatedly on the specified interval. 
c
c     cmixint = number of days between writing estimated mixing coeffs
c               on faces of T cells and U cells
c
c     crossint = number of days between writing diapycnal and isopycnal
c               components of flow
c
c     fctint = number of days between writing difference between 
c              FCT and leapfrog advection
c
c     densityint = number of days between writing density
c
c     exconvint = number of days between writing temperature rate of
c                 change due to explicit convection
c
c     glenint =  number of days between global energetics integrals.
c
c     trmbint =  number of days between momentum and tracer term
c                balances (global and regional).
c
c     itrmb   = (true,false) = (do,don`t) write regional mask info for
c               the term balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     gyreint =  number of days between calculation of tracer northward
c                transport.
c     igyre   = (true,false) = (do,don`t) write regional mask info for
c               the gyre diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     vmsfint =  number of days between calculation of vertical and
c                meridional stream function.
c
c     tyzint  =  number of days between calculation of zonally averaged
c                tracer components.
c
c     prxzint =  number of days between printouts of x-z data.
c
c     extint  =  number of days between printouts of external mode.
c
c     dspint  =  number of days between surface pressure calculation.
c                Note: only when "diagnostic_surface_height" is enabled.
c     dspper  = averaging period for "diagnostic_surface_height"
c
c     tavgint = number of days between regional tracer averages (under
c               horizontal regions).
c
c     itavg   = (true,false) = (do,don`t) write regional mask info for
c               the tracer average diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     tmbint  = number of days over which tracer equation in averaged
c               in depth and longitude to determine the meridional 
c               balance among storage, divergence, dissipation and 
c               forcing.
c     tmbper  = averaging period for "meridional_tracer_balance"
c
c     itmb    = (true,false) = (do,don`t) write "msktmb" for tracer
c               the meridional balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c
c     tsiint  = number of days between printing of time step integrals.
c
c     stabint = number of days between sampling for various stability
c               criteria.
c
c     snapint = number of days between writing instantaneous samples
c               of data from the MOM grid. note: only when "snapshots"
c               is enabled. see "iounit.h" for more details.
c               all data is at time level "tau" so it is one time step
c               before the date shown in "stamp".
c
c     timavgint= interval (days) for writing time mean data from
c               the "averaging" grid (only when "time_averages" is
c               enabled). if "timavgint" is not an integral number of
c               density time steps,"timavgint" is automatically adjusted
c               to insure this. if the number of days to integrate is
c               not an integral number of "timavgint" then the last
c               averaging period will be less than "timavgint" days.this 
c               may lead to one more averaging period than expected. 
c               see "iounit.h" for more details.
c     timavgper= averaging period for "time_averages"
c
c     xbtint  = averaging period (days) for writing XBT data (only when
c               "xbts" is enabled). if "xbtint" is not an integral
c               number of density time steps, "xbtint" is automatically
c               adjusted to insure this. if the number of days to 
c               integrate is not an integral number of "xbtint" then the
c               last averaging period will be less than "xbtint" days.
c               this may lead to one more averaging period than  
c               expected. see "iounit.h" for more details.
c     xbtper  = averaging period for "xbts"
c
c     zmbcint = number of days between calculation of zonal mean
c               surface boundary conditions (and related  quantities)
c
c     trajint = number of days between writing particle trajectories.
c               particle trajectories are always written on the last
c               time step of the run to allow for restarting.
c
c-----------------------------------------------------------------------
c     outputs from tmngr.F: logical switches
c-----------------------------------------------------------------------
c
c     rundays = integration time in days (from "runlen")
c
c     the following are logical counterparts to the above switches are 
c     set within "tmngr" every time step. logical switches control all
c     decisions about when to do things in MOM.
c
c     cmixts  = (false,true) = (don`t, do) do write estimated mixing
c               coefficients on this time step.
c               based on "cmixint".
c
c     crossts  = (false,true) = (don`t, do) write diapycnal and 
c               isopycnal components of flow on this time step.
c               based on "crossint".
c
c     fctts    = (false,true) = (don`t, do) write difference between 
c               FCT and leapfrog advection on this time step.
c               based on "fctint".
c
c     densityts  = (false,true) = (don`t, do) write density on this time
c               step. based on "densityint".
c               
c
c     exconvts  = (false,true) = (don`t, do) do write temperature change
c               due to explicit convection on this time step.
c               based on "exconvint".
c
c     glents  = (false,true) = (don`t, do) do calculation of global
c               energy integrals on this time step. based on "glenint".
c
c     trmbts  = (false,true) = (don`t, do) do calculation of momentum &
c               tracer term balance on this timestep. based on "trmbint"
c
c     gyrets  = (false,true) = (don`t, do) do calculation of tracer
c               northward transport on this timestep. based on "gyreint"
c
c     vmsfts  = (false,true) = (don`t, do) do calculation of vertical
c               and meridional stream function on this time step.
c               based on "vmsfint"
c
c     tyzts   = (false,true) = (don`t, do) do calculation of zonally
c               averaged tracer components on this time step.
c               based on "tyzint"
c
c     prxzts  = (false,true) = (don`t, do) do printouts of x-z data
c               on this time step. based on "prxzint"
c
c     extts  = (false,true) = (don`t, do) do printout of external mode
c               on this time step. based on "extint"
c
c     dspts  = (false,true) = (don`t, do) do calculation of diagnostic 
c              surface pressure on this time step. based on "dspint"
c               
c
c     stabts  = (false,true) = (don`t, do) test for stability on this
c               time step. based on "stabint"
c
c     tavgts  = (false,true) = (don`t do) do tracer averages on this
c               time step. based on "tavgint"
c
c     tmbts   = (false,true) = (don`t, do) write out tracer meridional .
c               balance on this time step. based on "tmbint"
c
c     tsits   = (false,true) = (don`t, do) print time step integrals
c               on this time step. based on "tsiint"
c
c     zmbcts  = (false,true) = (don`t, do) print zonal mean boundary
c               conditions on this time step.  based on "zmbcint"
c
c     trajts  = (false,true) = (don`t, do) print particle trajectories
c               on this time step. based on "trajint"
c
c     snapts  = (false,true) = (don`t, do) save a snapshot of the data
c               on this time step. based on "snapint"
c
c     timats  = (false,true) = (don`t, do) write time mean data
c               on this time step. based on "timavgint"
c                                          
c     xbtts   = (false,true) = (don`t, do) write averaged XBT data on
c               this time step based on "xbtint"
c
c
c     leapfrog= (false,true) on a (mixing, normal leapfrog) time step
c                based on "nmix"
c                                          
c     euler1  = true on the 1st pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     euler2  = true on the 2nd pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     forward = true on a forward time step. otherwise false
c		(applies when "eb" = false)		  
c                                          
c
c     the following logical switches are based on the model time step. 
c    
c     first   = (true,false) =  when it`s (the first, not the first)
c                               time step of a run
c     eots    = end of a time step. always true except for first
c               pass of an euler backward time step
c     eorun   = last time step of a run. always false except during the
c               last time step of the run.
c
c     eoday   = true when within 1/2 time step of the end of a day
c               else ... false
c     eoweek  = true when within 1/2 time step of the end of a 7 day
c               week (referenced to the start of a year) else ...false
c     eo2wks  = true when within 1/2 time step of the end of two weeks
c               (referenced to the start of a year) else ... false
c     midmon  = true when within 1/2 time step of the middle of a month
c               else ... false
c     eomon   = true when within 1/2 time step of the end of a month
c               else ... false
c     eoyear  = true when within 1/2 time step of the end of a year
c               else ... false
c     osegs   = true on the 1st time step of an ocean segment in mom.F
c               otherwise false.
c     osege  =  true on the last time step of an ocean segment in mom.F
c               otherwise false.
c
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c
c
      logical eb, leapfrog, euler1, euler2, forward, eots
      logical init, first, restrt
      logical itavg, itmb, itrmb, igyre
      character *8 rununits
c
      common /switcc/ rununits
      common /switcr/ runlen, rundays
      common /switci/ nmix
      common /switcl/ eb, leapfrog, euler1, euler2, forward, eots
      common /switcl/ init, first, restrt
      common /switcl/ itavg, itmb, itrmb, igyre
c
      logical          eoday, eoweek, eo2wks
      common /switci/ ieoday,ieoweek,ieo2wks
      common /switcl/  eoday, eoweek, eo2wks
c
      logical          eomon, midmon, eoyear, eorun
      common /switci/ ieomon,imidmon,ieoyear,ieorun
      common /switcl/  eomon, midmon, eoyear, eorun
c
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c     each interval switch needs three variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output (e.g,.  glenint)
c         2) a switch (logical) for the interval (e.g.,  glents )
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c         3) an index (integer)                       (e.g., iglenint)
c
c     the user must specify the interval [e.g., glenint] for diagnostic
c     output in units of days. tmngr sets the corresponding logical  
c     switch [e.g., glents] every time step. It is set to true when  
c     within half a time step of the requested interval, otherwise it is
c     false. All decisions relating to the interval [e.g., glenint]
c     are based on the logical switch [e.g., glents].
c           
c     internal time structures
c
c     The switch index [e.g., iglenint] is used to subsrcipt into  
c     internal arrays maintained by tmngr.F. The switch index is
c     allocated on the first call to function "alarm".
c     The array entry [e.g., iinterval(iglenint)] is a time index to the
c     internal representation of the interval [e.g., glenint].
c     The array entry [e.g., ialarm(iglenint)] is a time index to the
c     next time the alarm will be true.
c-----------------------------------------------------------------------
c
      logical           tavgts,    glents,    trmbts,   prxzts
      common /switcr/   tavgint,   glenint,   trmbint,  prxzint
      common /switci/  itavgint,  iglenint,  itrmbint, iprxzint
      common /switcl/   tavgts,    glents,    trmbts,   prxzts
c
      logical          extts,   trajts,   exconvts,   cmixts
      common /switcr/  extint,  trajint,  exconvint,  cmixint
      common /switci/ iextint, itrajint, iexconvint, icmixint
      common /switcl/  extts,   trajts,   exconvts,   cmixts
c
      logical          vmsfts,   gyrets,    tsits,   snapts,   fctts
      common /switcr/  vmsfint,  gyreint,   tsiint,  snapint,  fctint
      common /switci/ ivmsfint, igyreint,  itsiint, isnapint, ifctint
      common /switcl/  vmsfts,   gyrets,    tsits,   snapts,   fctts
c
      logical          tyzts
      common /switcr/  tyzint
      common /switci/ ityzint
      common /switcl/  tyzts
c
      logical          stabts,   zmbcts,   crossts,   densityts
      common /switcr/  stabint,  zmbcint,  crossint,  densityint
      common /switci/ istabint, izmbcint, icrossint, idensityint
      common /switcl/  stabts,   zmbcts,   crossts,   densityts
c
      logical          osegs,  osege
      common /switcr/          segtim
      common /switci/ iosegs, iosege
      common /switcl/  osegs,  osege
c   
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c              A N D   A V E R A G I N G   P E R I O D
c
c     each averaging period switch needs five variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output    (e.g. xbtint  )   
c         2) a switch (logical) for the interval         (e.g. xbtts   )
c         3) an averaging period (real)                  (e.g. xbtper  )   
c         4) a switch (logical) for accumulating         (e.g. xbtperts)
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switches
c
c         5) an index (integer)                         (e.g. ixbtint  )
c
c     The user must specify the interval [e.g., xbtint] for diagnostic
c     output in units of days and the averaging period [e.g., xbtper] 
c     in units of days. The averaging period may be less than or equal
c     to the interval. For example, if the interval is 30.0 days and the
c     averaging period is 5.0 days, results will be averaged over all
c     time steps within days 26, 27, 28, 29, and 30.  An averaging period
c     of 0.0 days averages over the last time step of the interval (as
c     does xbtper = dt), and an averaging period less than zero turns
c     the switches off for all time steps.  
c
c     The logical switch for writing output at the specified interval 
c     [e.g., xbtts] is set to true on the last time step of the 
c     averaging period. The logical switch for accumulating results
c     [e.g., xbtperts] is true for all time steps within the averaging
c     period, otherwise it is false. 
c
c     internal time structures
c
c     The index [e.g., ixbtint] is allocated on the first call to 
c     function "avg_alarm". The array element iperiod(ixbtint) is an
c     index to the time structure for the internal representation of 
c     "xbtper", and ilastsw(ixbtint) is the index of the switch that 
c     flags the last time step of the accumulation period.
c     Depending on use,  ilastsw(ixbtint) may either be the index
c     of another "named" switch or the index of a new switch
c     allocated on the first time step.
c     In the latter case, iinterval(ilastsw(ixbtint)) is the index of
c     the time structure where "xbtint" is stored in internal form,
c     and ialarm(ilastsw(ixbtint)) is the index of the time when an
c     accumulation period will next end.
c     The variable nextts(ixbtint) is true whenever the next
c     time step will begin the accumulation period.
c
c-----------------------------------------------------------------------
c
      logical         xbtts,     dspts,    tmbts,    timavgts
      logical         xbtperts,  dspperts, tmbperts, timavgperts
      common /switcr/ xbtint,    dspint,   tmbint,   timavgint
      common /switcr/ xbtper,    dspper,   tmbper,   timavgper
      common /switci/ixbtint,   idspint,  itmbint,  itimavgint
      common /switcl/ xbtts,     dspts,    tmbts,    timavgts
      common /switcl/ xbtperts,  dspperts, tmbperts, timavgperts
c
c-----------------------------------------------------------------------
c
c                 S W I T C H E S    B A S E D    O N    
c
c         C A L E N D A R   O R    P R E V I O U S    S W I T C H   
c
c               A N D   A V E R A G I N G    P E R I O D
c
c    
c
c     the following logical switches are based on any calendar or 
c     interval switch and an averaging period (in days). The  averaging
c     period must be less than or equal to the interval. The last
c     time step of the averaging period is at the end of the interval.
c     If the averaging period is set to zero, the averaging period
c     consists only of the last time period of the interval.  If
c     the averaging period is less than zero, these switches are always
c     false.
c
c     each averaging period switch needs four variables in common. For
c     example, if the averaging period is before the end of each month
c     then the calendar switch (eomon), and index (ieomon) are presumed
c     to exist in common and need not be added.
c     
c     Additionally, four items are needed.
c
c       1) an averaging period (real)                  (e.g.  testper  )   
c       2) a switch (logical) for accumulating results (e.g.  testperts)
c       3) a switch (logical) for the end of interval  (e.g.  testts   )
c
c     the fourth is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c       4) an index (integer)                          (e.g.  itestper )
c
c     Suppose it is required to produce averages over all time steps
c     during the last 5 days of each month. Then "testper" = 5.0 and 
c     the following will calculate the accumulating switch.
c
c      testts = avg_alarm(itestper, ihalfstep, 0, testper, iref, ieomon)
c      testperts = on(itestper)
c
c     Note the use of "ieomon" to key off the months.  The switch
c     "testts" will be true whenever "eomon" is true.
c     Also note that when an averaging switch is keyed off another
c     switch, the switch inverval argument is not used, but is 
c     retained for consistency with the form of other averaging
c     switches.
c-----------------------------------------------------------------------
c
      logical           testperts
      logical           testts
      common /switcr/   testint
      common /switcr/   testper
      common /switci/  itestper
      common /switcl/   testts
      common /switcl/   testperts

c
      parameter (maxsw=100)
      logical          on, lastts, nextts
      common /switci/  nsw  
      common /switci/  ialarm(maxsw), iinterval(maxsw), iperiod(maxsw)
     &,                ilastsw(maxsw)
      common /switcl/  on(maxsw), lastts(maxsw), nextts(maxsw)
c
c
      logical ltemp
c
      if (first) then
c
c-----------------------------------------------------------------------
c       initialize the alarm on first iteration
c-----------------------------------------------------------------------
c
        call getswitch (isw)
        call gettime (ialarm(isw))
        call gettime (iinterval(isw))
        call settime3 (iinterval(isw), timeint)
c
        if (timeint .gt. 0.0) then
          if (timeless (irunstart, irefer)) then
c
c-----------------------------------------------------------------------
c           if reference time is later than run start time then the
c           initial alarm is set to reference time.  (No alarms will
c           go off until the time reaches the reference time.)
c-----------------------------------------------------------------------
c
            call copytime (irefer, ialarm(isw))
          else
c
c-----------------------------------------------------------------------
c           set alarm to first time of the form:  reftime + i * timeint
c           that is at least dt/2 after runstart.
c-----------------------------------------------------------------------
c
            call subtime (irunstart, irefer, ireftime)
            call addtime (ireftime, idtd2, ireftime)
            realintervals = realdays(ireftime)/timeint
c
c-----------------------------------------------------------------------
c           i = least integer greater than realintervals (ceiling)
c-----------------------------------------------------------------------
c
            i = int(realintervals) + 1
            i = i - int(i - realintervals)
            call multime (i, iinterval(isw), ialarm(isw))
            call addtime (ialarm(isw), irefer, ialarm(isw))
          end if
        else 
          call addtime (itime, idt, ialarm(isw))
        end if
      end if 
c
c-----------------------------------------------------------------------
c     check alarm
c-----------------------------------------------------------------------
c
      if (timeint .gt. 0.0) then
        ltemp = timeless (ialarm(isw), ihalf)
        if (ltemp) then
c
c-----------------------------------------------------------------------
c         increment the alarm time
c-----------------------------------------------------------------------
c
 100      continue
          call addtime (ialarm(isw), iinterval(isw), ialarm(isw))
          if (timeless (ialarm(isw), ihalf)) goto 100
        endif
      elseif (timeint .lt. 0.0) then
        ltemp = .false.
        call addtime (itime, idt, ialarm(isw))
      else
        ltemp = .true.
        call addtime (itime, idt, ialarm(isw))
      end if
      alarm = ltemp
      on(isw) = ltemp
c
      return
      end
c
c
c
c
      function avg_alarm(isw, ihalf, swinterval, period, irefer
     &,                    ilastswitch)
c
c
c=======================================================================
c     inputs:
c
c     isw     = index to the switch number for this switch. isw is
c               allocated on the first call to avg_alarm. 
c
c     ihalf   = index to the time one half time step ahead of current
c               time
c
c     swinterval = specified time interval of the switch (in days.
c               eg: 1.0 day, 36 hours (1.5 days), a week (7.0 days),
c               two weeks (14.0 days), 365.0 days ... etc)
c
c     period = period of the averaging or accumulation part of the
c                interval (in days).
c                It is permissible for period and interval to be equal,
c                in which case, the logical on(isw) is always true, and
c                the logical lastts(isw) and the function value are
c                true become true once every interval days.
c
c     irefer  = index to the time to which the alarm is referenced
c
c     ilastswitch = index of switch which signals the last timestep of
c                   the interval.  If ilastswitch = 0, then a new,
c                   unnamed switch is allocated which turns on every
c                   interval days after the reference time.  If
c                   ilastswitch is nonzero, the argument interval is
c                   ignored and the "named" switch indexed by
c                   ilastswitch is used to signal the last time step
c                   of the interval.  Note that ilastswitch need not
c                   be a simple interval switch; it may be a calendar
c                   switch such as imidmon (mid month) or ieoyear
c                   (end of year).
c
c
c     outputs:
c
c     avg_alarm = true only on the last time step of the interval.
c
c     isw       = index to switch is allocated on first time step
c
c
c     outputs in common:
c
c     on(isw)      = true whenever current time step is within accumula-
c                    tion part of the interval.
c
c     lastts(isw)  = true only on last time step of interval.
c                    The alarm is then incremented
c
c
c     internal values in common:
c     the user need not be concerned with these:
c
c     nextts(isw)  = true when next time step will be first of interval.
c                    (i.e., on the time step nearest to period days
c                    before lastts(isw) will be true.)
c
c     iperiod(isw) = index of time field where length of the averaging
c                    period is stored in internal form.
c
c     ilastsw(isw) = index of switch which signals the last time step
c                    of the interval.  if ilastsw(isw) is a "named"
c                    switch, be sure to update it before isw is updated
c                    in the subroutine set_time_switches.
c
c
c     authors: c.h.goldberg          chg@gfdl.gov
c              d.j.goldberg
c
c=======================================================================
c
      logical avg_alarm, timeless, alarm, named_lastswitch
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c

c====================== include file "switch.h" ========================
c
c     all time dependent decisions are made by time manager "tmngr.F"
c     and communicated elsewhere to the model via logical switches.
c
c     inputs: (defaulted in "blkdta.F", optionally reset via namelist)
c
c
c     runlen  = integration period (see rununits). note "runlen" should
c               be an integral number of density time steps. if not,
c               then "runlen" is automatically adjusted to insure this.
c               fractional days are supported but not fractional months
c               or years.
c     rununits= units of "runlen". may be "days", "months", or "years".
c               tmngr will convert "runlen" which is in "rununits"
c               to "rundays" in units of days.
c
c     segtim  = the integration time "runlen" is broken into a number of
c               segments each of length "segtim" days. updated surface
c               boundary conditions are applied to MOM every "segtim" 
c               days. this is useful when coupling to atmospheric models
c               in which case both models exchange surface boundary
c               conditions every "segtim" days where "segtim"
c               is 1/(coupling frequency). without an atmospheric model,
c               when getting surface boundary conditions from data, 
c               "segtim" is set to the time step (in days) by mom.F. in
c               either case, "runlen" (in days) should be an integral
c               number of "segtim".     
c
c     nmix    = number of time steps between mixing timesteps. used
c               to damp timestep splitting due to centered leapfrog.
c
c     init    = (true,false)  indicates that this run is a
c               (start from initial conditions, restart)
c
c     restrt  = (true,false) = (do,don`t) write a restart at the end
c               of the run
c
c     eb      = (true,false) configures for the use of a 
c               (euler backward,forward) type mixing timestep
c
c-----------------------------------------------------------------------
c     inputs to tmngr.F: diagnostic intervals
c-----------------------------------------------------------------------
c
c     note: switches are used to control the interval between doing
c           diagnostics. units for all switches are in days. 
c           setting a switch < 0.0 disables whatever the switch is 
c           controlling. setting it = 0.0 causes the diagnostic to be 
c           done every time step, and setting it > 0.0 causes the 
c           diagnostic to be done repeatedly on the specified interval. 
c
c     cmixint = number of days between writing estimated mixing coeffs
c               on faces of T cells and U cells
c
c     crossint = number of days between writing diapycnal and isopycnal
c               components of flow
c
c     fctint = number of days between writing difference between 
c              FCT and leapfrog advection
c
c     densityint = number of days between writing density
c
c     exconvint = number of days between writing temperature rate of
c                 change due to explicit convection
c
c     glenint =  number of days between global energetics integrals.
c
c     trmbint =  number of days between momentum and tracer term
c                balances (global and regional).
c
c     itrmb   = (true,false) = (do,don`t) write regional mask info for
c               the term balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     gyreint =  number of days between calculation of tracer northward
c                transport.
c     igyre   = (true,false) = (do,don`t) write regional mask info for
c               the gyre diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     vmsfint =  number of days between calculation of vertical and
c                meridional stream function.
c
c     tyzint  =  number of days between calculation of zonally averaged
c                tracer components.
c
c     prxzint =  number of days between printouts of x-z data.
c
c     extint  =  number of days between printouts of external mode.
c
c     dspint  =  number of days between surface pressure calculation.
c                Note: only when "diagnostic_surface_height" is enabled.
c     dspper  = averaging period for "diagnostic_surface_height"
c
c     tavgint = number of days between regional tracer averages (under
c               horizontal regions).
c
c     itavg   = (true,false) = (do,don`t) write regional mask info for
c               the tracer average diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     tmbint  = number of days over which tracer equation in averaged
c               in depth and longitude to determine the meridional 
c               balance among storage, divergence, dissipation and 
c               forcing.
c     tmbper  = averaging period for "meridional_tracer_balance"
c
c     itmb    = (true,false) = (do,don`t) write "msktmb" for tracer
c               the meridional balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c
c     tsiint  = number of days between printing of time step integrals.
c
c     stabint = number of days between sampling for various stability
c               criteria.
c
c     snapint = number of days between writing instantaneous samples
c               of data from the MOM grid. note: only when "snapshots"
c               is enabled. see "iounit.h" for more details.
c               all data is at time level "tau" so it is one time step
c               before the date shown in "stamp".
c
c     timavgint= interval (days) for writing time mean data from
c               the "averaging" grid (only when "time_averages" is
c               enabled). if "timavgint" is not an integral number of
c               density time steps,"timavgint" is automatically adjusted
c               to insure this. if the number of days to integrate is
c               not an integral number of "timavgint" then the last
c               averaging period will be less than "timavgint" days.this 
c               may lead to one more averaging period than expected. 
c               see "iounit.h" for more details.
c     timavgper= averaging period for "time_averages"
c
c     xbtint  = averaging period (days) for writing XBT data (only when
c               "xbts" is enabled). if "xbtint" is not an integral
c               number of density time steps, "xbtint" is automatically
c               adjusted to insure this. if the number of days to 
c               integrate is not an integral number of "xbtint" then the
c               last averaging period will be less than "xbtint" days.
c               this may lead to one more averaging period than  
c               expected. see "iounit.h" for more details.
c     xbtper  = averaging period for "xbts"
c
c     zmbcint = number of days between calculation of zonal mean
c               surface boundary conditions (and related  quantities)
c
c     trajint = number of days between writing particle trajectories.
c               particle trajectories are always written on the last
c               time step of the run to allow for restarting.
c
c-----------------------------------------------------------------------
c     outputs from tmngr.F: logical switches
c-----------------------------------------------------------------------
c
c     rundays = integration time in days (from "runlen")
c
c     the following are logical counterparts to the above switches are 
c     set within "tmngr" every time step. logical switches control all
c     decisions about when to do things in MOM.
c
c     cmixts  = (false,true) = (don`t, do) do write estimated mixing
c               coefficients on this time step.
c               based on "cmixint".
c
c     crossts  = (false,true) = (don`t, do) write diapycnal and 
c               isopycnal components of flow on this time step.
c               based on "crossint".
c
c     fctts    = (false,true) = (don`t, do) write difference between 
c               FCT and leapfrog advection on this time step.
c               based on "fctint".
c
c     densityts  = (false,true) = (don`t, do) write density on this time
c               step. based on "densityint".
c               
c
c     exconvts  = (false,true) = (don`t, do) do write temperature change
c               due to explicit convection on this time step.
c               based on "exconvint".
c
c     glents  = (false,true) = (don`t, do) do calculation of global
c               energy integrals on this time step. based on "glenint".
c
c     trmbts  = (false,true) = (don`t, do) do calculation of momentum &
c               tracer term balance on this timestep. based on "trmbint"
c
c     gyrets  = (false,true) = (don`t, do) do calculation of tracer
c               northward transport on this timestep. based on "gyreint"
c
c     vmsfts  = (false,true) = (don`t, do) do calculation of vertical
c               and meridional stream function on this time step.
c               based on "vmsfint"
c
c     tyzts   = (false,true) = (don`t, do) do calculation of zonally
c               averaged tracer components on this time step.
c               based on "tyzint"
c
c     prxzts  = (false,true) = (don`t, do) do printouts of x-z data
c               on this time step. based on "prxzint"
c
c     extts  = (false,true) = (don`t, do) do printout of external mode
c               on this time step. based on "extint"
c
c     dspts  = (false,true) = (don`t, do) do calculation of diagnostic 
c              surface pressure on this time step. based on "dspint"
c               
c
c     stabts  = (false,true) = (don`t, do) test for stability on this
c               time step. based on "stabint"
c
c     tavgts  = (false,true) = (don`t do) do tracer averages on this
c               time step. based on "tavgint"
c
c     tmbts   = (false,true) = (don`t, do) write out tracer meridional .
c               balance on this time step. based on "tmbint"
c
c     tsits   = (false,true) = (don`t, do) print time step integrals
c               on this time step. based on "tsiint"
c
c     zmbcts  = (false,true) = (don`t, do) print zonal mean boundary
c               conditions on this time step.  based on "zmbcint"
c
c     trajts  = (false,true) = (don`t, do) print particle trajectories
c               on this time step. based on "trajint"
c
c     snapts  = (false,true) = (don`t, do) save a snapshot of the data
c               on this time step. based on "snapint"
c
c     timats  = (false,true) = (don`t, do) write time mean data
c               on this time step. based on "timavgint"
c                                          
c     xbtts   = (false,true) = (don`t, do) write averaged XBT data on
c               this time step based on "xbtint"
c
c
c     leapfrog= (false,true) on a (mixing, normal leapfrog) time step
c                based on "nmix"
c                                          
c     euler1  = true on the 1st pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     euler2  = true on the 2nd pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     forward = true on a forward time step. otherwise false
c		(applies when "eb" = false)		  
c                                          
c
c     the following logical switches are based on the model time step. 
c    
c     first   = (true,false) =  when it`s (the first, not the first)
c                               time step of a run
c     eots    = end of a time step. always true except for first
c               pass of an euler backward time step
c     eorun   = last time step of a run. always false except during the
c               last time step of the run.
c
c     eoday   = true when within 1/2 time step of the end of a day
c               else ... false
c     eoweek  = true when within 1/2 time step of the end of a 7 day
c               week (referenced to the start of a year) else ...false
c     eo2wks  = true when within 1/2 time step of the end of two weeks
c               (referenced to the start of a year) else ... false
c     midmon  = true when within 1/2 time step of the middle of a month
c               else ... false
c     eomon   = true when within 1/2 time step of the end of a month
c               else ... false
c     eoyear  = true when within 1/2 time step of the end of a year
c               else ... false
c     osegs   = true on the 1st time step of an ocean segment in mom.F
c               otherwise false.
c     osege  =  true on the last time step of an ocean segment in mom.F
c               otherwise false.
c
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c
c
      logical eb, leapfrog, euler1, euler2, forward, eots
      logical init, first, restrt
      logical itavg, itmb, itrmb, igyre
      character *8 rununits
c
      common /switcc/ rununits
      common /switcr/ runlen, rundays
      common /switci/ nmix
      common /switcl/ eb, leapfrog, euler1, euler2, forward, eots
      common /switcl/ init, first, restrt
      common /switcl/ itavg, itmb, itrmb, igyre
c
      logical          eoday, eoweek, eo2wks
      common /switci/ ieoday,ieoweek,ieo2wks
      common /switcl/  eoday, eoweek, eo2wks
c
      logical          eomon, midmon, eoyear, eorun
      common /switci/ ieomon,imidmon,ieoyear,ieorun
      common /switcl/  eomon, midmon, eoyear, eorun
c
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c     each interval switch needs three variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output (e.g,.  glenint)
c         2) a switch (logical) for the interval (e.g.,  glents )
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c         3) an index (integer)                       (e.g., iglenint)
c
c     the user must specify the interval [e.g., glenint] for diagnostic
c     output in units of days. tmngr sets the corresponding logical  
c     switch [e.g., glents] every time step. It is set to true when  
c     within half a time step of the requested interval, otherwise it is
c     false. All decisions relating to the interval [e.g., glenint]
c     are based on the logical switch [e.g., glents].
c           
c     internal time structures
c
c     The switch index [e.g., iglenint] is used to subsrcipt into  
c     internal arrays maintained by tmngr.F. The switch index is
c     allocated on the first call to function "alarm".
c     The array entry [e.g., iinterval(iglenint)] is a time index to the
c     internal representation of the interval [e.g., glenint].
c     The array entry [e.g., ialarm(iglenint)] is a time index to the
c     next time the alarm will be true.
c-----------------------------------------------------------------------
c
      logical           tavgts,    glents,    trmbts,   prxzts
      common /switcr/   tavgint,   glenint,   trmbint,  prxzint
      common /switci/  itavgint,  iglenint,  itrmbint, iprxzint
      common /switcl/   tavgts,    glents,    trmbts,   prxzts
c
      logical          extts,   trajts,   exconvts,   cmixts
      common /switcr/  extint,  trajint,  exconvint,  cmixint
      common /switci/ iextint, itrajint, iexconvint, icmixint
      common /switcl/  extts,   trajts,   exconvts,   cmixts
c
      logical          vmsfts,   gyrets,    tsits,   snapts,   fctts
      common /switcr/  vmsfint,  gyreint,   tsiint,  snapint,  fctint
      common /switci/ ivmsfint, igyreint,  itsiint, isnapint, ifctint
      common /switcl/  vmsfts,   gyrets,    tsits,   snapts,   fctts
c
      logical          tyzts
      common /switcr/  tyzint
      common /switci/ ityzint
      common /switcl/  tyzts
c
      logical          stabts,   zmbcts,   crossts,   densityts
      common /switcr/  stabint,  zmbcint,  crossint,  densityint
      common /switci/ istabint, izmbcint, icrossint, idensityint
      common /switcl/  stabts,   zmbcts,   crossts,   densityts
c
      logical          osegs,  osege
      common /switcr/          segtim
      common /switci/ iosegs, iosege
      common /switcl/  osegs,  osege
c   
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c              A N D   A V E R A G I N G   P E R I O D
c
c     each averaging period switch needs five variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output    (e.g. xbtint  )   
c         2) a switch (logical) for the interval         (e.g. xbtts   )
c         3) an averaging period (real)                  (e.g. xbtper  )   
c         4) a switch (logical) for accumulating         (e.g. xbtperts)
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switches
c
c         5) an index (integer)                         (e.g. ixbtint  )
c
c     The user must specify the interval [e.g., xbtint] for diagnostic
c     output in units of days and the averaging period [e.g., xbtper] 
c     in units of days. The averaging period may be less than or equal
c     to the interval. For example, if the interval is 30.0 days and the
c     averaging period is 5.0 days, results will be averaged over all
c     time steps within days 26, 27, 28, 29, and 30.  An averaging period
c     of 0.0 days averages over the last time step of the interval (as
c     does xbtper = dt), and an averaging period less than zero turns
c     the switches off for all time steps.  
c
c     The logical switch for writing output at the specified interval 
c     [e.g., xbtts] is set to true on the last time step of the 
c     averaging period. The logical switch for accumulating results
c     [e.g., xbtperts] is true for all time steps within the averaging
c     period, otherwise it is false. 
c
c     internal time structures
c
c     The index [e.g., ixbtint] is allocated on the first call to 
c     function "avg_alarm". The array element iperiod(ixbtint) is an
c     index to the time structure for the internal representation of 
c     "xbtper", and ilastsw(ixbtint) is the index of the switch that 
c     flags the last time step of the accumulation period.
c     Depending on use,  ilastsw(ixbtint) may either be the index
c     of another "named" switch or the index of a new switch
c     allocated on the first time step.
c     In the latter case, iinterval(ilastsw(ixbtint)) is the index of
c     the time structure where "xbtint" is stored in internal form,
c     and ialarm(ilastsw(ixbtint)) is the index of the time when an
c     accumulation period will next end.
c     The variable nextts(ixbtint) is true whenever the next
c     time step will begin the accumulation period.
c
c-----------------------------------------------------------------------
c
      logical         xbtts,     dspts,    tmbts,    timavgts
      logical         xbtperts,  dspperts, tmbperts, timavgperts
      common /switcr/ xbtint,    dspint,   tmbint,   timavgint
      common /switcr/ xbtper,    dspper,   tmbper,   timavgper
      common /switci/ixbtint,   idspint,  itmbint,  itimavgint
      common /switcl/ xbtts,     dspts,    tmbts,    timavgts
      common /switcl/ xbtperts,  dspperts, tmbperts, timavgperts
c
c-----------------------------------------------------------------------
c
c                 S W I T C H E S    B A S E D    O N    
c
c         C A L E N D A R   O R    P R E V I O U S    S W I T C H   
c
c               A N D   A V E R A G I N G    P E R I O D
c
c    
c
c     the following logical switches are based on any calendar or 
c     interval switch and an averaging period (in days). The  averaging
c     period must be less than or equal to the interval. The last
c     time step of the averaging period is at the end of the interval.
c     If the averaging period is set to zero, the averaging period
c     consists only of the last time period of the interval.  If
c     the averaging period is less than zero, these switches are always
c     false.
c
c     each averaging period switch needs four variables in common. For
c     example, if the averaging period is before the end of each month
c     then the calendar switch (eomon), and index (ieomon) are presumed
c     to exist in common and need not be added.
c     
c     Additionally, four items are needed.
c
c       1) an averaging period (real)                  (e.g.  testper  )   
c       2) a switch (logical) for accumulating results (e.g.  testperts)
c       3) a switch (logical) for the end of interval  (e.g.  testts   )
c
c     the fourth is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c       4) an index (integer)                          (e.g.  itestper )
c
c     Suppose it is required to produce averages over all time steps
c     during the last 5 days of each month. Then "testper" = 5.0 and 
c     the following will calculate the accumulating switch.
c
c      testts = avg_alarm(itestper, ihalfstep, 0, testper, iref, ieomon)
c      testperts = on(itestper)
c
c     Note the use of "ieomon" to key off the months.  The switch
c     "testts" will be true whenever "eomon" is true.
c     Also note that when an averaging switch is keyed off another
c     switch, the switch inverval argument is not used, but is 
c     retained for consistency with the form of other averaging
c     switches.
c-----------------------------------------------------------------------
c
      logical           testperts
      logical           testts
      common /switcr/   testint
      common /switcr/   testper
      common /switci/  itestper
      common /switcl/   testts
      common /switcl/   testperts

c
      parameter (maxsw=100)
      logical          on, lastts, nextts
      common /switci/  nsw  
      common /switci/  ialarm(maxsw), iinterval(maxsw), iperiod(maxsw)
     &,                ilastsw(maxsw)
      common /switcl/  on(maxsw), lastts(maxsw), nextts(maxsw)
c
c
      named_lastswitch = (ilastswitch .ne. 0)
c
      if (first) then
c
c-----------------------------------------------------------------------
c       allocate a new switch
c-----------------------------------------------------------------------
c
        call getswitch(isw)
c
c-----------------------------------------------------------------------
c       check for invalid user input
c-----------------------------------------------------------------------
c
        if (named_lastswitch) then
          ilastsw(isw) = ilastswitch
          swinterval = realdays(iinterval(ilastswitch))
        end if
        if (period .gt. swinterval) then
          print *, 'ERROR: switch period exceeds its interval'
          print *, '       period = ',period
          print *, '       interval = ',swinterval
          stop '==>avgalarm'
        end if
c
c-----------------------------------------------------------------------
c       initialize internal switch variables
c-----------------------------------------------------------------------
c
        call gettime (iperiod(isw))
        call settime3 (iperiod(isw), period)
c
c        if (period .le. 0) then
c          call copytime (idt, iperiod(isw))
c        end if
c
c-----------------------------------------------------------------------
c       initialize switches lastts and nextts
c-----------------------------------------------------------------------
c
        if (named_lastswitch) then
          lastts(isw) = on(ilastsw(isw))
        else
          call getswitch(ilastsw(isw))
          lastts(isw) = alarm (ilastsw(isw), ihalf, swinterval, irefer)
        end if
c
        call subtime (ialarm(ilastsw(isw)), iperiod(isw), itmptime)
        call subtime (ihalf, idt, itmptime2)
        nextts(isw) = timeless (itmptime2, itmptime) .and.
     &                timeless (itmptime, ihalf)
c
c-----------------------------------------------------------------------
c       set on(isw) only if start of averaging interval is within a half
c       time step of runstart.
c-----------------------------------------------------------------------
c
        call subtime (itmptime2, idt, itmptime3)
        on(isw) = timeless (itmptime3, itmptime) .and.
     &            timeless (itmptime, itmptime2)       
c
c-----------------------------------------------------------------------
c       turn lastts(isw) off if on(isw) is false
c-----------------------------------------------------------------------
c
        lastts(isw) = lastts(isw) .and. on(isw)
c
c-----------------------------------------------------------------------
c
      else
c
c-----------------------------------------------------------------------
c       this is not the first time step.
c       reset on(isw) based on events in previous call to increment_time
c-----------------------------------------------------------------------
c
        if (lastts(isw)) on(isw) = .false.
        if (nextts(isw)) on(isw) = .true.
c
c-----------------------------------------------------------------------
c       set lastts based on current call to increment_time.
c       end of run turns lastts(isw) on; however lastts(isw) must
c       never be true unless on(isw) is also true.
c-----------------------------------------------------------------------
c
        if (named_lastswitch) then
          lastts(isw) = on(ilastsw(isw))
        else
          lastts(isw) = alarm (ilastsw(isw), ihalf, swinterval, irefer)
        end if
        lastts(isw) = lastts(isw) .or. eorun
        lastts(isw) = lastts(isw) .and. on(isw)
c
c-----------------------------------------------------------------------
c       set nextts based on current call to increment_time.
c       these tests must follow the setting of lastts so that in the
c       case that the averaging period is equal to the entire interval,
c       the alarm setting for lastts will already be pushed ahead.
c
c       a period of 0 really means average over one time step.
c-----------------------------------------------------------------------
c
        call subtime (ialarm(ilastsw(isw)), iperiod(isw), itmptime)
        if (period .eq. 0) then
          call subtime (itmptime, idt, itmptime)
        end if
        call subtime (ihalf, idt, itmptime2)
        nextts(isw) = timeless (itmptime2, itmptime) .and.
     &                timeless (itmptime, ihalf)
c
      end if
c
      avg_alarm = lastts(isw)
c
      return
      end


      subroutine getswitch (isw)
c====================== include file "switch.h" ========================
c
c     all time dependent decisions are made by time manager "tmngr.F"
c     and communicated elsewhere to the model via logical switches.
c
c     inputs: (defaulted in "blkdta.F", optionally reset via namelist)
c
c
c     runlen  = integration period (see rununits). note "runlen" should
c               be an integral number of density time steps. if not,
c               then "runlen" is automatically adjusted to insure this.
c               fractional days are supported but not fractional months
c               or years.
c     rununits= units of "runlen". may be "days", "months", or "years".
c               tmngr will convert "runlen" which is in "rununits"
c               to "rundays" in units of days.
c
c     segtim  = the integration time "runlen" is broken into a number of
c               segments each of length "segtim" days. updated surface
c               boundary conditions are applied to MOM every "segtim" 
c               days. this is useful when coupling to atmospheric models
c               in which case both models exchange surface boundary
c               conditions every "segtim" days where "segtim"
c               is 1/(coupling frequency). without an atmospheric model,
c               when getting surface boundary conditions from data, 
c               "segtim" is set to the time step (in days) by mom.F. in
c               either case, "runlen" (in days) should be an integral
c               number of "segtim".     
c
c     nmix    = number of time steps between mixing timesteps. used
c               to damp timestep splitting due to centered leapfrog.
c
c     init    = (true,false)  indicates that this run is a
c               (start from initial conditions, restart)
c
c     restrt  = (true,false) = (do,don`t) write a restart at the end
c               of the run
c
c     eb      = (true,false) configures for the use of a 
c               (euler backward,forward) type mixing timestep
c
c-----------------------------------------------------------------------
c     inputs to tmngr.F: diagnostic intervals
c-----------------------------------------------------------------------
c
c     note: switches are used to control the interval between doing
c           diagnostics. units for all switches are in days. 
c           setting a switch < 0.0 disables whatever the switch is 
c           controlling. setting it = 0.0 causes the diagnostic to be 
c           done every time step, and setting it > 0.0 causes the 
c           diagnostic to be done repeatedly on the specified interval. 
c
c     cmixint = number of days between writing estimated mixing coeffs
c               on faces of T cells and U cells
c
c     crossint = number of days between writing diapycnal and isopycnal
c               components of flow
c
c     fctint = number of days between writing difference between 
c              FCT and leapfrog advection
c
c     densityint = number of days between writing density
c
c     exconvint = number of days between writing temperature rate of
c                 change due to explicit convection
c
c     glenint =  number of days between global energetics integrals.
c
c     trmbint =  number of days between momentum and tracer term
c                balances (global and regional).
c
c     itrmb   = (true,false) = (do,don`t) write regional mask info for
c               the term balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     gyreint =  number of days between calculation of tracer northward
c                transport.
c     igyre   = (true,false) = (do,don`t) write regional mask info for
c               the gyre diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     vmsfint =  number of days between calculation of vertical and
c                meridional stream function.
c
c     tyzint  =  number of days between calculation of zonally averaged
c                tracer components.
c
c     prxzint =  number of days between printouts of x-z data.
c
c     extint  =  number of days between printouts of external mode.
c
c     dspint  =  number of days between surface pressure calculation.
c                Note: only when "diagnostic_surface_height" is enabled.
c     dspper  = averaging period for "diagnostic_surface_height"
c
c     tavgint = number of days between regional tracer averages (under
c               horizontal regions).
c
c     itavg   = (true,false) = (do,don`t) write regional mask info for
c               the tracer average diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     tmbint  = number of days over which tracer equation in averaged
c               in depth and longitude to determine the meridional 
c               balance among storage, divergence, dissipation and 
c               forcing.
c     tmbper  = averaging period for "meridional_tracer_balance"
c
c     itmb    = (true,false) = (do,don`t) write "msktmb" for tracer
c               the meridional balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c
c     tsiint  = number of days between printing of time step integrals.
c
c     stabint = number of days between sampling for various stability
c               criteria.
c
c     snapint = number of days between writing instantaneous samples
c               of data from the MOM grid. note: only when "snapshots"
c               is enabled. see "iounit.h" for more details.
c               all data is at time level "tau" so it is one time step
c               before the date shown in "stamp".
c
c     timavgint= interval (days) for writing time mean data from
c               the "averaging" grid (only when "time_averages" is
c               enabled). if "timavgint" is not an integral number of
c               density time steps,"timavgint" is automatically adjusted
c               to insure this. if the number of days to integrate is
c               not an integral number of "timavgint" then the last
c               averaging period will be less than "timavgint" days.this 
c               may lead to one more averaging period than expected. 
c               see "iounit.h" for more details.
c     timavgper= averaging period for "time_averages"
c
c     xbtint  = averaging period (days) for writing XBT data (only when
c               "xbts" is enabled). if "xbtint" is not an integral
c               number of density time steps, "xbtint" is automatically
c               adjusted to insure this. if the number of days to 
c               integrate is not an integral number of "xbtint" then the
c               last averaging period will be less than "xbtint" days.
c               this may lead to one more averaging period than  
c               expected. see "iounit.h" for more details.
c     xbtper  = averaging period for "xbts"
c
c     zmbcint = number of days between calculation of zonal mean
c               surface boundary conditions (and related  quantities)
c
c     trajint = number of days between writing particle trajectories.
c               particle trajectories are always written on the last
c               time step of the run to allow for restarting.
c
c-----------------------------------------------------------------------
c     outputs from tmngr.F: logical switches
c-----------------------------------------------------------------------
c
c     rundays = integration time in days (from "runlen")
c
c     the following are logical counterparts to the above switches are 
c     set within "tmngr" every time step. logical switches control all
c     decisions about when to do things in MOM.
c
c     cmixts  = (false,true) = (don`t, do) do write estimated mixing
c               coefficients on this time step.
c               based on "cmixint".
c
c     crossts  = (false,true) = (don`t, do) write diapycnal and 
c               isopycnal components of flow on this time step.
c               based on "crossint".
c
c     fctts    = (false,true) = (don`t, do) write difference between 
c               FCT and leapfrog advection on this time step.
c               based on "fctint".
c
c     densityts  = (false,true) = (don`t, do) write density on this time
c               step. based on "densityint".
c               
c
c     exconvts  = (false,true) = (don`t, do) do write temperature change
c               due to explicit convection on this time step.
c               based on "exconvint".
c
c     glents  = (false,true) = (don`t, do) do calculation of global
c               energy integrals on this time step. based on "glenint".
c
c     trmbts  = (false,true) = (don`t, do) do calculation of momentum &
c               tracer term balance on this timestep. based on "trmbint"
c
c     gyrets  = (false,true) = (don`t, do) do calculation of tracer
c               northward transport on this timestep. based on "gyreint"
c
c     vmsfts  = (false,true) = (don`t, do) do calculation of vertical
c               and meridional stream function on this time step.
c               based on "vmsfint"
c
c     tyzts   = (false,true) = (don`t, do) do calculation of zonally
c               averaged tracer components on this time step.
c               based on "tyzint"
c
c     prxzts  = (false,true) = (don`t, do) do printouts of x-z data
c               on this time step. based on "prxzint"
c
c     extts  = (false,true) = (don`t, do) do printout of external mode
c               on this time step. based on "extint"
c
c     dspts  = (false,true) = (don`t, do) do calculation of diagnostic 
c              surface pressure on this time step. based on "dspint"
c               
c
c     stabts  = (false,true) = (don`t, do) test for stability on this
c               time step. based on "stabint"
c
c     tavgts  = (false,true) = (don`t do) do tracer averages on this
c               time step. based on "tavgint"
c
c     tmbts   = (false,true) = (don`t, do) write out tracer meridional .
c               balance on this time step. based on "tmbint"
c
c     tsits   = (false,true) = (don`t, do) print time step integrals
c               on this time step. based on "tsiint"
c
c     zmbcts  = (false,true) = (don`t, do) print zonal mean boundary
c               conditions on this time step.  based on "zmbcint"
c
c     trajts  = (false,true) = (don`t, do) print particle trajectories
c               on this time step. based on "trajint"
c
c     snapts  = (false,true) = (don`t, do) save a snapshot of the data
c               on this time step. based on "snapint"
c
c     timats  = (false,true) = (don`t, do) write time mean data
c               on this time step. based on "timavgint"
c                                          
c     xbtts   = (false,true) = (don`t, do) write averaged XBT data on
c               this time step based on "xbtint"
c
c
c     leapfrog= (false,true) on a (mixing, normal leapfrog) time step
c                based on "nmix"
c                                          
c     euler1  = true on the 1st pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     euler2  = true on the 2nd pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     forward = true on a forward time step. otherwise false
c		(applies when "eb" = false)		  
c                                          
c
c     the following logical switches are based on the model time step. 
c    
c     first   = (true,false) =  when it`s (the first, not the first)
c                               time step of a run
c     eots    = end of a time step. always true except for first
c               pass of an euler backward time step
c     eorun   = last time step of a run. always false except during the
c               last time step of the run.
c
c     eoday   = true when within 1/2 time step of the end of a day
c               else ... false
c     eoweek  = true when within 1/2 time step of the end of a 7 day
c               week (referenced to the start of a year) else ...false
c     eo2wks  = true when within 1/2 time step of the end of two weeks
c               (referenced to the start of a year) else ... false
c     midmon  = true when within 1/2 time step of the middle of a month
c               else ... false
c     eomon   = true when within 1/2 time step of the end of a month
c               else ... false
c     eoyear  = true when within 1/2 time step of the end of a year
c               else ... false
c     osegs   = true on the 1st time step of an ocean segment in mom.F
c               otherwise false.
c     osege  =  true on the last time step of an ocean segment in mom.F
c               otherwise false.
c
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c
c
      logical eb, leapfrog, euler1, euler2, forward, eots
      logical init, first, restrt
      logical itavg, itmb, itrmb, igyre
      character *8 rununits
c
      common /switcc/ rununits
      common /switcr/ runlen, rundays
      common /switci/ nmix
      common /switcl/ eb, leapfrog, euler1, euler2, forward, eots
      common /switcl/ init, first, restrt
      common /switcl/ itavg, itmb, itrmb, igyre
c
      logical          eoday, eoweek, eo2wks
      common /switci/ ieoday,ieoweek,ieo2wks
      common /switcl/  eoday, eoweek, eo2wks
c
      logical          eomon, midmon, eoyear, eorun
      common /switci/ ieomon,imidmon,ieoyear,ieorun
      common /switcl/  eomon, midmon, eoyear, eorun
c
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c     each interval switch needs three variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output (e.g,.  glenint)
c         2) a switch (logical) for the interval (e.g.,  glents )
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c         3) an index (integer)                       (e.g., iglenint)
c
c     the user must specify the interval [e.g., glenint] for diagnostic
c     output in units of days. tmngr sets the corresponding logical  
c     switch [e.g., glents] every time step. It is set to true when  
c     within half a time step of the requested interval, otherwise it is
c     false. All decisions relating to the interval [e.g., glenint]
c     are based on the logical switch [e.g., glents].
c           
c     internal time structures
c
c     The switch index [e.g., iglenint] is used to subsrcipt into  
c     internal arrays maintained by tmngr.F. The switch index is
c     allocated on the first call to function "alarm".
c     The array entry [e.g., iinterval(iglenint)] is a time index to the
c     internal representation of the interval [e.g., glenint].
c     The array entry [e.g., ialarm(iglenint)] is a time index to the
c     next time the alarm will be true.
c-----------------------------------------------------------------------
c
      logical           tavgts,    glents,    trmbts,   prxzts
      common /switcr/   tavgint,   glenint,   trmbint,  prxzint
      common /switci/  itavgint,  iglenint,  itrmbint, iprxzint
      common /switcl/   tavgts,    glents,    trmbts,   prxzts
c
      logical          extts,   trajts,   exconvts,   cmixts
      common /switcr/  extint,  trajint,  exconvint,  cmixint
      common /switci/ iextint, itrajint, iexconvint, icmixint
      common /switcl/  extts,   trajts,   exconvts,   cmixts
c
      logical          vmsfts,   gyrets,    tsits,   snapts,   fctts
      common /switcr/  vmsfint,  gyreint,   tsiint,  snapint,  fctint
      common /switci/ ivmsfint, igyreint,  itsiint, isnapint, ifctint
      common /switcl/  vmsfts,   gyrets,    tsits,   snapts,   fctts
c
      logical          tyzts
      common /switcr/  tyzint
      common /switci/ ityzint
      common /switcl/  tyzts
c
      logical          stabts,   zmbcts,   crossts,   densityts
      common /switcr/  stabint,  zmbcint,  crossint,  densityint
      common /switci/ istabint, izmbcint, icrossint, idensityint
      common /switcl/  stabts,   zmbcts,   crossts,   densityts
c
      logical          osegs,  osege
      common /switcr/          segtim
      common /switci/ iosegs, iosege
      common /switcl/  osegs,  osege
c   
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c              A N D   A V E R A G I N G   P E R I O D
c
c     each averaging period switch needs five variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output    (e.g. xbtint  )   
c         2) a switch (logical) for the interval         (e.g. xbtts   )
c         3) an averaging period (real)                  (e.g. xbtper  )   
c         4) a switch (logical) for accumulating         (e.g. xbtperts)
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switches
c
c         5) an index (integer)                         (e.g. ixbtint  )
c
c     The user must specify the interval [e.g., xbtint] for diagnostic
c     output in units of days and the averaging period [e.g., xbtper] 
c     in units of days. The averaging period may be less than or equal
c     to the interval. For example, if the interval is 30.0 days and the
c     averaging period is 5.0 days, results will be averaged over all
c     time steps within days 26, 27, 28, 29, and 30.  An averaging period
c     of 0.0 days averages over the last time step of the interval (as
c     does xbtper = dt), and an averaging period less than zero turns
c     the switches off for all time steps.  
c
c     The logical switch for writing output at the specified interval 
c     [e.g., xbtts] is set to true on the last time step of the 
c     averaging period. The logical switch for accumulating results
c     [e.g., xbtperts] is true for all time steps within the averaging
c     period, otherwise it is false. 
c
c     internal time structures
c
c     The index [e.g., ixbtint] is allocated on the first call to 
c     function "avg_alarm". The array element iperiod(ixbtint) is an
c     index to the time structure for the internal representation of 
c     "xbtper", and ilastsw(ixbtint) is the index of the switch that 
c     flags the last time step of the accumulation period.
c     Depending on use,  ilastsw(ixbtint) may either be the index
c     of another "named" switch or the index of a new switch
c     allocated on the first time step.
c     In the latter case, iinterval(ilastsw(ixbtint)) is the index of
c     the time structure where "xbtint" is stored in internal form,
c     and ialarm(ilastsw(ixbtint)) is the index of the time when an
c     accumulation period will next end.
c     The variable nextts(ixbtint) is true whenever the next
c     time step will begin the accumulation period.
c
c-----------------------------------------------------------------------
c
      logical         xbtts,     dspts,    tmbts,    timavgts
      logical         xbtperts,  dspperts, tmbperts, timavgperts
      common /switcr/ xbtint,    dspint,   tmbint,   timavgint
      common /switcr/ xbtper,    dspper,   tmbper,   timavgper
      common /switci/ixbtint,   idspint,  itmbint,  itimavgint
      common /switcl/ xbtts,     dspts,    tmbts,    timavgts
      common /switcl/ xbtperts,  dspperts, tmbperts, timavgperts
c
c-----------------------------------------------------------------------
c
c                 S W I T C H E S    B A S E D    O N    
c
c         C A L E N D A R   O R    P R E V I O U S    S W I T C H   
c
c               A N D   A V E R A G I N G    P E R I O D
c
c    
c
c     the following logical switches are based on any calendar or 
c     interval switch and an averaging period (in days). The  averaging
c     period must be less than or equal to the interval. The last
c     time step of the averaging period is at the end of the interval.
c     If the averaging period is set to zero, the averaging period
c     consists only of the last time period of the interval.  If
c     the averaging period is less than zero, these switches are always
c     false.
c
c     each averaging period switch needs four variables in common. For
c     example, if the averaging period is before the end of each month
c     then the calendar switch (eomon), and index (ieomon) are presumed
c     to exist in common and need not be added.
c     
c     Additionally, four items are needed.
c
c       1) an averaging period (real)                  (e.g.  testper  )   
c       2) a switch (logical) for accumulating results (e.g.  testperts)
c       3) a switch (logical) for the end of interval  (e.g.  testts   )
c
c     the fourth is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c       4) an index (integer)                          (e.g.  itestper )
c
c     Suppose it is required to produce averages over all time steps
c     during the last 5 days of each month. Then "testper" = 5.0 and 
c     the following will calculate the accumulating switch.
c
c      testts = avg_alarm(itestper, ihalfstep, 0, testper, iref, ieomon)
c      testperts = on(itestper)
c
c     Note the use of "ieomon" to key off the months.  The switch
c     "testts" will be true whenever "eomon" is true.
c     Also note that when an averaging switch is keyed off another
c     switch, the switch inverval argument is not used, but is 
c     retained for consistency with the form of other averaging
c     switches.
c-----------------------------------------------------------------------
c
      logical           testperts
      logical           testts
      common /switcr/   testint
      common /switcr/   testper
      common /switci/  itestper
      common /switcl/   testts
      common /switcl/   testperts

c
      parameter (maxsw=100)
      logical          on, lastts, nextts
      common /switci/  nsw  
      common /switci/  ialarm(maxsw), iinterval(maxsw), iperiod(maxsw)
     &,                ilastsw(maxsw)
      common /switcl/  on(maxsw), lastts(maxsw), nextts(maxsw)
c
      nsw = nsw + 1
      if (nsw .gt. maxsw) then
        print *, 'ERROR:  not enough switches.'
        print *, '        increase maxsw = ',maxsw,' in switch.h'
        stop '==>getsw'
      end if
      isw = nsw
c
      return
      end



      subroutine set_eorun (runlen0, rununits0, rundays0)
c=======================================================================
c     initialize end of run alarm.
c     place dummy arguments in corresponding variables in "switch.h"
c
c     inputs:
c       runlen0   = length of run [see rununits for units]
c       rununits0 = time units ('days', 'months', or 'years' for runlen0
c     output:
c       rundays0  = length of run converted to (real) days
c
c     at present, arbitrary real run lengths in 'days' are handled.
c     run lengths in real 'months' or 'years' are rounded to the
c     nearest integral number of months or years before use.
c
c     authors: c. h. goldberg        chg@gfdl.gov
c              d. j. goldberg
c=======================================================================
c
c====================== include file "switch.h" ========================
c
c     all time dependent decisions are made by time manager "tmngr.F"
c     and communicated elsewhere to the model via logical switches.
c
c     inputs: (defaulted in "blkdta.F", optionally reset via namelist)
c
c
c     runlen  = integration period (see rununits). note "runlen" should
c               be an integral number of density time steps. if not,
c               then "runlen" is automatically adjusted to insure this.
c               fractional days are supported but not fractional months
c               or years.
c     rununits= units of "runlen". may be "days", "months", or "years".
c               tmngr will convert "runlen" which is in "rununits"
c               to "rundays" in units of days.
c
c     segtim  = the integration time "runlen" is broken into a number of
c               segments each of length "segtim" days. updated surface
c               boundary conditions are applied to MOM every "segtim" 
c               days. this is useful when coupling to atmospheric models
c               in which case both models exchange surface boundary
c               conditions every "segtim" days where "segtim"
c               is 1/(coupling frequency). without an atmospheric model,
c               when getting surface boundary conditions from data, 
c               "segtim" is set to the time step (in days) by mom.F. in
c               either case, "runlen" (in days) should be an integral
c               number of "segtim".     
c
c     nmix    = number of time steps between mixing timesteps. used
c               to damp timestep splitting due to centered leapfrog.
c
c     init    = (true,false)  indicates that this run is a
c               (start from initial conditions, restart)
c
c     restrt  = (true,false) = (do,don`t) write a restart at the end
c               of the run
c
c     eb      = (true,false) configures for the use of a 
c               (euler backward,forward) type mixing timestep
c
c-----------------------------------------------------------------------
c     inputs to tmngr.F: diagnostic intervals
c-----------------------------------------------------------------------
c
c     note: switches are used to control the interval between doing
c           diagnostics. units for all switches are in days. 
c           setting a switch < 0.0 disables whatever the switch is 
c           controlling. setting it = 0.0 causes the diagnostic to be 
c           done every time step, and setting it > 0.0 causes the 
c           diagnostic to be done repeatedly on the specified interval. 
c
c     cmixint = number of days between writing estimated mixing coeffs
c               on faces of T cells and U cells
c
c     crossint = number of days between writing diapycnal and isopycnal
c               components of flow
c
c     fctint = number of days between writing difference between 
c              FCT and leapfrog advection
c
c     densityint = number of days between writing density
c
c     exconvint = number of days between writing temperature rate of
c                 change due to explicit convection
c
c     glenint =  number of days between global energetics integrals.
c
c     trmbint =  number of days between momentum and tracer term
c                balances (global and regional).
c
c     itrmb   = (true,false) = (do,don`t) write regional mask info for
c               the term balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     gyreint =  number of days between calculation of tracer northward
c                transport.
c     igyre   = (true,false) = (do,don`t) write regional mask info for
c               the gyre diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     vmsfint =  number of days between calculation of vertical and
c                meridional stream function.
c
c     tyzint  =  number of days between calculation of zonally averaged
c                tracer components.
c
c     prxzint =  number of days between printouts of x-z data.
c
c     extint  =  number of days between printouts of external mode.
c
c     dspint  =  number of days between surface pressure calculation.
c                Note: only when "diagnostic_surface_height" is enabled.
c     dspper  = averaging period for "diagnostic_surface_height"
c
c     tavgint = number of days between regional tracer averages (under
c               horizontal regions).
c
c     itavg   = (true,false) = (do,don`t) write regional mask info for
c               the tracer average diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     tmbint  = number of days over which tracer equation in averaged
c               in depth and longitude to determine the meridional 
c               balance among storage, divergence, dissipation and 
c               forcing.
c     tmbper  = averaging period for "meridional_tracer_balance"
c
c     itmb    = (true,false) = (do,don`t) write "msktmb" for tracer
c               the meridional balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c
c     tsiint  = number of days between printing of time step integrals.
c
c     stabint = number of days between sampling for various stability
c               criteria.
c
c     snapint = number of days between writing instantaneous samples
c               of data from the MOM grid. note: only when "snapshots"
c               is enabled. see "iounit.h" for more details.
c               all data is at time level "tau" so it is one time step
c               before the date shown in "stamp".
c
c     timavgint= interval (days) for writing time mean data from
c               the "averaging" grid (only when "time_averages" is
c               enabled). if "timavgint" is not an integral number of
c               density time steps,"timavgint" is automatically adjusted
c               to insure this. if the number of days to integrate is
c               not an integral number of "timavgint" then the last
c               averaging period will be less than "timavgint" days.this 
c               may lead to one more averaging period than expected. 
c               see "iounit.h" for more details.
c     timavgper= averaging period for "time_averages"
c
c     xbtint  = averaging period (days) for writing XBT data (only when
c               "xbts" is enabled). if "xbtint" is not an integral
c               number of density time steps, "xbtint" is automatically
c               adjusted to insure this. if the number of days to 
c               integrate is not an integral number of "xbtint" then the
c               last averaging period will be less than "xbtint" days.
c               this may lead to one more averaging period than  
c               expected. see "iounit.h" for more details.
c     xbtper  = averaging period for "xbts"
c
c     zmbcint = number of days between calculation of zonal mean
c               surface boundary conditions (and related  quantities)
c
c     trajint = number of days between writing particle trajectories.
c               particle trajectories are always written on the last
c               time step of the run to allow for restarting.
c
c-----------------------------------------------------------------------
c     outputs from tmngr.F: logical switches
c-----------------------------------------------------------------------
c
c     rundays = integration time in days (from "runlen")
c
c     the following are logical counterparts to the above switches are 
c     set within "tmngr" every time step. logical switches control all
c     decisions about when to do things in MOM.
c
c     cmixts  = (false,true) = (don`t, do) do write estimated mixing
c               coefficients on this time step.
c               based on "cmixint".
c
c     crossts  = (false,true) = (don`t, do) write diapycnal and 
c               isopycnal components of flow on this time step.
c               based on "crossint".
c
c     fctts    = (false,true) = (don`t, do) write difference between 
c               FCT and leapfrog advection on this time step.
c               based on "fctint".
c
c     densityts  = (false,true) = (don`t, do) write density on this time
c               step. based on "densityint".
c               
c
c     exconvts  = (false,true) = (don`t, do) do write temperature change
c               due to explicit convection on this time step.
c               based on "exconvint".
c
c     glents  = (false,true) = (don`t, do) do calculation of global
c               energy integrals on this time step. based on "glenint".
c
c     trmbts  = (false,true) = (don`t, do) do calculation of momentum &
c               tracer term balance on this timestep. based on "trmbint"
c
c     gyrets  = (false,true) = (don`t, do) do calculation of tracer
c               northward transport on this timestep. based on "gyreint"
c
c     vmsfts  = (false,true) = (don`t, do) do calculation of vertical
c               and meridional stream function on this time step.
c               based on "vmsfint"
c
c     tyzts   = (false,true) = (don`t, do) do calculation of zonally
c               averaged tracer components on this time step.
c               based on "tyzint"
c
c     prxzts  = (false,true) = (don`t, do) do printouts of x-z data
c               on this time step. based on "prxzint"
c
c     extts  = (false,true) = (don`t, do) do printout of external mode
c               on this time step. based on "extint"
c
c     dspts  = (false,true) = (don`t, do) do calculation of diagnostic 
c              surface pressure on this time step. based on "dspint"
c               
c
c     stabts  = (false,true) = (don`t, do) test for stability on this
c               time step. based on "stabint"
c
c     tavgts  = (false,true) = (don`t do) do tracer averages on this
c               time step. based on "tavgint"
c
c     tmbts   = (false,true) = (don`t, do) write out tracer meridional .
c               balance on this time step. based on "tmbint"
c
c     tsits   = (false,true) = (don`t, do) print time step integrals
c               on this time step. based on "tsiint"
c
c     zmbcts  = (false,true) = (don`t, do) print zonal mean boundary
c               conditions on this time step.  based on "zmbcint"
c
c     trajts  = (false,true) = (don`t, do) print particle trajectories
c               on this time step. based on "trajint"
c
c     snapts  = (false,true) = (don`t, do) save a snapshot of the data
c               on this time step. based on "snapint"
c
c     timats  = (false,true) = (don`t, do) write time mean data
c               on this time step. based on "timavgint"
c                                          
c     xbtts   = (false,true) = (don`t, do) write averaged XBT data on
c               this time step based on "xbtint"
c
c
c     leapfrog= (false,true) on a (mixing, normal leapfrog) time step
c                based on "nmix"
c                                          
c     euler1  = true on the 1st pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     euler2  = true on the 2nd pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     forward = true on a forward time step. otherwise false
c		(applies when "eb" = false)		  
c                                          
c
c     the following logical switches are based on the model time step. 
c    
c     first   = (true,false) =  when it`s (the first, not the first)
c                               time step of a run
c     eots    = end of a time step. always true except for first
c               pass of an euler backward time step
c     eorun   = last time step of a run. always false except during the
c               last time step of the run.
c
c     eoday   = true when within 1/2 time step of the end of a day
c               else ... false
c     eoweek  = true when within 1/2 time step of the end of a 7 day
c               week (referenced to the start of a year) else ...false
c     eo2wks  = true when within 1/2 time step of the end of two weeks
c               (referenced to the start of a year) else ... false
c     midmon  = true when within 1/2 time step of the middle of a month
c               else ... false
c     eomon   = true when within 1/2 time step of the end of a month
c               else ... false
c     eoyear  = true when within 1/2 time step of the end of a year
c               else ... false
c     osegs   = true on the 1st time step of an ocean segment in mom.F
c               otherwise false.
c     osege  =  true on the last time step of an ocean segment in mom.F
c               otherwise false.
c
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c
c
      logical eb, leapfrog, euler1, euler2, forward, eots
      logical init, first, restrt
      logical itavg, itmb, itrmb, igyre
      character *8 rununits
c
      common /switcc/ rununits
      common /switcr/ runlen, rundays
      common /switci/ nmix
      common /switcl/ eb, leapfrog, euler1, euler2, forward, eots
      common /switcl/ init, first, restrt
      common /switcl/ itavg, itmb, itrmb, igyre
c
      logical          eoday, eoweek, eo2wks
      common /switci/ ieoday,ieoweek,ieo2wks
      common /switcl/  eoday, eoweek, eo2wks
c
      logical          eomon, midmon, eoyear, eorun
      common /switci/ ieomon,imidmon,ieoyear,ieorun
      common /switcl/  eomon, midmon, eoyear, eorun
c
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c     each interval switch needs three variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output (e.g,.  glenint)
c         2) a switch (logical) for the interval (e.g.,  glents )
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c         3) an index (integer)                       (e.g., iglenint)
c
c     the user must specify the interval [e.g., glenint] for diagnostic
c     output in units of days. tmngr sets the corresponding logical  
c     switch [e.g., glents] every time step. It is set to true when  
c     within half a time step of the requested interval, otherwise it is
c     false. All decisions relating to the interval [e.g., glenint]
c     are based on the logical switch [e.g., glents].
c           
c     internal time structures
c
c     The switch index [e.g., iglenint] is used to subsrcipt into  
c     internal arrays maintained by tmngr.F. The switch index is
c     allocated on the first call to function "alarm".
c     The array entry [e.g., iinterval(iglenint)] is a time index to the
c     internal representation of the interval [e.g., glenint].
c     The array entry [e.g., ialarm(iglenint)] is a time index to the
c     next time the alarm will be true.
c-----------------------------------------------------------------------
c
      logical           tavgts,    glents,    trmbts,   prxzts
      common /switcr/   tavgint,   glenint,   trmbint,  prxzint
      common /switci/  itavgint,  iglenint,  itrmbint, iprxzint
      common /switcl/   tavgts,    glents,    trmbts,   prxzts
c
      logical          extts,   trajts,   exconvts,   cmixts
      common /switcr/  extint,  trajint,  exconvint,  cmixint
      common /switci/ iextint, itrajint, iexconvint, icmixint
      common /switcl/  extts,   trajts,   exconvts,   cmixts
c
      logical          vmsfts,   gyrets,    tsits,   snapts,   fctts
      common /switcr/  vmsfint,  gyreint,   tsiint,  snapint,  fctint
      common /switci/ ivmsfint, igyreint,  itsiint, isnapint, ifctint
      common /switcl/  vmsfts,   gyrets,    tsits,   snapts,   fctts
c
      logical          tyzts
      common /switcr/  tyzint
      common /switci/ ityzint
      common /switcl/  tyzts
c
      logical          stabts,   zmbcts,   crossts,   densityts
      common /switcr/  stabint,  zmbcint,  crossint,  densityint
      common /switci/ istabint, izmbcint, icrossint, idensityint
      common /switcl/  stabts,   zmbcts,   crossts,   densityts
c
      logical          osegs,  osege
      common /switcr/          segtim
      common /switci/ iosegs, iosege
      common /switcl/  osegs,  osege
c   
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c              A N D   A V E R A G I N G   P E R I O D
c
c     each averaging period switch needs five variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output    (e.g. xbtint  )   
c         2) a switch (logical) for the interval         (e.g. xbtts   )
c         3) an averaging period (real)                  (e.g. xbtper  )   
c         4) a switch (logical) for accumulating         (e.g. xbtperts)
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switches
c
c         5) an index (integer)                         (e.g. ixbtint  )
c
c     The user must specify the interval [e.g., xbtint] for diagnostic
c     output in units of days and the averaging period [e.g., xbtper] 
c     in units of days. The averaging period may be less than or equal
c     to the interval. For example, if the interval is 30.0 days and the
c     averaging period is 5.0 days, results will be averaged over all
c     time steps within days 26, 27, 28, 29, and 30.  An averaging period
c     of 0.0 days averages over the last time step of the interval (as
c     does xbtper = dt), and an averaging period less than zero turns
c     the switches off for all time steps.  
c
c     The logical switch for writing output at the specified interval 
c     [e.g., xbtts] is set to true on the last time step of the 
c     averaging period. The logical switch for accumulating results
c     [e.g., xbtperts] is true for all time steps within the averaging
c     period, otherwise it is false. 
c
c     internal time structures
c
c     The index [e.g., ixbtint] is allocated on the first call to 
c     function "avg_alarm". The array element iperiod(ixbtint) is an
c     index to the time structure for the internal representation of 
c     "xbtper", and ilastsw(ixbtint) is the index of the switch that 
c     flags the last time step of the accumulation period.
c     Depending on use,  ilastsw(ixbtint) may either be the index
c     of another "named" switch or the index of a new switch
c     allocated on the first time step.
c     In the latter case, iinterval(ilastsw(ixbtint)) is the index of
c     the time structure where "xbtint" is stored in internal form,
c     and ialarm(ilastsw(ixbtint)) is the index of the time when an
c     accumulation period will next end.
c     The variable nextts(ixbtint) is true whenever the next
c     time step will begin the accumulation period.
c
c-----------------------------------------------------------------------
c
      logical         xbtts,     dspts,    tmbts,    timavgts
      logical         xbtperts,  dspperts, tmbperts, timavgperts
      common /switcr/ xbtint,    dspint,   tmbint,   timavgint
      common /switcr/ xbtper,    dspper,   tmbper,   timavgper
      common /switci/ixbtint,   idspint,  itmbint,  itimavgint
      common /switcl/ xbtts,     dspts,    tmbts,    timavgts
      common /switcl/ xbtperts,  dspperts, tmbperts, timavgperts
c
c-----------------------------------------------------------------------
c
c                 S W I T C H E S    B A S E D    O N    
c
c         C A L E N D A R   O R    P R E V I O U S    S W I T C H   
c
c               A N D   A V E R A G I N G    P E R I O D
c
c    
c
c     the following logical switches are based on any calendar or 
c     interval switch and an averaging period (in days). The  averaging
c     period must be less than or equal to the interval. The last
c     time step of the averaging period is at the end of the interval.
c     If the averaging period is set to zero, the averaging period
c     consists only of the last time period of the interval.  If
c     the averaging period is less than zero, these switches are always
c     false.
c
c     each averaging period switch needs four variables in common. For
c     example, if the averaging period is before the end of each month
c     then the calendar switch (eomon), and index (ieomon) are presumed
c     to exist in common and need not be added.
c     
c     Additionally, four items are needed.
c
c       1) an averaging period (real)                  (e.g.  testper  )   
c       2) a switch (logical) for accumulating results (e.g.  testperts)
c       3) a switch (logical) for the end of interval  (e.g.  testts   )
c
c     the fourth is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c       4) an index (integer)                          (e.g.  itestper )
c
c     Suppose it is required to produce averages over all time steps
c     during the last 5 days of each month. Then "testper" = 5.0 and 
c     the following will calculate the accumulating switch.
c
c      testts = avg_alarm(itestper, ihalfstep, 0, testper, iref, ieomon)
c      testperts = on(itestper)
c
c     Note the use of "ieomon" to key off the months.  The switch
c     "testts" will be true whenever "eomon" is true.
c     Also note that when an averaging switch is keyed off another
c     switch, the switch inverval argument is not used, but is 
c     retained for consistency with the form of other averaging
c     switches.
c-----------------------------------------------------------------------
c
      logical           testperts
      logical           testts
      common /switcr/   testint
      common /switcr/   testper
      common /switci/  itestper
      common /switcl/   testts
      common /switcl/   testperts

c
      parameter (maxsw=100)
      logical          on, lastts, nextts
      common /switci/  nsw  
      common /switci/  ialarm(maxsw), iinterval(maxsw), iperiod(maxsw)
     &,                ilastsw(maxsw)
      common /switcl/  on(maxsw), lastts(maxsw), nextts(maxsw)
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c


      character *(*) rununits0
c
c     copy inputs to common in "switch.h"
c
      runlen = runlen0
      rununits = rununits0
c
c     calculate end of run based on rununits0
c
      call getswitch (ieorun)
      call getfulltime (ialarm(ieorun))
      call copyfulltime (irunstart, ialarm(ieorun))
      if (rununits0 .eq. 'years') then
        year(ialarm(ieorun)) = year(ialarm(ieorun)) + nint(runlen0)
        call expandtime (ialarm(ieorun))
        day  (ialarm(ieorun)) = min (day(irunstart), 
     &                               daysinmon(ialarm(ieorun)))
        call expandtime (ialarm(ieorun))
        if (real(nint(runlen0)) .ne. runlen0) then
          print '(/,a,1pg14.7,a,i3,a,/)', 
     &          'WARNING:  run length ',runlen0,' years rounded to ',
     &          nint(runlen0), ' years'
          runlen0 = real(nint(runlen0))
          runlen = runlen0
        end if
      elseif (rununits0 .eq. 'months') then
        month(ialarm(ieorun)) = month(ialarm(ieorun)) + nint(runlen0)
     &                                                - 1
        year (ialarm(ieorun)) = year (ialarm(ieorun)) + month(ieorun)/12
        month(ialarm(ieorun)) = modulo (month(ialarm(ieorun)), 12) + 1
        day  (ialarm(ieorun)) = 1
        call expandtime (ialarm(ieorun))
        if (real(nint(runlen0)) .ne. runlen0) then
          print '(/,a,1pg14.7,a,i3,a,/)', 
     &          'WARNING:  run length ',runlen0,' months rounded to ',
     &          nint(runlen0), ' months'
          runlen0 = real(nint(runlen0))
          runlen = runlen0
        end if
        day  (ialarm(ieorun)) = min (day(irunstart), 
     &                               daysinmon(ialarm(ieorun)))
        call expandtime (ialarm(ieorun))
      elseif (rununits0 .eq. 'days') then
        call settime3 (itemptime, runlen0)
        call addtime (irunstart, itemptime, ialarm(ieorun))
        call expandtime2 (ialarm(ieorun))
      else
        write (stdout, *)
     &       'Warning: No units given for run length--days assumed'
        call settime3 (itemptime, runlen0)
        call addtime (irunstart, itemptime, ialarm(ieorun))
        call expandtime2 (ialarm(ieorun))
      end if
c
      call subtime (ialarm(ieorun), irunstart, itemptime)
      rundays0 = realdays (itemptime)
      rundays  = rundays0
c
      return
      end


      subroutine initswitch
c
c=======================================================================
c     initialize switch indices for getswitch.
c
c     author:  c. h. goldberg       chg@gfdl.gov
c=======================================================================
c
c====================== include file "switch.h" ========================
c
c     all time dependent decisions are made by time manager "tmngr.F"
c     and communicated elsewhere to the model via logical switches.
c
c     inputs: (defaulted in "blkdta.F", optionally reset via namelist)
c
c
c     runlen  = integration period (see rununits). note "runlen" should
c               be an integral number of density time steps. if not,
c               then "runlen" is automatically adjusted to insure this.
c               fractional days are supported but not fractional months
c               or years.
c     rununits= units of "runlen". may be "days", "months", or "years".
c               tmngr will convert "runlen" which is in "rununits"
c               to "rundays" in units of days.
c
c     segtim  = the integration time "runlen" is broken into a number of
c               segments each of length "segtim" days. updated surface
c               boundary conditions are applied to MOM every "segtim" 
c               days. this is useful when coupling to atmospheric models
c               in which case both models exchange surface boundary
c               conditions every "segtim" days where "segtim"
c               is 1/(coupling frequency). without an atmospheric model,
c               when getting surface boundary conditions from data, 
c               "segtim" is set to the time step (in days) by mom.F. in
c               either case, "runlen" (in days) should be an integral
c               number of "segtim".     
c
c     nmix    = number of time steps between mixing timesteps. used
c               to damp timestep splitting due to centered leapfrog.
c
c     init    = (true,false)  indicates that this run is a
c               (start from initial conditions, restart)
c
c     restrt  = (true,false) = (do,don`t) write a restart at the end
c               of the run
c
c     eb      = (true,false) configures for the use of a 
c               (euler backward,forward) type mixing timestep
c
c-----------------------------------------------------------------------
c     inputs to tmngr.F: diagnostic intervals
c-----------------------------------------------------------------------
c
c     note: switches are used to control the interval between doing
c           diagnostics. units for all switches are in days. 
c           setting a switch < 0.0 disables whatever the switch is 
c           controlling. setting it = 0.0 causes the diagnostic to be 
c           done every time step, and setting it > 0.0 causes the 
c           diagnostic to be done repeatedly on the specified interval. 
c
c     cmixint = number of days between writing estimated mixing coeffs
c               on faces of T cells and U cells
c
c     crossint = number of days between writing diapycnal and isopycnal
c               components of flow
c
c     fctint = number of days between writing difference between 
c              FCT and leapfrog advection
c
c     densityint = number of days between writing density
c
c     exconvint = number of days between writing temperature rate of
c                 change due to explicit convection
c
c     glenint =  number of days between global energetics integrals.
c
c     trmbint =  number of days between momentum and tracer term
c                balances (global and regional).
c
c     itrmb   = (true,false) = (do,don`t) write regional mask info for
c               the term balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     gyreint =  number of days between calculation of tracer northward
c                transport.
c     igyre   = (true,false) = (do,don`t) write regional mask info for
c               the gyre diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     vmsfint =  number of days between calculation of vertical and
c                meridional stream function.
c
c     tyzint  =  number of days between calculation of zonally averaged
c                tracer components.
c
c     prxzint =  number of days between printouts of x-z data.
c
c     extint  =  number of days between printouts of external mode.
c
c     dspint  =  number of days between surface pressure calculation.
c                Note: only when "diagnostic_surface_height" is enabled.
c     dspper  = averaging period for "diagnostic_surface_height"
c
c     tavgint = number of days between regional tracer averages (under
c               horizontal regions).
c
c     itavg   = (true,false) = (do,don`t) write regional mask info for
c               the tracer average diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     tmbint  = number of days over which tracer equation in averaged
c               in depth and longitude to determine the meridional 
c               balance among storage, divergence, dissipation and 
c               forcing.
c     tmbper  = averaging period for "meridional_tracer_balance"
c
c     itmb    = (true,false) = (do,don`t) write "msktmb" for tracer
c               the meridional balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c
c     tsiint  = number of days between printing of time step integrals.
c
c     stabint = number of days between sampling for various stability
c               criteria.
c
c     snapint = number of days between writing instantaneous samples
c               of data from the MOM grid. note: only when "snapshots"
c               is enabled. see "iounit.h" for more details.
c               all data is at time level "tau" so it is one time step
c               before the date shown in "stamp".
c
c     timavgint= interval (days) for writing time mean data from
c               the "averaging" grid (only when "time_averages" is
c               enabled). if "timavgint" is not an integral number of
c               density time steps,"timavgint" is automatically adjusted
c               to insure this. if the number of days to integrate is
c               not an integral number of "timavgint" then the last
c               averaging period will be less than "timavgint" days.this 
c               may lead to one more averaging period than expected. 
c               see "iounit.h" for more details.
c     timavgper= averaging period for "time_averages"
c
c     xbtint  = averaging period (days) for writing XBT data (only when
c               "xbts" is enabled). if "xbtint" is not an integral
c               number of density time steps, "xbtint" is automatically
c               adjusted to insure this. if the number of days to 
c               integrate is not an integral number of "xbtint" then the
c               last averaging period will be less than "xbtint" days.
c               this may lead to one more averaging period than  
c               expected. see "iounit.h" for more details.
c     xbtper  = averaging period for "xbts"
c
c     zmbcint = number of days between calculation of zonal mean
c               surface boundary conditions (and related  quantities)
c
c     trajint = number of days between writing particle trajectories.
c               particle trajectories are always written on the last
c               time step of the run to allow for restarting.
c
c-----------------------------------------------------------------------
c     outputs from tmngr.F: logical switches
c-----------------------------------------------------------------------
c
c     rundays = integration time in days (from "runlen")
c
c     the following are logical counterparts to the above switches are 
c     set within "tmngr" every time step. logical switches control all
c     decisions about when to do things in MOM.
c
c     cmixts  = (false,true) = (don`t, do) do write estimated mixing
c               coefficients on this time step.
c               based on "cmixint".
c
c     crossts  = (false,true) = (don`t, do) write diapycnal and 
c               isopycnal components of flow on this time step.
c               based on "crossint".
c
c     fctts    = (false,true) = (don`t, do) write difference between 
c               FCT and leapfrog advection on this time step.
c               based on "fctint".
c
c     densityts  = (false,true) = (don`t, do) write density on this time
c               step. based on "densityint".
c               
c
c     exconvts  = (false,true) = (don`t, do) do write temperature change
c               due to explicit convection on this time step.
c               based on "exconvint".
c
c     glents  = (false,true) = (don`t, do) do calculation of global
c               energy integrals on this time step. based on "glenint".
c
c     trmbts  = (false,true) = (don`t, do) do calculation of momentum &
c               tracer term balance on this timestep. based on "trmbint"
c
c     gyrets  = (false,true) = (don`t, do) do calculation of tracer
c               northward transport on this timestep. based on "gyreint"
c
c     vmsfts  = (false,true) = (don`t, do) do calculation of vertical
c               and meridional stream function on this time step.
c               based on "vmsfint"
c
c     tyzts   = (false,true) = (don`t, do) do calculation of zonally
c               averaged tracer components on this time step.
c               based on "tyzint"
c
c     prxzts  = (false,true) = (don`t, do) do printouts of x-z data
c               on this time step. based on "prxzint"
c
c     extts  = (false,true) = (don`t, do) do printout of external mode
c               on this time step. based on "extint"
c
c     dspts  = (false,true) = (don`t, do) do calculation of diagnostic 
c              surface pressure on this time step. based on "dspint"
c               
c
c     stabts  = (false,true) = (don`t, do) test for stability on this
c               time step. based on "stabint"
c
c     tavgts  = (false,true) = (don`t do) do tracer averages on this
c               time step. based on "tavgint"
c
c     tmbts   = (false,true) = (don`t, do) write out tracer meridional .
c               balance on this time step. based on "tmbint"
c
c     tsits   = (false,true) = (don`t, do) print time step integrals
c               on this time step. based on "tsiint"
c
c     zmbcts  = (false,true) = (don`t, do) print zonal mean boundary
c               conditions on this time step.  based on "zmbcint"
c
c     trajts  = (false,true) = (don`t, do) print particle trajectories
c               on this time step. based on "trajint"
c
c     snapts  = (false,true) = (don`t, do) save a snapshot of the data
c               on this time step. based on "snapint"
c
c     timats  = (false,true) = (don`t, do) write time mean data
c               on this time step. based on "timavgint"
c                                          
c     xbtts   = (false,true) = (don`t, do) write averaged XBT data on
c               this time step based on "xbtint"
c
c
c     leapfrog= (false,true) on a (mixing, normal leapfrog) time step
c                based on "nmix"
c                                          
c     euler1  = true on the 1st pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     euler2  = true on the 2nd pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     forward = true on a forward time step. otherwise false
c		(applies when "eb" = false)		  
c                                          
c
c     the following logical switches are based on the model time step. 
c    
c     first   = (true,false) =  when it`s (the first, not the first)
c                               time step of a run
c     eots    = end of a time step. always true except for first
c               pass of an euler backward time step
c     eorun   = last time step of a run. always false except during the
c               last time step of the run.
c
c     eoday   = true when within 1/2 time step of the end of a day
c               else ... false
c     eoweek  = true when within 1/2 time step of the end of a 7 day
c               week (referenced to the start of a year) else ...false
c     eo2wks  = true when within 1/2 time step of the end of two weeks
c               (referenced to the start of a year) else ... false
c     midmon  = true when within 1/2 time step of the middle of a month
c               else ... false
c     eomon   = true when within 1/2 time step of the end of a month
c               else ... false
c     eoyear  = true when within 1/2 time step of the end of a year
c               else ... false
c     osegs   = true on the 1st time step of an ocean segment in mom.F
c               otherwise false.
c     osege  =  true on the last time step of an ocean segment in mom.F
c               otherwise false.
c
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c
c
      logical eb, leapfrog, euler1, euler2, forward, eots
      logical init, first, restrt
      logical itavg, itmb, itrmb, igyre
      character *8 rununits
c
      common /switcc/ rununits
      common /switcr/ runlen, rundays
      common /switci/ nmix
      common /switcl/ eb, leapfrog, euler1, euler2, forward, eots
      common /switcl/ init, first, restrt
      common /switcl/ itavg, itmb, itrmb, igyre
c
      logical          eoday, eoweek, eo2wks
      common /switci/ ieoday,ieoweek,ieo2wks
      common /switcl/  eoday, eoweek, eo2wks
c
      logical          eomon, midmon, eoyear, eorun
      common /switci/ ieomon,imidmon,ieoyear,ieorun
      common /switcl/  eomon, midmon, eoyear, eorun
c
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c     each interval switch needs three variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output (e.g,.  glenint)
c         2) a switch (logical) for the interval (e.g.,  glents )
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c         3) an index (integer)                       (e.g., iglenint)
c
c     the user must specify the interval [e.g., glenint] for diagnostic
c     output in units of days. tmngr sets the corresponding logical  
c     switch [e.g., glents] every time step. It is set to true when  
c     within half a time step of the requested interval, otherwise it is
c     false. All decisions relating to the interval [e.g., glenint]
c     are based on the logical switch [e.g., glents].
c           
c     internal time structures
c
c     The switch index [e.g., iglenint] is used to subsrcipt into  
c     internal arrays maintained by tmngr.F. The switch index is
c     allocated on the first call to function "alarm".
c     The array entry [e.g., iinterval(iglenint)] is a time index to the
c     internal representation of the interval [e.g., glenint].
c     The array entry [e.g., ialarm(iglenint)] is a time index to the
c     next time the alarm will be true.
c-----------------------------------------------------------------------
c
      logical           tavgts,    glents,    trmbts,   prxzts
      common /switcr/   tavgint,   glenint,   trmbint,  prxzint
      common /switci/  itavgint,  iglenint,  itrmbint, iprxzint
      common /switcl/   tavgts,    glents,    trmbts,   prxzts
c
      logical          extts,   trajts,   exconvts,   cmixts
      common /switcr/  extint,  trajint,  exconvint,  cmixint
      common /switci/ iextint, itrajint, iexconvint, icmixint
      common /switcl/  extts,   trajts,   exconvts,   cmixts
c
      logical          vmsfts,   gyrets,    tsits,   snapts,   fctts
      common /switcr/  vmsfint,  gyreint,   tsiint,  snapint,  fctint
      common /switci/ ivmsfint, igyreint,  itsiint, isnapint, ifctint
      common /switcl/  vmsfts,   gyrets,    tsits,   snapts,   fctts
c
      logical          tyzts
      common /switcr/  tyzint
      common /switci/ ityzint
      common /switcl/  tyzts
c
      logical          stabts,   zmbcts,   crossts,   densityts
      common /switcr/  stabint,  zmbcint,  crossint,  densityint
      common /switci/ istabint, izmbcint, icrossint, idensityint
      common /switcl/  stabts,   zmbcts,   crossts,   densityts
c
      logical          osegs,  osege
      common /switcr/          segtim
      common /switci/ iosegs, iosege
      common /switcl/  osegs,  osege
c   
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c              A N D   A V E R A G I N G   P E R I O D
c
c     each averaging period switch needs five variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output    (e.g. xbtint  )   
c         2) a switch (logical) for the interval         (e.g. xbtts   )
c         3) an averaging period (real)                  (e.g. xbtper  )   
c         4) a switch (logical) for accumulating         (e.g. xbtperts)
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switches
c
c         5) an index (integer)                         (e.g. ixbtint  )
c
c     The user must specify the interval [e.g., xbtint] for diagnostic
c     output in units of days and the averaging period [e.g., xbtper] 
c     in units of days. The averaging period may be less than or equal
c     to the interval. For example, if the interval is 30.0 days and the
c     averaging period is 5.0 days, results will be averaged over all
c     time steps within days 26, 27, 28, 29, and 30.  An averaging period
c     of 0.0 days averages over the last time step of the interval (as
c     does xbtper = dt), and an averaging period less than zero turns
c     the switches off for all time steps.  
c
c     The logical switch for writing output at the specified interval 
c     [e.g., xbtts] is set to true on the last time step of the 
c     averaging period. The logical switch for accumulating results
c     [e.g., xbtperts] is true for all time steps within the averaging
c     period, otherwise it is false. 
c
c     internal time structures
c
c     The index [e.g., ixbtint] is allocated on the first call to 
c     function "avg_alarm". The array element iperiod(ixbtint) is an
c     index to the time structure for the internal representation of 
c     "xbtper", and ilastsw(ixbtint) is the index of the switch that 
c     flags the last time step of the accumulation period.
c     Depending on use,  ilastsw(ixbtint) may either be the index
c     of another "named" switch or the index of a new switch
c     allocated on the first time step.
c     In the latter case, iinterval(ilastsw(ixbtint)) is the index of
c     the time structure where "xbtint" is stored in internal form,
c     and ialarm(ilastsw(ixbtint)) is the index of the time when an
c     accumulation period will next end.
c     The variable nextts(ixbtint) is true whenever the next
c     time step will begin the accumulation period.
c
c-----------------------------------------------------------------------
c
      logical         xbtts,     dspts,    tmbts,    timavgts
      logical         xbtperts,  dspperts, tmbperts, timavgperts
      common /switcr/ xbtint,    dspint,   tmbint,   timavgint
      common /switcr/ xbtper,    dspper,   tmbper,   timavgper
      common /switci/ixbtint,   idspint,  itmbint,  itimavgint
      common /switcl/ xbtts,     dspts,    tmbts,    timavgts
      common /switcl/ xbtperts,  dspperts, tmbperts, timavgperts
c
c-----------------------------------------------------------------------
c
c                 S W I T C H E S    B A S E D    O N    
c
c         C A L E N D A R   O R    P R E V I O U S    S W I T C H   
c
c               A N D   A V E R A G I N G    P E R I O D
c
c    
c
c     the following logical switches are based on any calendar or 
c     interval switch and an averaging period (in days). The  averaging
c     period must be less than or equal to the interval. The last
c     time step of the averaging period is at the end of the interval.
c     If the averaging period is set to zero, the averaging period
c     consists only of the last time period of the interval.  If
c     the averaging period is less than zero, these switches are always
c     false.
c
c     each averaging period switch needs four variables in common. For
c     example, if the averaging period is before the end of each month
c     then the calendar switch (eomon), and index (ieomon) are presumed
c     to exist in common and need not be added.
c     
c     Additionally, four items are needed.
c
c       1) an averaging period (real)                  (e.g.  testper  )   
c       2) a switch (logical) for accumulating results (e.g.  testperts)
c       3) a switch (logical) for the end of interval  (e.g.  testts   )
c
c     the fourth is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c       4) an index (integer)                          (e.g.  itestper )
c
c     Suppose it is required to produce averages over all time steps
c     during the last 5 days of each month. Then "testper" = 5.0 and 
c     the following will calculate the accumulating switch.
c
c      testts = avg_alarm(itestper, ihalfstep, 0, testper, iref, ieomon)
c      testperts = on(itestper)
c
c     Note the use of "ieomon" to key off the months.  The switch
c     "testts" will be true whenever "eomon" is true.
c     Also note that when an averaging switch is keyed off another
c     switch, the switch inverval argument is not used, but is 
c     retained for consistency with the form of other averaging
c     switches.
c-----------------------------------------------------------------------
c
      logical           testperts
      logical           testts
      common /switcr/   testint
      common /switcr/   testper
      common /switci/  itestper
      common /switcl/   testts
      common /switcl/   testperts

c
      parameter (maxsw=100)
      logical          on, lastts, nextts
      common /switci/  nsw  
      common /switci/  ialarm(maxsw), iinterval(maxsw), iperiod(maxsw)
     &,                ilastsw(maxsw)
      common /switcl/  on(maxsw), lastts(maxsw), nextts(maxsw)
c
c
      nsw = 0
c
      return
      end





      subroutine timeinterpi (nrec, stamp1, aprec, tdrec, isbcstart
     &,                       period)
c              
c=======================================================================
c     initializes time center of each data record based on the time
c     stamp and average period.
c
c     author: c. h. goldberg        e-mail=> chg@gfdl.gov
c             r. c. pacanowski      e-mail=> rcp@gfdl.gov
c=======================================================================
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c


      dimension aprec(nrec), tdrec(nrec)
      character*(*) stamp1
      logical period
      data isbcend /0/
      save isbcend
c
c     define each climatological data record to be at the center of the
c     month starting with month "isbcmonth"
c
      sum = 0.0
      do m=1,nrec
        sum      = sum + aprec(m)
        tdrec(m) = sum - 0.5*aprec(m)
      enddo
c
c     calculate time at start of first record: "isbcstart"
c
      if (isbcend .eq. 0) call getfulltime (isbcend)
      call getfulltime (isbcstart)
c      
      call rdstmp (stamp1, isbcyear, isbcmon, isbcday, isbchour
     &,            isbcmin, isbcsec)
      call setfulltime (isbcend, isbcyear, isbcmon, isbcday, isbchour
     &,            isbcmin, isbcsec)
      call inctime (isbcend, -aprec(1), isbcstart)
c
c     check integrity of data record times. also when using datasets
c     as periodic, add 0.2425 days to febuary and adjust subsequent
c     months to account for this change when using the time manager 
c     with a leap year calendar.           
c
      if (period) call checkinterp (nrec, tdrec, aprec) 
      return
      end


      subroutine timeinterp (tm, n, tdrec, aprec, ndr, period, method
     &,                     ia, ib, wb, change, inext, iprev)
c
c=======================================================================
c
c     time interpolator ... constructs indices & weight needed for
c     linearly interpolating data defined at arbitrary time intervals
c     (midpoints of years, months, days or  random intervals) to
c     the time of the current model time step.
c
c     inputs:
c
c     tm     = the time at which the data is desired (units of "tdrec")
c
c     tdrec  = the times at which the data records in the dataset are
c              defined. times must be monotonically increasing and are
c              assumed to be at the centers of the averaging periods.
c              (eg: the centers of the months if using monthly averaged
c               climatology. units are arbitrary)
c
c     aprec  = array of averaging periods for the data records
c              (eg: the number of days per month)
c
c     ndr    = number of data records in the dataset. (eg: 12 if using
c              monthly climatology)
c
c     period = (true,false) if the dataset is to be treated as
c              (perodic, not periodic). if periodic, then the model
c               time is always mapped into the dataset. if not, then
c               record 1 is used for all model time before the 
c               beginning of the dataset and record "ndr" is used for
c               all model time after the end of the dataset.
c
c     method = interpolation scheme desired.  (0..3)
c                0 = no interpolation; the average value is used
c                    for all times in the entire averaging period.
c                    (preserves the integral over averaging periods,
c                    but is discontinuous at period boundaries.)
c                1 = linear interpolation between the middles of
c                    two adjacent averaging periods.
c                    (continuous but does not preserve integral for
c                    unequal periods.)
c                2 = equal linear interpolation.  Assumes that the
c                    value on the boundary between two adjacent
c                    averaging periods is the unweighted average of
c                    the two average values.  Linearly interpolates
c                    between the midperiod and period boundary.
c                    (continuous but does not preserve integral for
c                    unequal periods.)
c                3 = equal area (midperiod to midperiod) interpolation
c                    chooses a value for the boundary between two
c                    adjacent periods such that linear interpolation 
c                    between the two midperiods and this value will
c                    preserve the integral midperiod to midperiod.
c                Note that methods 1,2, and 3 are equivalent if
c                all periods lengths are equal.
c
c     n      = a number denoting which dataset is being interpolated
c              (each dataset should be referenced by a unique number
c               starting with 1 for the 1st, 2 for the 2nd, ...etc)
c
c
c     outputs:
c
c     ia     = index for pointing to the next data record which will be
c              reached by the model. (eg: ahead of the model. "ia" would
c              be 3 if "tm" was beyond the  middle of {but still within} 
c              february)
c     ib     = index for pointing to the data record which was just
c              passed by the model. (eg: behind the model. "ib" would
c              be 2 if "tm" was beyond the middle of {but still within}
c              february)
c     inext  = index to memory buffer containing data from "ia"
c     iprev  = index to memory buffer containing data from "ib"
c     wb     = interpolation weight for defining data at "tm"
c              schematically the interpolation is defined by:
c
c              data(iprev) <== disk data "ib"              
c              data(inext) <== disk data "ia"
c              data(tm) = wb*data(iprev) + (1-wb)*data(inext)
c
c     change = logical for sensing when "ia" and "ib" change.
c              when change = T then it is time to read the disk
c              and update "inext" and "iprev"
c     
c     author:        r. c. pacanowski      e-mail=> rcp@gfdl.gov
c     revised by:    d. j. goldberg        e-mail=> chg@gfdl.gov         
c=======================================================================
c
      logical change, period
      parameter (maxsets=15, iflag=-99999)
      dimension iaold(maxsets), tdrec(ndr), aprec(ndr)
      dimension imethod(maxsets)
      data iaold /maxsets*iflag/
      save iaold, imethod
c
c-----------------------------------------------------------------------
c     statement function
c-----------------------------------------------------------------------
c
      frac(r) = r - int(r)
c
      if (n .gt. maxsets) then
        write (*,'(a,i10,a,i10)') 'Error: n=', n, ' maxsets=',maxsets
        stop '=>timeinterp'
      end if
c
      if (iaold(n) .eq. iflag) then
        write (*,'(/1x,a,i2,a,i3/)')
     &      'Assigning interpolation method ',method, ' to dataset # ',n
        imethod(n) = method
      endif 
c
      if (method .ne. imethod(n)) then
        write (*,'(/a,i2,a,i3/a,i2,a/)')
     &   'Error: trying to use method ',method, ' on dataset # ',n
     &,  'originally, method ',imethod(n),' was used in timeinterp'
        stop 
      endif 
c
      if (period) then
c
c       define the position of the dataset in time
c      
        dstart = tdrec(1) - 0.5*aprec(1)
        dend   = tdrec(ndr) + 0.5*aprec(ndr)
        dlen   = dend - dstart
c
c       map the model time into the dataset assuming dataset periodicity
c
        if (tm .lt. dstart) then
          d = dstart - tm
          f = frac(d/dlen)
          time = dend - f*dlen
        elseif (tm .gt. dend) then
          d = tm - dend
          f = frac(d/dlen)
          time = dstart + f*dlen
        else
          time = tm
        end if
      else
c
c       define the position of the dataset in time. no periodicity
c      
        dstart = tdrec(1)
        dend   = tdrec(ndr)
        dlen   = dend - dstart
c
c       map the model time into the dataset. assume data is constant
c       before the beginning and after the end of the dataset
c
        if (tm .lt. dstart) then
          time = dstart
        elseif (tm .gt. dend) then
          time = dend 
        else
          time = tm
        end if
      end if
c
c     calculate record pointers and weighting for interpolation of
c     dataset records to the model time step.
c
      ib = indp (time, tdrec, ndr)
      if (tdrec(ib) .gt. time) ib = ib - 1
      if (period) then
        ia = mod(ib, ndr) + 1
        if (ib .lt. 1) ib = ndr
      else
        ia = ib + 1
        if (ia .gt. ndr) ia = ib
        if (ib .lt. 1)   ib = ia
      end if
c
c     find whether "time" is closer to midpoint of record "ia" or ib"
c     ic is the index of the closest midpoint
c     io is the index of the other midpoint
c
      startaft = tdrec(ia) - 0.5*aprec(ia)
      if (time .ge. startaft .and. time .le. tdrec(ia)) then
        ic = ia
        io = ib
      else
        ic = ib
        io = ia
      end if
c
c     dtmid = distance from "time" to midpoint of closer record
c     dtbnd = distance from "time" to boundary of closer record
c     dtomid = distance from "time" to midpoint of other record
c
      dtmid  = abs(time - tdrec(ic))
      dtbnd  = 0.5*aprec(ic) - dtmid
      dtomid = 0.5*aprec(io) + dtbnd
c
c-----------------------------------------------------------------------
c     3) equal area (midperiod to midperiod) interpolation formula
c-----------------------------------------------------------------------
c
      if (method .eq. 3) then
        wc = 2.0*dtbnd/aprec(ic) + 2.0*dtmid/(aprec(ic) + aprec(io))
c
c-----------------------------------------------------------------------
c     2) equal linear interpolation
c             value on period boundary assumed to be average of values
c             on the two adjacent periods.
c-----------------------------------------------------------------------
c
      elseif (method .eq. 2) then
        wc = (2.0*dtbnd + dtmid)/aprec(ic)
c
c-----------------------------------------------------------------------
c     1) linear interpolation
c-----------------------------------------------------------------------
c
      elseif (method .eq. 1) then
        wc = dtomid/(dtmid + dtomid)
c
c-----------------------------------------------------------------------
c     0) no interpolation
c-----------------------------------------------------------------------
c
      elseif (method .eq. 0) then
        wc = 1.0
      else
c
c-----------------------------------------------------------------------
c     anyting else is not allowed for (unless you want to add one!)
c-----------------------------------------------------------------------
c
        print *,'=>Error: method = ',method,' not allowed in timeinterp'
        stop 
      end if
c
      if (ib .eq. ic) then
        wb = wc
      else
        wb = 1.0 - wc
      end if
      if (wc .lt. 0.0 .or. wc .gt. 1.0) then
        print *,' ic=',ic,' io=',io, ' dtmid=',dtmid,' dtbnd=',dtbnd
     &,' dtomid=',dtomid, ' time=',time, ' ia=',ia,' ib=',ib
     &, ' wc=',wc
        print *,' =>Error: bad interpolation wieght in timeinterp'
        stop
      endif
c
c     refresh pointers to memory buffers when reading disk data
c
      if (iaold(n) .ne. ia) then
        change = .true.
        itemp = iprev
        iprev = inext
        inext = itemp
      else
        change = .false.
      end if
      iaold(n) = ia
c

      return
      end



      subroutine checkinterp (ntdrec, tdrec, aprec)
c              
c=======================================================================
c     check for consistency between interpolation period centers "tdrec"
c     and period lengths "aprec".
c     adjust tdrec and aprec for leap years
c     check for and compensate for some mismatches between data and 
c     calendar
c
c     authors: c. h. goldberg           chg@gfdl.gov
c              r. c. pacanowski         rcp@gfdl.gov
c=======================================================================
c
c======================= include file "calendar.h"======================
c
c                       calendar specification arrays
c
c-----------------------------------------------------------------------
c
c     eqyear = true to select a calendar in which each year
c              has the same number of days (i.e., no leap years)
c              false selects a julian calendar
c
c     eqmon  = true to force all months to have the same number of days
c              false => the usual 31, 28, 31, 30, ..., days per month. 
c              only used when eqyear = true 
c
c     dayname = character names of days
c
c     monname = character names of months
c
c     monlen = the length of each month (in days) when eqmon is true
c
c     yrlen  = the length of a typical (non-leap) year in days
c
c     daypm  = array of month lengths in days   (non-leap)
c
c     msum   = array of cumulative days preceding each month
c              (again, non-leap)
c
c-----------------------------------------------------------------------
      logical eqyear, eqmon
      integer daypm, msum, yrlen, monlen
c
      character*10 dayname
      character*12 monname
c
      common /calenc/ dayname(7), monname(12)
      common /calenl/ eqyear, eqmon
      common /caleni/ daypm(12), msum(12), yrlen, monlen

c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
      dimension tdrec(ntdrec), aprec(ntdrec)
      logical febdone, monthly, error
c
c     test for consistency of tdrec and aprec times
c
      monthly = .true.
      error   = .false.
      sum     = 0.5*aprec(1)
      do m=2,ntdrec
        sum = sum + 0.5*(aprec(m) + aprec(m-1))
	if (abs(tdrec(m) - sum) .gt. 0.01*tdrec(m)) then
	  error = .true.
	  write (stdout,*) 'Error in time interpolation data'
	  write (stdout,*) 'Date for middle of record ',m
     &,                   ' is not centered'
	endif
	if (.not.(28.0 .le. aprec(m) .and. aprec(m) .le. 32)) then
	  monthly = .false.
	endif
      enddo
c
      if (error) then
        write (stdout,*) 'STOP in checkinterp'
c	stop
      endif
c
      dlen = (tdrec(ntdrec) + 0.5*aprec(ntdrec)) - 
     &       (tdrec(1) - 0.5*aprec(1))
c
c     if using leap years, add 1/4 day to feburary (or last record in
c     feb if data is other than monthly. eg: daily)
c
      if (.not.eqyear) then
        if (mod(dlen, real(yrlen)) .lt. 0.01) then
c
c         calendar has leap years but data does not, add 1/4 day to
c         feburary (or last record in feb if data is other than monthly.
c         eg: daily)
c     
          write (stdout, '(/,a,a)')
     &           'Checkinterp: Modifying equal year interpolation' 
     &,          ' data for use with leap year calendar'
          febdone = .false.
	  time    = 0.0
          do m=1,ntdrec
	    time = time + aprec(m)
	    if (time .ge. yrlen) then
	      time = time - yrlen
	      febdone = .false.
	    endif
	    if (time .ge. msum(3)) then
	      if (.not. febdone) then
	        aprec(m)   = aprec(m) + 0.2425
                write (stdout, '(a,i4)')
     &                'Checkinterp: Adding 0.2425 days to record ',m
	        febdone = .true.
	      endif
	    endif
	  enddo
          sum = tdrec(1) - 0.5*aprec(1)
          do m=1,ntdrec
            sum = sum + aprec(m)
            tdrec(m) = sum - 0.5*aprec(m)
c	    print *,' m=',m,' tdrec=',tdrec(m), ' aprec=',aprec(m)
          enddo
c	  
        elseif (mod(dlen, real(yrlen)) - 0.2425*nint(dlen/yrlen)
     &          .le. 0.01) then
c
c         calendar has leap years and data is leap year corrected by adding
c         0.2425 days per year.  interpolation data is consistent.
c
        else
c
c         calendar has leap years but data is neither leap year
c         compensated nor an exact number of years, it is not clear
c         what user wants.
c
          write (stdout,*) 'Problem in checkinterp'
	  write (stdout,*) 'Calendar uses leap years, but interpolation'
     &,	     ' data is neither an integer number of years or leap year'
     &,		   ' corrected by adding 0.2425 days per year.'
          stop
	endif
c
      else
        if (mod(dlen, real(yrlen)) .lt. 0.01) then
c
c         calendar uses equal years and data is an integral number of these
c         years.  interpolation data is consistent.
c       
        elseif (mod(dlen, real(yrlen)) - 0.2425*nint(dlen/yrlen)
     &          .le. 0.01) then
c
c         calendar uses equal years, but data is leap year corrected.
c         subtract 1/4 day from feburary (or last record in feb if data is other
c         than monthly. eg: daily)
c     
          write (stdout, '(/,a,a)')
     &                     'Checkinterp: Modifying leap year corrected'
     &,                  ' interpolation data for use with equal years'
          febdone = .false.
	  time    = 0.0
          do m=1,ntdrec
	    time = time + aprec(m)
	    if (time .ge. yrlen + 0.2425) then
	      time = time - yrlen - 0.2425
	      febdone = .false.
	    endif
	    if (time .ge. msum(3)+0.2425) then
	      if (.not. febdone) then
	        aprec(m)   = aprec(m) - 0.2425
                write (stdout, '(a,i4)')
     &           'Checkinterp: Subtracting 0.2425 days from record ',m
	        febdone = .true.
	      endif
	    endif
	  enddo
          sum = tdrec(1) - 0.5*aprec(1)
          do m=1,ntdrec
            sum = sum + aprec(m)
            tdrec(m) = sum - 0.5*aprec(m)
c	    print *,' m=',m,' tdrec=',tdrec(m), ' aprec=',aprec(m)
          enddo
c	  
        else
c
c         calendar has equal years but data is neither leap year
c         compensated nor an exact number of years, it is not clear
c         what user wants.
c
          write (stdout,*) 'Problem in checkinterp'
	  write (stdout,*) 'Calendar uses equal years, but interpolation'
     &,	     ' data is neither an integer number of years or leap year'
     &,		   ' corrected by adding 0.2425 days per year.'
          stop
c
        endif          
c
      endif
      return
      end



c
c=======================================================================
c
c                           Timing Module
c 
c     This module contains as set of general purpose timing routines
c     which are useful in timing sections of code.
c
c     If compiled with the option -Dtiming, the timers are active.
c     If -Dtiming is not selected, all subroutines are null routines
c     and calls to them need not be removed from source code.
c
c     Timers are organized by group name and subgroup name, both
c     character strings.  For each group timer and subtimers, summary
c     statistics are printed showing total time, number of calls,
c     average time per call, percent of group time, and percent of total
c     time that this timer was active.
c
c     A timer is turned on by a call to the subroutine "tic" and turned
c     off by a call to the subroutine "toc".
c
c          call tic ('group name', 'subgroup name')
c          ...code to be timed....
c          call toc ('group name', 'subgroup name')
c
c     A subroutine "ticr" is provided to resume a previous call to "tic"
c     without increasing the number of calls statistic.  This is useful
c     for timing a part of the code that is separated by some untimed
c     code.
c
c          call tic ('group name', 'subgroup name')
c          ...first part of code....
c          call toc ('group name', 'subgroup name')
c          ...untimed code...
c          call ticr ('group name', 'subgroup name')
c          ...second part of code....
c          call toc ('group name', 'subgroup name')
c
c     Times are cpu times from a call to "tic" to its matched call to
c     "toc".  The function "second" provides the raw cpu times.  If a
c     subroutine call occurs in a section of code being timed, the
c     entire execution time of the subroutine will be included (unless
c     it contains a call to "toc" that timer).
c
c     Any number of timers from different groups may be simultaneously
c     active, and they may be "tic"-ed or "toc"-ed independently.
c     Within a group, at most one timer is active at any time.  If a
c     second timer from the group is "tic"-ed, the first is 
c     automatically "toc"-ed and pushed on a stack for that group.
c     The "tic" time for the second timer is precisely the "toc" time
c     for the first. When the second timer is "toc"-ed, the first timer
c     is popped from the stack and resumed at precisely the time the
c     second is "toc"-ed.
c
c          subroutine sub_name
c            call tic ('sub_name', 'miscellaneous')
c            ...miscellaneous subroutine code...
c            call tic ('sub_name', 'subgroup a')
c              call sub_a  (x, y, z)
c            call toc ('sub_name', 'subgroup a')
c            ...more miscellaneous code...
c            call tic ('sub_name', 'subgroup b')
c              call sub_b  (u, v, w)
c            call toc ('sub_name', 'subgroup b')
c            ...still more miscellaneous code...
c            call toc ('sub_name', 'miscellaneous')
c            return
c            end
c
c   The ('sub_name', 'miscellaneous') timer captures all the time of the
c   subroutine sub_name not specifically timed by the timers ('sub_name',
c   'subgroup a') and ('sub_name', 'subgroup b').
c
c   WARNINGS are issued for improper nesting of "tic" and "toc" up to
c   a maximum of max_timer_warnings (in timer.h).  Many improper nesting
c   problems are handled gracefully and the timings may still be useful.
c   Individual WARNING messages indicate the corrective action taken in
c   each case.
c
c   Total time for the run is timed from the call to "inittimers",
c   normally one of the first executable statements of the run, until
c   the call to "showtimers", normally one of the last executable
c   statements of the run.
c
c   Accuracy of the timings depends on the precision of the Fortran
c   readable clock accessed by the function "second".  On machines where
c   the clock returns only integer seconds, the preprocessor (cpp)
c   variable "real_seconds" is turned off, and raw, unadjusted timings
c   that include the overhead of the calls to "tic" and "toc" are
c   printed by "showtimers".  The overhead is relatively small for
c   unnested "tic"-"toc" pairs or innermost nested "tic"-"toc" pairs,
c   but will be somewhat higher for timed that code that itself contains
c   calls to "tic" and "toc".  Also bear in mind that the timing for
c   each individual "tic"-"toc" pair may be in error by a full second
c   because of the limited precision of the clock.  On such machines,
c   it may be necessary to artificially repeat the calculation between
c   "tic" and "toc" to get times long enough that the uncertainty of
c   one second is not significant.
c
c   If greater precision is available to the function "second", the
c   preprocessor variable "real_seconds" is defined, and times shown by
c   "showtimers" are adjusted times, with elaborate compensations made
c   for the cpu time spent in various portions of "tic" and "toc".
c   Calibration loops are executed and timed in both "inittimers" and
c   in "showtimers" to compensate both for combinations of timers within
c   timers and for the increased search time as the list of timer group
c   names and subgroup names grows.  Although in heavily instrumented
c   code, the time spent in "tic" and "toc" may be a third of the total
c   cpu time, experience on the Cray ymp has shown these adjusted times
c   to be quite reliable and accurate.  For your information, the time
c   per "tic"-"toc" pair is also printed by "showtimers", as are
c   warnings about "tic"-ed timers still not "toc"-ed by the end of the
c   run.
c
c     author:      c. h. goldberg      e-mail=> chg@gfdl.gov
c=======================================================================
c




c#define debug_timer
c#define show_tictocs

c     #define show_tictocs  shows all calls to tic, toc, and ticr
c            and all implied tic/tocs arising from time push/pops

c real_seconds is defined if the cpu clock shows milliseconds or better






      function second()
c
c=======================================================================
c     read a system clock and return a time in real seconds
c
c     author:     please supply your system clock function here
c=======================================================================
c
      print *,' '
      print *,' Please supply your system clock function in "timer.F"'
      print *,' under "fuction second()"'
      print *,' '
      second = 0.0
      return
      end




c=======================================================================
c
c               T I M E      M A N A G E R   M O D U L E
c
c     The time manager does three basic things for the model
c           1) It contains subroutines to keep, manipulate, and convert
c              all times for the model in internal representations in
c              arrays in "tmngr.h"
c           2) Subroutine increment_time updates times using the chosen
c              time step "dt" and calendar type without any roundoff or
c              drift for arbitrarily long integrations, even when using
c              32 bit arithmetic.
c           3) Subroutine set_time_switches sets switches in "switch.h"
c              that trigger periodically recurring events in the model
c              such as diagnostics and end-of-run.
c
c     Times are kept internal to the time manager in the primary form
c     of integer days (in the array "iday") and nonnegative integer
c     milliseconds in a fractional day (in the array "msday").  A unique 
c     subscript for each time accesses all the arrays.  (See "tmngr.h"
c     for a list of predeclared time subscripts.) 
c
c     Times that have a calendar reference are called "full times"
c     because in addition to the primary time fields "iday" and
c     "msday", they also have integer secondary time fields "year",
c     "month", "day", "hour", "minute", and "second", and a 32
c     character time stamp, "tstamp", in the form written and read
c     by the model. They also have tertiary fields "dayofyear",
c     "dayofweek", "daysinmon", and "daysinyear".  For such times,
c     the primary fields "iday" and "msday" represent days and
c     fractional days since the calendar base, (0,0) =
c     December 31, 1899 at the start of the day, 00:00:00.
c
c     For differences of two calendar times, the secondary calendar
c     fields make no sense, so these times are kept as "short times"
c     with only the two primary fields "iday" and "msday".
c
c     tmngr can keep track of time using either
c           a) a leap-year corrected Gregorian calendar
c           b) a constant 365-day year calendar
c           c) a constant month calendar, 12 months/year, with an
c              arbitrary number of days per month
c
c     Although the model does not currently use this feature, the
c     subroutine "tmngr" is designed to handle time increments, "dt",
c     varying at every time step.
c
c     Currently implemented switches include end-of-day, end-of-
c     week, end-of-two-weeks, end-of-month, end-of-year, end-of-
c     run, mid-month, and switches active at prespecified intervals
c     from either start of run, initial conditions, or any other
c     reference time the user chooses.  It is relatively
c     easy to add additional switches by following the models of
c     switches already provided.
c
c     Finally, this module provides a collection of utility 
c     subroutines to perform arithmetic on the internal representations
c     of time, to convert between primary and secondary internal
c     representations, and between internal representations and
c     external representations such as real seconds or real days or
c     calendar year, month, day, hour, minute, and second.     
c     The user who needs to work with time quantities, say to 
c     write time stamps on a data set prepared by a user-written
c     program, might find some of them useful.
c
c     authors: c. h. goldberg         chg@gfdl.gov 
c              d. j. goldberg
c             (an improved version (to eliminate roundoff) of the time 
c              manager written by r.c. pacanowski and k. dixon)
c           
c=======================================================================
c











      subroutine tmngri (icyear, icmonth, icday, ichour, icmin, icsec
     &,                     rfyear, rfmonth, rfday, rfhour, rfmin, rfsec
     &,                     idayrestart, msrestart
     &,                     runlen0, rununits0, rundays0, timestep)
c
c=======================================================================
c     initialize internal time variables and enter initial values
c     for externally defined times (initial conditions, user reference
c     and model time at start of run).
c
c     author: c. h. goldberg         chg@gfdl.gov 
c=======================================================================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c====================== include file "switch.h" ========================
c
c     all time dependent decisions are made by time manager "tmngr.F"
c     and communicated elsewhere to the model via logical switches.
c
c     inputs: (defaulted in "blkdta.F", optionally reset via namelist)
c
c
c     runlen  = integration period (see rununits). note "runlen" should
c               be an integral number of density time steps. if not,
c               then "runlen" is automatically adjusted to insure this.
c               fractional days are supported but not fractional months
c               or years.
c     rununits= units of "runlen". may be "days", "months", or "years".
c               tmngr will convert "runlen" which is in "rununits"
c               to "rundays" in units of days.
c
c     segtim  = the integration time "runlen" is broken into a number of
c               segments each of length "segtim" days. updated surface
c               boundary conditions are applied to MOM every "segtim" 
c               days. this is useful when coupling to atmospheric models
c               in which case both models exchange surface boundary
c               conditions every "segtim" days where "segtim"
c               is 1/(coupling frequency). without an atmospheric model,
c               when getting surface boundary conditions from data, 
c               "segtim" is set to the time step (in days) by mom.F. in
c               either case, "runlen" (in days) should be an integral
c               number of "segtim".     
c
c     nmix    = number of time steps between mixing timesteps. used
c               to damp timestep splitting due to centered leapfrog.
c
c     init    = (true,false)  indicates that this run is a
c               (start from initial conditions, restart)
c
c     restrt  = (true,false) = (do,don`t) write a restart at the end
c               of the run
c
c     eb      = (true,false) configures for the use of a 
c               (euler backward,forward) type mixing timestep
c
c-----------------------------------------------------------------------
c     inputs to tmngr.F: diagnostic intervals
c-----------------------------------------------------------------------
c
c     note: switches are used to control the interval between doing
c           diagnostics. units for all switches are in days. 
c           setting a switch < 0.0 disables whatever the switch is 
c           controlling. setting it = 0.0 causes the diagnostic to be 
c           done every time step, and setting it > 0.0 causes the 
c           diagnostic to be done repeatedly on the specified interval. 
c
c     cmixint = number of days between writing estimated mixing coeffs
c               on faces of T cells and U cells
c
c     crossint = number of days between writing diapycnal and isopycnal
c               components of flow
c
c     fctint = number of days between writing difference between 
c              FCT and leapfrog advection
c
c     densityint = number of days between writing density
c
c     exconvint = number of days between writing temperature rate of
c                 change due to explicit convection
c
c     glenint =  number of days between global energetics integrals.
c
c     trmbint =  number of days between momentum and tracer term
c                balances (global and regional).
c
c     itrmb   = (true,false) = (do,don`t) write regional mask info for
c               the term balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     gyreint =  number of days between calculation of tracer northward
c                transport.
c     igyre   = (true,false) = (do,don`t) write regional mask info for
c               the gyre diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     vmsfint =  number of days between calculation of vertical and
c                meridional stream function.
c
c     tyzint  =  number of days between calculation of zonally averaged
c                tracer components.
c
c     prxzint =  number of days between printouts of x-z data.
c
c     extint  =  number of days between printouts of external mode.
c
c     dspint  =  number of days between surface pressure calculation.
c                Note: only when "diagnostic_surface_height" is enabled.
c     dspper  = averaging period for "diagnostic_surface_height"
c
c     tavgint = number of days between regional tracer averages (under
c               horizontal regions).
c
c     itavg   = (true,false) = (do,don`t) write regional mask info for
c               the tracer average diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     tmbint  = number of days over which tracer equation in averaged
c               in depth and longitude to determine the meridional 
c               balance among storage, divergence, dissipation and 
c               forcing.
c     tmbper  = averaging period for "meridional_tracer_balance"
c
c     itmb    = (true,false) = (do,don`t) write "msktmb" for tracer
c               the meridional balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c
c     tsiint  = number of days between printing of time step integrals.
c
c     stabint = number of days between sampling for various stability
c               criteria.
c
c     snapint = number of days between writing instantaneous samples
c               of data from the MOM grid. note: only when "snapshots"
c               is enabled. see "iounit.h" for more details.
c               all data is at time level "tau" so it is one time step
c               before the date shown in "stamp".
c
c     timavgint= interval (days) for writing time mean data from
c               the "averaging" grid (only when "time_averages" is
c               enabled). if "timavgint" is not an integral number of
c               density time steps,"timavgint" is automatically adjusted
c               to insure this. if the number of days to integrate is
c               not an integral number of "timavgint" then the last
c               averaging period will be less than "timavgint" days.this 
c               may lead to one more averaging period than expected. 
c               see "iounit.h" for more details.
c     timavgper= averaging period for "time_averages"
c
c     xbtint  = averaging period (days) for writing XBT data (only when
c               "xbts" is enabled). if "xbtint" is not an integral
c               number of density time steps, "xbtint" is automatically
c               adjusted to insure this. if the number of days to 
c               integrate is not an integral number of "xbtint" then the
c               last averaging period will be less than "xbtint" days.
c               this may lead to one more averaging period than  
c               expected. see "iounit.h" for more details.
c     xbtper  = averaging period for "xbts"
c
c     zmbcint = number of days between calculation of zonal mean
c               surface boundary conditions (and related  quantities)
c
c     trajint = number of days between writing particle trajectories.
c               particle trajectories are always written on the last
c               time step of the run to allow for restarting.
c
c-----------------------------------------------------------------------
c     outputs from tmngr.F: logical switches
c-----------------------------------------------------------------------
c
c     rundays = integration time in days (from "runlen")
c
c     the following are logical counterparts to the above switches are 
c     set within "tmngr" every time step. logical switches control all
c     decisions about when to do things in MOM.
c
c     cmixts  = (false,true) = (don`t, do) do write estimated mixing
c               coefficients on this time step.
c               based on "cmixint".
c
c     crossts  = (false,true) = (don`t, do) write diapycnal and 
c               isopycnal components of flow on this time step.
c               based on "crossint".
c
c     fctts    = (false,true) = (don`t, do) write difference between 
c               FCT and leapfrog advection on this time step.
c               based on "fctint".
c
c     densityts  = (false,true) = (don`t, do) write density on this time
c               step. based on "densityint".
c               
c
c     exconvts  = (false,true) = (don`t, do) do write temperature change
c               due to explicit convection on this time step.
c               based on "exconvint".
c
c     glents  = (false,true) = (don`t, do) do calculation of global
c               energy integrals on this time step. based on "glenint".
c
c     trmbts  = (false,true) = (don`t, do) do calculation of momentum &
c               tracer term balance on this timestep. based on "trmbint"
c
c     gyrets  = (false,true) = (don`t, do) do calculation of tracer
c               northward transport on this timestep. based on "gyreint"
c
c     vmsfts  = (false,true) = (don`t, do) do calculation of vertical
c               and meridional stream function on this time step.
c               based on "vmsfint"
c
c     tyzts   = (false,true) = (don`t, do) do calculation of zonally
c               averaged tracer components on this time step.
c               based on "tyzint"
c
c     prxzts  = (false,true) = (don`t, do) do printouts of x-z data
c               on this time step. based on "prxzint"
c
c     extts  = (false,true) = (don`t, do) do printout of external mode
c               on this time step. based on "extint"
c
c     dspts  = (false,true) = (don`t, do) do calculation of diagnostic 
c              surface pressure on this time step. based on "dspint"
c               
c
c     stabts  = (false,true) = (don`t, do) test for stability on this
c               time step. based on "stabint"
c
c     tavgts  = (false,true) = (don`t do) do tracer averages on this
c               time step. based on "tavgint"
c
c     tmbts   = (false,true) = (don`t, do) write out tracer meridional .
c               balance on this time step. based on "tmbint"
c
c     tsits   = (false,true) = (don`t, do) print time step integrals
c               on this time step. based on "tsiint"
c
c     zmbcts  = (false,true) = (don`t, do) print zonal mean boundary
c               conditions on this time step.  based on "zmbcint"
c
c     trajts  = (false,true) = (don`t, do) print particle trajectories
c               on this time step. based on "trajint"
c
c     snapts  = (false,true) = (don`t, do) save a snapshot of the data
c               on this time step. based on "snapint"
c
c     timats  = (false,true) = (don`t, do) write time mean data
c               on this time step. based on "timavgint"
c                                          
c     xbtts   = (false,true) = (don`t, do) write averaged XBT data on
c               this time step based on "xbtint"
c
c
c     leapfrog= (false,true) on a (mixing, normal leapfrog) time step
c                based on "nmix"
c                                          
c     euler1  = true on the 1st pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     euler2  = true on the 2nd pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     forward = true on a forward time step. otherwise false
c		(applies when "eb" = false)		  
c                                          
c
c     the following logical switches are based on the model time step. 
c    
c     first   = (true,false) =  when it`s (the first, not the first)
c                               time step of a run
c     eots    = end of a time step. always true except for first
c               pass of an euler backward time step
c     eorun   = last time step of a run. always false except during the
c               last time step of the run.
c
c     eoday   = true when within 1/2 time step of the end of a day
c               else ... false
c     eoweek  = true when within 1/2 time step of the end of a 7 day
c               week (referenced to the start of a year) else ...false
c     eo2wks  = true when within 1/2 time step of the end of two weeks
c               (referenced to the start of a year) else ... false
c     midmon  = true when within 1/2 time step of the middle of a month
c               else ... false
c     eomon   = true when within 1/2 time step of the end of a month
c               else ... false
c     eoyear  = true when within 1/2 time step of the end of a year
c               else ... false
c     osegs   = true on the 1st time step of an ocean segment in mom.F
c               otherwise false.
c     osege  =  true on the last time step of an ocean segment in mom.F
c               otherwise false.
c
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c
c
      logical eb, leapfrog, euler1, euler2, forward, eots
      logical init, first, restrt
      logical itavg, itmb, itrmb, igyre
      character *8 rununits
c
      common /switcc/ rununits
      common /switcr/ runlen, rundays
      common /switci/ nmix
      common /switcl/ eb, leapfrog, euler1, euler2, forward, eots
      common /switcl/ init, first, restrt
      common /switcl/ itavg, itmb, itrmb, igyre
c
      logical          eoday, eoweek, eo2wks
      common /switci/ ieoday,ieoweek,ieo2wks
      common /switcl/  eoday, eoweek, eo2wks
c
      logical          eomon, midmon, eoyear, eorun
      common /switci/ ieomon,imidmon,ieoyear,ieorun
      common /switcl/  eomon, midmon, eoyear, eorun
c
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c     each interval switch needs three variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output (e.g,.  glenint)
c         2) a switch (logical) for the interval (e.g.,  glents )
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c         3) an index (integer)                       (e.g., iglenint)
c
c     the user must specify the interval [e.g., glenint] for diagnostic
c     output in units of days. tmngr sets the corresponding logical  
c     switch [e.g., glents] every time step. It is set to true when  
c     within half a time step of the requested interval, otherwise it is
c     false. All decisions relating to the interval [e.g., glenint]
c     are based on the logical switch [e.g., glents].
c           
c     internal time structures
c
c     The switch index [e.g., iglenint] is used to subsrcipt into  
c     internal arrays maintained by tmngr.F. The switch index is
c     allocated on the first call to function "alarm".
c     The array entry [e.g., iinterval(iglenint)] is a time index to the
c     internal representation of the interval [e.g., glenint].
c     The array entry [e.g., ialarm(iglenint)] is a time index to the
c     next time the alarm will be true.
c-----------------------------------------------------------------------
c
      logical           tavgts,    glents,    trmbts,   prxzts
      common /switcr/   tavgint,   glenint,   trmbint,  prxzint
      common /switci/  itavgint,  iglenint,  itrmbint, iprxzint
      common /switcl/   tavgts,    glents,    trmbts,   prxzts
c
      logical          extts,   trajts,   exconvts,   cmixts
      common /switcr/  extint,  trajint,  exconvint,  cmixint
      common /switci/ iextint, itrajint, iexconvint, icmixint
      common /switcl/  extts,   trajts,   exconvts,   cmixts
c
      logical          vmsfts,   gyrets,    tsits,   snapts,   fctts
      common /switcr/  vmsfint,  gyreint,   tsiint,  snapint,  fctint
      common /switci/ ivmsfint, igyreint,  itsiint, isnapint, ifctint
      common /switcl/  vmsfts,   gyrets,    tsits,   snapts,   fctts
c
      logical          tyzts
      common /switcr/  tyzint
      common /switci/ ityzint
      common /switcl/  tyzts
c
      logical          stabts,   zmbcts,   crossts,   densityts
      common /switcr/  stabint,  zmbcint,  crossint,  densityint
      common /switci/ istabint, izmbcint, icrossint, idensityint
      common /switcl/  stabts,   zmbcts,   crossts,   densityts
c
      logical          osegs,  osege
      common /switcr/          segtim
      common /switci/ iosegs, iosege
      common /switcl/  osegs,  osege
c   
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c              A N D   A V E R A G I N G   P E R I O D
c
c     each averaging period switch needs five variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output    (e.g. xbtint  )   
c         2) a switch (logical) for the interval         (e.g. xbtts   )
c         3) an averaging period (real)                  (e.g. xbtper  )   
c         4) a switch (logical) for accumulating         (e.g. xbtperts)
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switches
c
c         5) an index (integer)                         (e.g. ixbtint  )
c
c     The user must specify the interval [e.g., xbtint] for diagnostic
c     output in units of days and the averaging period [e.g., xbtper] 
c     in units of days. The averaging period may be less than or equal
c     to the interval. For example, if the interval is 30.0 days and the
c     averaging period is 5.0 days, results will be averaged over all
c     time steps within days 26, 27, 28, 29, and 30.  An averaging period
c     of 0.0 days averages over the last time step of the interval (as
c     does xbtper = dt), and an averaging period less than zero turns
c     the switches off for all time steps.  
c
c     The logical switch for writing output at the specified interval 
c     [e.g., xbtts] is set to true on the last time step of the 
c     averaging period. The logical switch for accumulating results
c     [e.g., xbtperts] is true for all time steps within the averaging
c     period, otherwise it is false. 
c
c     internal time structures
c
c     The index [e.g., ixbtint] is allocated on the first call to 
c     function "avg_alarm". The array element iperiod(ixbtint) is an
c     index to the time structure for the internal representation of 
c     "xbtper", and ilastsw(ixbtint) is the index of the switch that 
c     flags the last time step of the accumulation period.
c     Depending on use,  ilastsw(ixbtint) may either be the index
c     of another "named" switch or the index of a new switch
c     allocated on the first time step.
c     In the latter case, iinterval(ilastsw(ixbtint)) is the index of
c     the time structure where "xbtint" is stored in internal form,
c     and ialarm(ilastsw(ixbtint)) is the index of the time when an
c     accumulation period will next end.
c     The variable nextts(ixbtint) is true whenever the next
c     time step will begin the accumulation period.
c
c-----------------------------------------------------------------------
c
      logical         xbtts,     dspts,    tmbts,    timavgts
      logical         xbtperts,  dspperts, tmbperts, timavgperts
      common /switcr/ xbtint,    dspint,   tmbint,   timavgint
      common /switcr/ xbtper,    dspper,   tmbper,   timavgper
      common /switci/ixbtint,   idspint,  itmbint,  itimavgint
      common /switcl/ xbtts,     dspts,    tmbts,    timavgts
      common /switcl/ xbtperts,  dspperts, tmbperts, timavgperts
c
c-----------------------------------------------------------------------
c
c                 S W I T C H E S    B A S E D    O N    
c
c         C A L E N D A R   O R    P R E V I O U S    S W I T C H   
c
c               A N D   A V E R A G I N G    P E R I O D
c
c    
c
c     the following logical switches are based on any calendar or 
c     interval switch and an averaging period (in days). The  averaging
c     period must be less than or equal to the interval. The last
c     time step of the averaging period is at the end of the interval.
c     If the averaging period is set to zero, the averaging period
c     consists only of the last time period of the interval.  If
c     the averaging period is less than zero, these switches are always
c     false.
c
c     each averaging period switch needs four variables in common. For
c     example, if the averaging period is before the end of each month
c     then the calendar switch (eomon), and index (ieomon) are presumed
c     to exist in common and need not be added.
c     
c     Additionally, four items are needed.
c
c       1) an averaging period (real)                  (e.g.  testper  )   
c       2) a switch (logical) for accumulating results (e.g.  testperts)
c       3) a switch (logical) for the end of interval  (e.g.  testts   )
c
c     the fourth is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c       4) an index (integer)                          (e.g.  itestper )
c
c     Suppose it is required to produce averages over all time steps
c     during the last 5 days of each month. Then "testper" = 5.0 and 
c     the following will calculate the accumulating switch.
c
c      testts = avg_alarm(itestper, ihalfstep, 0, testper, iref, ieomon)
c      testperts = on(itestper)
c
c     Note the use of "ieomon" to key off the months.  The switch
c     "testts" will be true whenever "eomon" is true.
c     Also note that when an averaging switch is keyed off another
c     switch, the switch inverval argument is not used, but is 
c     retained for consistency with the form of other averaging
c     switches.
c-----------------------------------------------------------------------
c
      logical           testperts
      logical           testts
      common /switcr/   testint
      common /switcr/   testper
      common /switci/  itestper
      common /switcl/   testts
      common /switcl/   testperts

c
      parameter (maxsw=100)
      logical          on, lastts, nextts
      common /switci/  nsw  
      common /switci/  ialarm(maxsw), iinterval(maxsw), iperiod(maxsw)
     &,                ilastsw(maxsw)
      common /switcl/  on(maxsw), lastts(maxsw), nextts(maxsw)
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c

c======================= include file "calendar.h"======================
c
c                       calendar specification arrays
c
c-----------------------------------------------------------------------
c
c     eqyear = true to select a calendar in which each year
c              has the same number of days (i.e., no leap years)
c              false selects a julian calendar
c
c     eqmon  = true to force all months to have the same number of days
c              false => the usual 31, 28, 31, 30, ..., days per month. 
c              only used when eqyear = true 
c
c     dayname = character names of days
c
c     monname = character names of months
c
c     monlen = the length of each month (in days) when eqmon is true
c
c     yrlen  = the length of a typical (non-leap) year in days
c
c     daypm  = array of month lengths in days   (non-leap)
c
c     msum   = array of cumulative days preceding each month
c              (again, non-leap)
c
c-----------------------------------------------------------------------
      logical eqyear, eqmon
      integer daypm, msum, yrlen, monlen
c
      character*10 dayname
      character*12 monname
c
      common /calenc/ dayname(7), monname(12)
      common /calenl/ eqyear, eqmon
      common /caleni/ daypm(12), msum(12), yrlen, monlen


      character*(*) rununits0
c
      integer icyear, icmonth, icday, ichour, icmin, icsec
      integer rfyear, rfmonth, rfday, rfhour, rfmin, rfsec
      integer idayrestart, msrestart
      logical error, timeless
c
      write (stdout,'(//,10x,a,/)') 'Time manager initialization'
c
      call inittime
      call initswitch
      first = .true.
      error = .false.
      call calendari (eqyear, eqmon, monlen,
     &            yrlen, daypm, msum, dayname, monname, error)
      if (error) then
        stop 'badcal'
      end if
c
c-----------------------------------------------------------------------
c     enter and print initial date and time and check bounds.
c-----------------------------------------------------------------------
c
      call getfulltime (initial)
      call setfulltime (initial, icyear, icmonth, icday, ichour, icmin
     &,                 icsec)
      write (stdout,9000) 'Initial Conditions: ', tstamp(initial)
      write (stdout,*) ' '
      call ckdate (initial, error)
      if (error) then
        stop '=>tmngri'
      end if
c
c----------------------------------------------------------------------
c     set model time counter.  
c----------------------------------------------------------------------
c
      call gettime  (imodeltime)
      call settime2 (imodeltime, idayrestart, msrestart)
      write (stdout,'(a,1pg14.7,a/)') 
     & '  Time since initial conditions =',
     & realdays(imodeltime), ' days'
c
c----------------------------------------------------------------------
c     calculate y/m/d and h/m/s of start of run.
c----------------------------------------------------------------------
c
      call getfulltime (irunstart)
      call addtime (initial, imodeltime, irunstart)
      call expandtime2 (irunstart)
      call getfulltime (itime)
      call copyfulltime (irunstart, itime)
      stamp = tstamp(itime)
      pstamp = stamp
c
c-----------------------------------------------------------------------
c     calculate real output quantities:
c       relyr  = years of model time since initial conditions
c       dayoyr = days since start of current year
c-----------------------------------------------------------------------
c
      dayoyr = dayofyear(itime) - 1 + (msday(itime)/86400000.0)
      relyr  = year(itime) - year(initial) + dayoyr/daysinyear(itime) -
     &         (dayofyear(initial) - 1 + (msday(initial)/86400000.0))/
     &         daysinyear(initial)
      prelyr = relyr
c

      write (stdout,9000) 'Start of Run: ', tstamp(irunstart)
      write (stdout,'(a,i10/)') 'Corresponding to time step "itt" =',itt
c
c----------------------------------------------------------------------
c       select reference time for computing diagnostic switches
c----------------------------------------------------------------------
c
      irefs = 0
      call getfulltime (iref)
      if (refrun) then
        irefs = irefs + 1
        write (stdout,*)
     &  ' "refrun = .true." selected.'
        write (stdout,'(a,a)')
     &  '  intervals for diagnostic switches are referenced to ',
     &  '  the beginning of each run.'
        call copyfulltime (irunstart, iref)
      endif
      if (refinit) then
        irefs = irefs + 1
        write (stdout,*)
     &  ' "refinit = .true." selected.'
        write (stdout,'(a,a)')
     &  '  intervals for diagnostic switches are referenced to ',
     &  '  the initial conditions time.'
        call copyfulltime (initial, iref)
      endif
      if (refuser) then
        irefs = irefs + 1
        write (stdout,*)
     &  ' "refuser = .true." selected.'
        write (stdout,'(a,a)')
     &  '  intervals for diagnostic switches are referenced to ',
     &  '  user specified date and time.'
        call getfulltime (iuser)
        call setfulltime (iuser, rfyear, rfmonth, rfday, rfhour, rfmin
     &,                   rfsec)
        call ckdate (iuser, error)
        if (error) then
          stop '=>tmngri'
        endif
        write (stdout,9000) '    Reference time:     ', tstamp(iuser)
        write (stdout,*) ' '
        call copyfulltime (iuser, iref)
      endif
c
      if (irefs .ne. 1) then
        write (stdout, *) 'You must choose exactly one of the'
     &  // ' options: refrun, refinit, or refuser.'
        stop '=>tmngr'
      endif
c
      call gettime (idt)
      call gettime (idtd2)
      call gettime (iusertime)
      call gettime (ireftime)
      call gettime (iruntime)
      call gettime (ihalfstep)
c
      call getfulltime (itemptime)
      call getfulltime (itemptime2)
      call gettime (itmptime)
      call gettime (itmptime2)
      call gettime (itmptime3)
c
c-----------------------------------------------------------------------
c     set a reference to Sunday Jan 0, 1900, 0:00:00, the base date
c     or earier if necessary.
c-----------------------------------------------------------------------
c
      call gettime  (isunday)
      call settime2 (isunday, 0, 0)
      if (timeless (initial, isunday)) then
        iday(isunday) = 14*int(iday(initial)/14) - 14
      end if
c
c-----------------------------------------------------------------------
c     initialize idt as "timestep" rounded to the nearest millisecond
c-----------------------------------------------------------------------
c
      iddt = id (timestep)
      msdt = msec (timestep)
      call settime2 (idt, iddt, msdt)
c
      call set_eorun (runlen0, rununits0, rundays0)
c
      write (stdout,'(/,10x,a,//)') 'Initialization completed'
c
9000  format (a,a)
      return
      end





      subroutine increment_time (dt)
c
c=======================================================================
c
c               I N C R E M E N T   T I M E
c
c     increment_time keeps track of model time using either
c           a) leap-year corrected Gregorian calendar
c           b) constant 365-day year calendar
c           c) constant month calendar, 12 months/year, arbitrary
c              number of days per month
c
c     date and time are accurate to within one millisecond for arbitrary
c     length time steps (even on computers with 32 bit word lengths!).
c
c               julian base = Jan 0, 1900 at 00:00:00
c
c       For accuracy, all fundamental times are kept
c       in the form:  integer days (with Jan 1, 1900=1)
c                     non-negative integer milliseconds within the day
c
c     input:
c
c       dt     = length of time step in seconds. (need not be constant)
c
c     outputs:
c
c       dt     = dt rounded to nearest millisec if needed
c
c       updated time fields: year, month, day, hour, minute, second,
c                            tstamp, dayofyear, dayofweek, daysinmonth,
c                            daysinyear
c       times updated:
c         itime  = "absolute" (y/m/d...) time after adding dt
c         ihalfstep = dt/2 beyond itime
c         imodeltime = time since initial conditions
c
c       stamp   = 32 character time stamp (m/d/y h:m:s)
c       pstamp  = stamp returned in previous call to increment_time
c
c       relyr  = model time in years since initial conditions
c       dayoyr = days + fractional days since start of calendar year
c
c     authors: c. h. goldberg        chg@gfdl.gov
c              d. j. goldberg
c             (an improved version (to eliminate roundoff) of the time 
c              manager written by r.c. pacanowski and k. dixon)
c           
c=======================================================================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c

c====================== include file "switch.h" ========================
c
c     all time dependent decisions are made by time manager "tmngr.F"
c     and communicated elsewhere to the model via logical switches.
c
c     inputs: (defaulted in "blkdta.F", optionally reset via namelist)
c
c
c     runlen  = integration period (see rununits). note "runlen" should
c               be an integral number of density time steps. if not,
c               then "runlen" is automatically adjusted to insure this.
c               fractional days are supported but not fractional months
c               or years.
c     rununits= units of "runlen". may be "days", "months", or "years".
c               tmngr will convert "runlen" which is in "rununits"
c               to "rundays" in units of days.
c
c     segtim  = the integration time "runlen" is broken into a number of
c               segments each of length "segtim" days. updated surface
c               boundary conditions are applied to MOM every "segtim" 
c               days. this is useful when coupling to atmospheric models
c               in which case both models exchange surface boundary
c               conditions every "segtim" days where "segtim"
c               is 1/(coupling frequency). without an atmospheric model,
c               when getting surface boundary conditions from data, 
c               "segtim" is set to the time step (in days) by mom.F. in
c               either case, "runlen" (in days) should be an integral
c               number of "segtim".     
c
c     nmix    = number of time steps between mixing timesteps. used
c               to damp timestep splitting due to centered leapfrog.
c
c     init    = (true,false)  indicates that this run is a
c               (start from initial conditions, restart)
c
c     restrt  = (true,false) = (do,don`t) write a restart at the end
c               of the run
c
c     eb      = (true,false) configures for the use of a 
c               (euler backward,forward) type mixing timestep
c
c-----------------------------------------------------------------------
c     inputs to tmngr.F: diagnostic intervals
c-----------------------------------------------------------------------
c
c     note: switches are used to control the interval between doing
c           diagnostics. units for all switches are in days. 
c           setting a switch < 0.0 disables whatever the switch is 
c           controlling. setting it = 0.0 causes the diagnostic to be 
c           done every time step, and setting it > 0.0 causes the 
c           diagnostic to be done repeatedly on the specified interval. 
c
c     cmixint = number of days between writing estimated mixing coeffs
c               on faces of T cells and U cells
c
c     crossint = number of days between writing diapycnal and isopycnal
c               components of flow
c
c     fctint = number of days between writing difference between 
c              FCT and leapfrog advection
c
c     densityint = number of days between writing density
c
c     exconvint = number of days between writing temperature rate of
c                 change due to explicit convection
c
c     glenint =  number of days between global energetics integrals.
c
c     trmbint =  number of days between momentum and tracer term
c                balances (global and regional).
c
c     itrmb   = (true,false) = (do,don`t) write regional mask info for
c               the term balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     gyreint =  number of days between calculation of tracer northward
c                transport.
c     igyre   = (true,false) = (do,don`t) write regional mask info for
c               the gyre diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     vmsfint =  number of days between calculation of vertical and
c                meridional stream function.
c
c     tyzint  =  number of days between calculation of zonally averaged
c                tracer components.
c
c     prxzint =  number of days between printouts of x-z data.
c
c     extint  =  number of days between printouts of external mode.
c
c     dspint  =  number of days between surface pressure calculation.
c                Note: only when "diagnostic_surface_height" is enabled.
c     dspper  = averaging period for "diagnostic_surface_height"
c
c     tavgint = number of days between regional tracer averages (under
c               horizontal regions).
c
c     itavg   = (true,false) = (do,don`t) write regional mask info for
c               the tracer average diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c     tmbint  = number of days over which tracer equation in averaged
c               in depth and longitude to determine the meridional 
c               balance among storage, divergence, dissipation and 
c               forcing.
c     tmbper  = averaging period for "meridional_tracer_balance"
c
c     itmb    = (true,false) = (do,don`t) write "msktmb" for tracer
c               the meridional balance diagnostic. Typically set true
c               at the beginning of a run; otherwise false since it is
c               not necessary to keep writing a time independent field
c               particularly when it may be a significant part of the
c               time dependent part of the diagnostic.
c
c
c     tsiint  = number of days between printing of time step integrals.
c
c     stabint = number of days between sampling for various stability
c               criteria.
c
c     snapint = number of days between writing instantaneous samples
c               of data from the MOM grid. note: only when "snapshots"
c               is enabled. see "iounit.h" for more details.
c               all data is at time level "tau" so it is one time step
c               before the date shown in "stamp".
c
c     timavgint= interval (days) for writing time mean data from
c               the "averaging" grid (only when "time_averages" is
c               enabled). if "timavgint" is not an integral number of
c               density time steps,"timavgint" is automatically adjusted
c               to insure this. if the number of days to integrate is
c               not an integral number of "timavgint" then the last
c               averaging period will be less than "timavgint" days.this 
c               may lead to one more averaging period than expected. 
c               see "iounit.h" for more details.
c     timavgper= averaging period for "time_averages"
c
c     xbtint  = averaging period (days) for writing XBT data (only when
c               "xbts" is enabled). if "xbtint" is not an integral
c               number of density time steps, "xbtint" is automatically
c               adjusted to insure this. if the number of days to 
c               integrate is not an integral number of "xbtint" then the
c               last averaging period will be less than "xbtint" days.
c               this may lead to one more averaging period than  
c               expected. see "iounit.h" for more details.
c     xbtper  = averaging period for "xbts"
c
c     zmbcint = number of days between calculation of zonal mean
c               surface boundary conditions (and related  quantities)
c
c     trajint = number of days between writing particle trajectories.
c               particle trajectories are always written on the last
c               time step of the run to allow for restarting.
c
c-----------------------------------------------------------------------
c     outputs from tmngr.F: logical switches
c-----------------------------------------------------------------------
c
c     rundays = integration time in days (from "runlen")
c
c     the following are logical counterparts to the above switches are 
c     set within "tmngr" every time step. logical switches control all
c     decisions about when to do things in MOM.
c
c     cmixts  = (false,true) = (don`t, do) do write estimated mixing
c               coefficients on this time step.
c               based on "cmixint".
c
c     crossts  = (false,true) = (don`t, do) write diapycnal and 
c               isopycnal components of flow on this time step.
c               based on "crossint".
c
c     fctts    = (false,true) = (don`t, do) write difference between 
c               FCT and leapfrog advection on this time step.
c               based on "fctint".
c
c     densityts  = (false,true) = (don`t, do) write density on this time
c               step. based on "densityint".
c               
c
c     exconvts  = (false,true) = (don`t, do) do write temperature change
c               due to explicit convection on this time step.
c               based on "exconvint".
c
c     glents  = (false,true) = (don`t, do) do calculation of global
c               energy integrals on this time step. based on "glenint".
c
c     trmbts  = (false,true) = (don`t, do) do calculation of momentum &
c               tracer term balance on this timestep. based on "trmbint"
c
c     gyrets  = (false,true) = (don`t, do) do calculation of tracer
c               northward transport on this timestep. based on "gyreint"
c
c     vmsfts  = (false,true) = (don`t, do) do calculation of vertical
c               and meridional stream function on this time step.
c               based on "vmsfint"
c
c     tyzts   = (false,true) = (don`t, do) do calculation of zonally
c               averaged tracer components on this time step.
c               based on "tyzint"
c
c     prxzts  = (false,true) = (don`t, do) do printouts of x-z data
c               on this time step. based on "prxzint"
c
c     extts  = (false,true) = (don`t, do) do printout of external mode
c               on this time step. based on "extint"
c
c     dspts  = (false,true) = (don`t, do) do calculation of diagnostic 
c              surface pressure on this time step. based on "dspint"
c               
c
c     stabts  = (false,true) = (don`t, do) test for stability on this
c               time step. based on "stabint"
c
c     tavgts  = (false,true) = (don`t do) do tracer averages on this
c               time step. based on "tavgint"
c
c     tmbts   = (false,true) = (don`t, do) write out tracer meridional .
c               balance on this time step. based on "tmbint"
c
c     tsits   = (false,true) = (don`t, do) print time step integrals
c               on this time step. based on "tsiint"
c
c     zmbcts  = (false,true) = (don`t, do) print zonal mean boundary
c               conditions on this time step.  based on "zmbcint"
c
c     trajts  = (false,true) = (don`t, do) print particle trajectories
c               on this time step. based on "trajint"
c
c     snapts  = (false,true) = (don`t, do) save a snapshot of the data
c               on this time step. based on "snapint"
c
c     timats  = (false,true) = (don`t, do) write time mean data
c               on this time step. based on "timavgint"
c                                          
c     xbtts   = (false,true) = (don`t, do) write averaged XBT data on
c               this time step based on "xbtint"
c
c
c     leapfrog= (false,true) on a (mixing, normal leapfrog) time step
c                based on "nmix"
c                                          
c     euler1  = true on the 1st pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     euler2  = true on the 2nd pass of an euler backward time step
c               otherwise false. (applies when "eb" = true)
c     forward = true on a forward time step. otherwise false
c		(applies when "eb" = false)		  
c                                          
c
c     the following logical switches are based on the model time step. 
c    
c     first   = (true,false) =  when it`s (the first, not the first)
c                               time step of a run
c     eots    = end of a time step. always true except for first
c               pass of an euler backward time step
c     eorun   = last time step of a run. always false except during the
c               last time step of the run.
c
c     eoday   = true when within 1/2 time step of the end of a day
c               else ... false
c     eoweek  = true when within 1/2 time step of the end of a 7 day
c               week (referenced to the start of a year) else ...false
c     eo2wks  = true when within 1/2 time step of the end of two weeks
c               (referenced to the start of a year) else ... false
c     midmon  = true when within 1/2 time step of the middle of a month
c               else ... false
c     eomon   = true when within 1/2 time step of the end of a month
c               else ... false
c     eoyear  = true when within 1/2 time step of the end of a year
c               else ... false
c     osegs   = true on the 1st time step of an ocean segment in mom.F
c               otherwise false.
c     osege  =  true on the last time step of an ocean segment in mom.F
c               otherwise false.
c
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c
c
      logical eb, leapfrog, euler1, euler2, forward, eots
      logical init, first, restrt
      logical itavg, itmb, itrmb, igyre
      character *8 rununits
c
      common /switcc/ rununits
      common /switcr/ runlen, rundays
      common /switci/ nmix
      common /switcl/ eb, leapfrog, euler1, euler2, forward, eots
      common /switcl/ init, first, restrt
      common /switcl/ itavg, itmb, itrmb, igyre
c
      logical          eoday, eoweek, eo2wks
      common /switci/ ieoday,ieoweek,ieo2wks
      common /switcl/  eoday, eoweek, eo2wks
c
      logical          eomon, midmon, eoyear, eorun
      common /switci/ ieomon,imidmon,ieoyear,ieorun
      common /switcl/  eomon, midmon, eoyear, eorun
c
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c     each interval switch needs three variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output (e.g,.  glenint)
c         2) a switch (logical) for the interval (e.g.,  glents )
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c         3) an index (integer)                       (e.g., iglenint)
c
c     the user must specify the interval [e.g., glenint] for diagnostic
c     output in units of days. tmngr sets the corresponding logical  
c     switch [e.g., glents] every time step. It is set to true when  
c     within half a time step of the requested interval, otherwise it is
c     false. All decisions relating to the interval [e.g., glenint]
c     are based on the logical switch [e.g., glents].
c           
c     internal time structures
c
c     The switch index [e.g., iglenint] is used to subsrcipt into  
c     internal arrays maintained by tmngr.F. The switch index is
c     allocated on the first call to function "alarm".
c     The array entry [e.g., iinterval(iglenint)] is a time index to the
c     internal representation of the interval [e.g., glenint].
c     The array entry [e.g., ialarm(iglenint)] is a time index to the
c     next time the alarm will be true.
c-----------------------------------------------------------------------
c
      logical           tavgts,    glents,    trmbts,   prxzts
      common /switcr/   tavgint,   glenint,   trmbint,  prxzint
      common /switci/  itavgint,  iglenint,  itrmbint, iprxzint
      common /switcl/   tavgts,    glents,    trmbts,   prxzts
c
      logical          extts,   trajts,   exconvts,   cmixts
      common /switcr/  extint,  trajint,  exconvint,  cmixint
      common /switci/ iextint, itrajint, iexconvint, icmixint
      common /switcl/  extts,   trajts,   exconvts,   cmixts
c
      logical          vmsfts,   gyrets,    tsits,   snapts,   fctts
      common /switcr/  vmsfint,  gyreint,   tsiint,  snapint,  fctint
      common /switci/ ivmsfint, igyreint,  itsiint, isnapint, ifctint
      common /switcl/  vmsfts,   gyrets,    tsits,   snapts,   fctts
c
      logical          tyzts
      common /switcr/  tyzint
      common /switci/ ityzint
      common /switcl/  tyzts
c
      logical          stabts,   zmbcts,   crossts,   densityts
      common /switcr/  stabint,  zmbcint,  crossint,  densityint
      common /switci/ istabint, izmbcint, icrossint, idensityint
      common /switcl/  stabts,   zmbcts,   crossts,   densityts
c
      logical          osegs,  osege
      common /switcr/          segtim
      common /switci/ iosegs, iosege
      common /switcl/  osegs,  osege
c   
c-----------------------------------------------------------------------
c
c     S W I T C H E S    B A S E D    O N    A N    I N T E R V A L
c
c              A N D   A V E R A G I N G   P E R I O D
c
c     each averaging period switch needs five variables in common. The 
c     following naming convention is used.
c
c         1) an interval (real) for diagnostic output    (e.g. xbtint  )   
c         2) a switch (logical) for the interval         (e.g. xbtts   )
c         3) an averaging period (real)                  (e.g. xbtper  )   
c         4) a switch (logical) for accumulating         (e.g. xbtperts)
c
c     the third is an internal variable needed by the time manager
c     to support calculation of the logical switches
c
c         5) an index (integer)                         (e.g. ixbtint  )
c
c     The user must specify the interval [e.g., xbtint] for diagnostic
c     output in units of days and the averaging period [e.g., xbtper] 
c     in units of days. The averaging period may be less than or equal
c     to the interval. For example, if the interval is 30.0 days and the
c     averaging period is 5.0 days, results will be averaged over all
c     time steps within days 26, 27, 28, 29, and 30.  An averaging period
c     of 0.0 days averages over the last time step of the interval (as
c     does xbtper = dt), and an averaging period less than zero turns
c     the switches off for all time steps.  
c
c     The logical switch for writing output at the specified interval 
c     [e.g., xbtts] is set to true on the last time step of the 
c     averaging period. The logical switch for accumulating results
c     [e.g., xbtperts] is true for all time steps within the averaging
c     period, otherwise it is false. 
c
c     internal time structures
c
c     The index [e.g., ixbtint] is allocated on the first call to 
c     function "avg_alarm". The array element iperiod(ixbtint) is an
c     index to the time structure for the internal representation of 
c     "xbtper", and ilastsw(ixbtint) is the index of the switch that 
c     flags the last time step of the accumulation period.
c     Depending on use,  ilastsw(ixbtint) may either be the index
c     of another "named" switch or the index of a new switch
c     allocated on the first time step.
c     In the latter case, iinterval(ilastsw(ixbtint)) is the index of
c     the time structure where "xbtint" is stored in internal form,
c     and ialarm(ilastsw(ixbtint)) is the index of the time when an
c     accumulation period will next end.
c     The variable nextts(ixbtint) is true whenever the next
c     time step will begin the accumulation period.
c
c-----------------------------------------------------------------------
c
      logical         xbtts,     dspts,    tmbts,    timavgts
      logical         xbtperts,  dspperts, tmbperts, timavgperts
      common /switcr/ xbtint,    dspint,   tmbint,   timavgint
      common /switcr/ xbtper,    dspper,   tmbper,   timavgper
      common /switci/ixbtint,   idspint,  itmbint,  itimavgint
      common /switcl/ xbtts,     dspts,    tmbts,    timavgts
      common /switcl/ xbtperts,  dspperts, tmbperts, timavgperts
c
c-----------------------------------------------------------------------
c
c                 S W I T C H E S    B A S E D    O N    
c
c         C A L E N D A R   O R    P R E V I O U S    S W I T C H   
c
c               A N D   A V E R A G I N G    P E R I O D
c
c    
c
c     the following logical switches are based on any calendar or 
c     interval switch and an averaging period (in days). The  averaging
c     period must be less than or equal to the interval. The last
c     time step of the averaging period is at the end of the interval.
c     If the averaging period is set to zero, the averaging period
c     consists only of the last time period of the interval.  If
c     the averaging period is less than zero, these switches are always
c     false.
c
c     each averaging period switch needs four variables in common. For
c     example, if the averaging period is before the end of each month
c     then the calendar switch (eomon), and index (ieomon) are presumed
c     to exist in common and need not be added.
c     
c     Additionally, four items are needed.
c
c       1) an averaging period (real)                  (e.g.  testper  )   
c       2) a switch (logical) for accumulating results (e.g.  testperts)
c       3) a switch (logical) for the end of interval  (e.g.  testts   )
c
c     the fourth is an internal variable needed by the time manager
c     to support calculation of the logical switch
c
c       4) an index (integer)                          (e.g.  itestper )
c
c     Suppose it is required to produce averages over all time steps
c     during the last 5 days of each month. Then "testper" = 5.0 and 
c     the following will calculate the accumulating switch.
c
c      testts = avg_alarm(itestper, ihalfstep, 0, testper, iref, ieomon)
c      testperts = on(itestper)
c
c     Note the use of "ieomon" to key off the months.  The switch
c     "testts" will be true whenever "eomon" is true.
c     Also note that when an averaging switch is keyed off another
c     switch, the switch inverval argument is not used, but is 
c     retained for consistency with the form of other averaging
c     switches.
c-----------------------------------------------------------------------
c
      logical           testperts
      logical           testts
      common /switcr/   testint
      common /switcr/   testper
      common /switci/  itestper
      common /switcl/   testts
      common /switcl/   testperts

c
      parameter (maxsw=100)
      logical          on, lastts, nextts
      common /switci/  nsw  
      common /switci/  ialarm(maxsw), iinterval(maxsw), iperiod(maxsw)
     &,                ilastsw(maxsw)
      common /switcl/  on(maxsw), lastts(maxsw), nextts(maxsw)
c
c======================= include file "calendar.h"======================
c
c                       calendar specification arrays
c
c-----------------------------------------------------------------------
c
c     eqyear = true to select a calendar in which each year
c              has the same number of days (i.e., no leap years)
c              false selects a julian calendar
c
c     eqmon  = true to force all months to have the same number of days
c              false => the usual 31, 28, 31, 30, ..., days per month. 
c              only used when eqyear = true 
c
c     dayname = character names of days
c
c     monname = character names of months
c
c     monlen = the length of each month (in days) when eqmon is true
c
c     yrlen  = the length of a typical (non-leap) year in days
c
c     daypm  = array of month lengths in days   (non-leap)
c
c     msum   = array of cumulative days preceding each month
c              (again, non-leap)
c
c-----------------------------------------------------------------------
      logical eqyear, eqmon
      integer daypm, msum, yrlen, monlen
c
      character*10 dayname
      character*12 monname
c
      common /calenc/ dayname(7), monname(12)
      common /calenl/ eqyear, eqmon
      common /caleni/ daypm(12), msum(12), yrlen, monlen

c
      logical timeequal
c
c=======================================================================
c     date and time calculations (done every time step)
c=======================================================================
c
c     set flag "first" if first iteration of a run.
c     this flag must be set BEFORE the time is incremented.
c
      first = timeequal (itime, irunstart)
c
c-----------------------------------------------------------------------
c     round dt to the nearest millisecond
c-----------------------------------------------------------------------
c
      iddt = id (dt)
      msdt = msec (dt)
      call settime2 (idt, iddt, msdt)
      dt   = realsecs(idt)
c
c-----------------------------------------------------------------------
c     calculate half time step
c-----------------------------------------------------------------------
c
      iddtd2 = iddt/2
      msdtd2 = msdt/2 + 43200000*modulo (iddt, 2)
      call settime2 (idtd2, iddtd2, msdtd2)
c
c-----------------------------------------------------------------------
c     save previous values of stamp and relyr
c-----------------------------------------------------------------------
c
      pstamp = tstamp(itime)
      prelyr = relyr
c
c-----------------------------------------------------------------------
c     increment time counters
c-----------------------------------------------------------------------
c
      call addtime (itime, idt, itime)
      call expandtime2 (itime)
c
c     set current time stamp for MOM
c
      stamp = tstamp(itime)
c
      call addtime (itime, idtd2, ihalfstep)
c
c-----------------------------------------------------------------------
c     calculate number of days since reference time and start of run
c     all times are of form: (integer days, fractional day in millisec)
c----------------------------------------------------------------------
c
      call subtime (itime, irunstart, iruntime)
      call subtime (itime, initial, imodeltime)
      if (refuser) then 
        call subtime (itime, iuser, iusertime)
      end if
c
c-----------------------------------------------------------------------
c     calculate real output quantities:
c       relyr  = years of model time since initial conditions
c       dayoyr = days since start of current year
c-----------------------------------------------------------------------
c
      dayoyr = dayofyear(itime) - 1 + (msday(itime)/86400000.0)
      relyr  = year(itime) - year(initial) + dayoyr/daysinyear(itime) -
     &         (dayofyear(initial) - 1 + (msday(initial)/86400000.0))/
     &         daysinyear(initial)
c
      return
      end





      subroutine calendari (eqyear, eqmon, monlen,
     &                   yrlen, daypm, msum, dayname, monname, error)
c
c=======================================================================
c     set up the calendar by choosing one of the following:
c
c        a) fully leap-year corrected calendar     (eqyear=F eqmon=F)
c        b) equal 365-day years (variable months)  (eqyear=T eqmon=F)
c        c) 12 equal months of "monlen" days each  (eqyear=T eqmon=T)
c
c     inputs:
c        eqyear, eqmon = logicals degined as in "a", "b", and "c"
c        monlen = days per month when using option "c"
c
c     outputs:
c        yrlen   = length of year in days
c        daypm   = days per month
c        msum    = accululated days per month
c        dayname = character day names
c        monname = character month names
c        error   = .t. if something went wrong
c
c     authors: c. h. goldberg        chg@gfdl.gov
c              d. j. goldberg
c=======================================================================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
      parameter (nmonth = 12, nday = 7)
      logical eqyear, eqmon, error
      character*10 daynamei
      character*12 monnamei
      character*(*) dayname, monname
      dimension daynamei(nday), monnamei(nmonth)
      dimension dayname(nday), monname(nmonth)
      integer daypm(nmonth), daypmi(nmonth), msum(nmonth), yrlen
      data daypmi/31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31/
      data daynamei/'sunday', 'monday', 'tuesday', 'wednesday',
     &            'thursday', 'friday', 'saturday'/
c
      data monnamei /'january', 'febuary', 'march', 'april', 'may'
     &,           'june', 'july', 'august', 'september', 'october'
     &,           'november', 'december'/
c
c-----------------------------------------------------------------------
c     first check that a valid combination of eqyear and eqmon
c     has been specified
c-----------------------------------------------------------------------
c
      if (eqmon .and. (.not. eqyear)) then
        write (stdout,999) eqyear, eqmon
        stop 'badcal'
      endif
c
      if (.not. (eqyear .and. eqmon)) then
        do i = 1, nmonth
          daypm(i) = daypmi(i)
        enddo
      else
        error = error .or. (monlen .le. 0)
        do i = 1, nmonth
          daypm(i) = monlen
        enddo
      endif
c
      msum(1) = 0
      do i = 2,nmonth
        msum(i) = msum(i-1) + daypm(i-1)
      enddo
      yrlen = msum(nmonth) + daypm(nmonth)
c
c     initialize day and month names
c
      do n=1,nday
        dayname(n) = daynamei(n)
      enddo
c
      do n=1,nmonth
        monname(n) = monnamei(n)
      enddo
c
      write (stdout,'(a)') 'Calendar selection:'
      if (.not. eqyear) then
        print '(/,a)', '  leap year corrected calendar'
      else
        print '(/,a,i4,a)', '  equal years of ', yrlen, ' days'
      endif
c
      print '(a,12i3,/)', '  days per month =',daypm
c
      return
c
999   format(/' error => An inappropriate calendar type was selected  ',
     &   /'     eqyear was set to ',l1,'   eqmon was set to ',l1,
     &   /'     valid combinations are:',
     &   /'     fully leap-year corrected calendar  (eqyear=F eqmon=F)'
     &   /'     equal 365-day years                 (eqyear=T eqmon=F)'
     &   /'     12 equal months of monlen days each (eqyear=T eqmon=T)')
c
      end



      subroutine ckdate (i, error)
c
c=======================================================================
c     do bounds checking on clock parameters
c     year is not checked since all years are ok.
c     at present, one extra day is allowed in month 2, even if year is
c     not a leap year or if there are no leap years.
c
c     authors: c. h. goldberg        chg@gfdl.gov
c              d. j. goldberg
c=======================================================================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c

c======================= include file "calendar.h"======================
c
c                       calendar specification arrays
c
c-----------------------------------------------------------------------
c
c     eqyear = true to select a calendar in which each year
c              has the same number of days (i.e., no leap years)
c              false selects a julian calendar
c
c     eqmon  = true to force all months to have the same number of days
c              false => the usual 31, 28, 31, 30, ..., days per month. 
c              only used when eqyear = true 
c
c     dayname = character names of days
c
c     monname = character names of months
c
c     monlen = the length of each month (in days) when eqmon is true
c
c     yrlen  = the length of a typical (non-leap) year in days
c
c     daypm  = array of month lengths in days   (non-leap)
c
c     msum   = array of cumulative days preceding each month
c              (again, non-leap)
c
c-----------------------------------------------------------------------
      logical eqyear, eqmon
      integer daypm, msum, yrlen, monlen
c
      character*10 dayname
      character*12 monname
c
      common /calenc/ dayname(7), monname(12)
      common /calenl/ eqyear, eqmon
      common /caleni/ daypm(12), msum(12), yrlen, monlen

c
      logical error
c
      error = .false.
c
      if (month(i) .lt. 1 .or. month(i) .gt. 12) then
        write (stdout,*) ' Error:  month is out of bounds'
        error = .true.
      endif
c 
      if ((day(i) .lt. 1 .or. day(i) .gt. daypm(month(i))) .and. .not.
     &    (month(i) .eq. 2 .and. day(i) .eq. daypm(2)+1)) then
        write (stdout,*) ' Error:  day is out of bounds'
        error = .true.
      endif
c
      if (hour(i) .lt. 0 .or. hour(i) .gt. 23) then
        write (stdout,*) ' Error:  hour is out of bounds'
        error = .true.
      endif
c
      if (minute(i) .lt. 0 .or. minute(i) .gt. 59) then
        write (stdout,*) ' Error:  minute is out of bounds'
        error = .true.
      endif
c
      if (second(i) .lt. 0 .or. second(i) .gt. 59) then
        write (stdout,*) ' Error:  second is out of bounds'
        error = .true.
      endif
c
      return
      end


      subroutine d2ymd (inday,
     &                  iyear, imonth, iday, idoy, idow, ndim, ndiy)
c
c======================================================================
c     d2ymd takes the number of days since Dec 31, 1899 and converts
c     to year, month, day, and other defining quantities.
c     ie. inday=1   yields  Jan 1, 1900.
c     if eqyear=.true. then calculation is done in subroutine d2ymdc
c
c     inday  = input days since Dec. 31, 1899
c     eqyear = .false. ==> use leap year corrected calendar
c     eqyear = .true.  ==> use constant length year calendar
c
c     output:
c       iyear  = output year
c       imonth = output month
c       iday   = output day of the month
c       idoy   = output day of the current year
c       idow   = output day of the week   1=sun - 7=sat
c       ndim   = number of days in the current month
c       ndiy   = number of days in the current year
c
c     authors: c. h. goldberg        chg@gfdl.gov
c              d. j. goldberg
c======================================================================
c
c======================= include file "calendar.h"======================
c
c                       calendar specification arrays
c
c-----------------------------------------------------------------------
c
c     eqyear = true to select a calendar in which each year
c              has the same number of days (i.e., no leap years)
c              false selects a julian calendar
c
c     eqmon  = true to force all months to have the same number of days
c              false => the usual 31, 28, 31, 30, ..., days per month. 
c              only used when eqyear = true 
c
c     dayname = character names of days
c
c     monname = character names of months
c
c     monlen = the length of each month (in days) when eqmon is true
c
c     yrlen  = the length of a typical (non-leap) year in days
c
c     daypm  = array of month lengths in days   (non-leap)
c
c     msum   = array of cumulative days preceding each month
c              (again, non-leap)
c
c-----------------------------------------------------------------------
      logical eqyear, eqmon
      integer daypm, msum, yrlen, monlen
c
      character*10 dayname
      character*12 monname
c
      common /calenc/ dayname(7), monname(12)
      common /calenl/ eqyear, eqmon
      common /caleni/ daypm(12), msum(12), yrlen, monlen


c
      logical leap
c
c     define the number of days per month for a non leap year (daypmi)
c
      integer daypmi(12)
      data daypmi/31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31/
c
c-----------------------------------------------------------------------
c     equal-year calculations are handled by d2ymdc
c-----------------------------------------------------------------------
c
      if (eqyear) then
        call d2ymdc (inday,
     &               iyear, imonth, iday, idoy, idow, ndim, ndiy)
        return
      endif
c
c-----------------------------------------------------------------------
c     calculate day of the week (idow)
c     inday = 0, i.e.,  Dec 31, 1899 was a Sunday.
c-----------------------------------------------------------------------
c
      idow = modulo (inday, 7) + 1
c
c-----------------------------------------------------------------------
c     convert to days after january 1, 1601 using a virtual calendar
c     consistent with current leap-year systems to extend backwards.
c     (ie. 1700, 1800, 1900 are not considered leap-years but 2000
c     is a leap-year)
c-----------------------------------------------------------------------
c
      nday  = inday + 109206
      ibasyr = 1601
c
c-----------------------------------------------------------------------
c     make corrections for years before 1601 (assuming modern leap year
c     conventions)  note that 400 years doesn`t affect the day of the
c     week.   146097 days = 20871 weeks exactly.
c-----------------------------------------------------------------------
c
      if (nday .lt. 0) then
        nfh     = 1 + (-nday - 1)/146097
        ibasyr  = ibasyr - 400*nfh
        nday    = nday + 146097*nfh
      endif
c
c-----------------------------------------------------------------------
c     peel off year.  Acurate from before Jan 1, 1900 until the
c     julian day overflows machine limitations.
c----------------------------------------------------------------------
c
      nfh   = nday/146097
      nday  = modulo (nday, 146097)
      nhund = nday/36524
      if (nhund .gt. 3) then
        nhund = 3
        nday  = 36524
      else
        nday  = modulo (nday, 36524)
      endif
      nfour = nday/1461
      nday  = modulo (nday, 1461)
      nex   = nday/365
      if (nex .gt. 3) then
        nex   = 3
        nday  = 365
      else
        nday  = modulo (nday, 365)
      endif
      leap  = (nex .eq. 3) .and. ((nfour .ne. 24) .or. (nhund .eq. 3))
      if (leap) then
        ndiy = 366
      else
        ndiy = 365
      endif
      iyear = ibasyr + 400*nfh + 100*nhund + 4*nfour + nex
      idoy  = nday + 1
c
c-----------------------------------------------------------------------
c     peel off month and day.
c-----------------------------------------------------------------------
c
      iday = idoy
      do m=1,12
        if (leap .and. (m .eq. 2)) then
          if (iday .le. (daypmi(2)+1)) then
            imonth = 2
            ndim = daypmi(2) + 1
            goto 200
          endif
          iday = iday - daypmi(2) - 1
        else
          if (iday .le. daypmi(m))  then
            imonth = m
            ndim = daypmi(m)
            goto 200
          endif
          iday = iday - daypmi(m)
        endif
      enddo
c
 200  continue
c
      return
      end


      subroutine d2ymdc (inday,
     &                   iyear, imonth, iday, idoy, idow, ndim, ndiy)
c======================================================================
c     inverse of "ymd2dc"
c     d2ymdc takes the number of days since Dec 31, 1899 (or the last
c     day of December 1899 in case equal months of length < 31 days are
c     used) and converts to year, month, day, and other defining
c     quantities.
c     eg: inday=1   yields  Jan 1, 1900.
c
c     equal length years are assumed (no leap years here)
c
c     input:
c       inday  = days since Dec. 31, 1899
c
c     output:
c       iyear  = output year
c       imonth = output month
c       iday   = output day of the month
c       idoy   = day of the current year
c       idow   = day of the week   1=sun - 7=sat
c       ndim   = number of days in the current month
c       ndiy   = number of days in the current year
c
c     authors: c. h. goldberg        chg@gfdl.gov
c              d. j. goldberg
c======================================================================
c======================= include file "calendar.h"======================
c
c                       calendar specification arrays
c
c-----------------------------------------------------------------------
c
c     eqyear = true to select a calendar in which each year
c              has the same number of days (i.e., no leap years)
c              false selects a julian calendar
c
c     eqmon  = true to force all months to have the same number of days
c              false => the usual 31, 28, 31, 30, ..., days per month. 
c              only used when eqyear = true 
c
c     dayname = character names of days
c
c     monname = character names of months
c
c     monlen = the length of each month (in days) when eqmon is true
c
c     yrlen  = the length of a typical (non-leap) year in days
c
c     daypm  = array of month lengths in days   (non-leap)
c
c     msum   = array of cumulative days preceding each month
c              (again, non-leap)
c
c-----------------------------------------------------------------------
      logical eqyear, eqmon
      integer daypm, msum, yrlen, monlen
c
      character*10 dayname
      character*12 monname
c
      common /calenc/ dayname(7), monname(12)
      common /calenl/ eqyear, eqmon
      common /caleni/ daypm(12), msum(12), yrlen, monlen


c
c-----------------------------------------------------------------------
c     calculate day of the week (sunday=1)
c     inday = 0, i.e., Dec 31, 1899 was a Sunday.
c-----------------------------------------------------------------------
c
      idow = modulo (inday, 7) + 1
c
c-----------------------------------------------------------------------
c     peel off the year
c-----------------------------------------------------------------------
c
      if (inday .le. 0) then
        iyr = (inday / yrlen) - 1
      else
        iyr = (inday - 1) / yrlen
      end if
      iyear = iyr + 1900
      idoy  = inday - yrlen*iyr
c
c-----------------------------------------------------------------------
c     peel off the month and day.
c-----------------------------------------------------------------------
c
      iday = idoy
      do m=1,12
        if (iday .le. daypm(m))  then
          imonth = m
          ndim = daypm(m)
          goto 200
        endif
        iday = iday - daypm(m)
      enddo
c
 200  continue
      ndiy = yrlen
c
      return
      end


      subroutine ymd2d (iyear, imonth, iday,
     &                  nday, idoy, idow, ndim, ndiy)
c
c=======================================================================
c     inverse of "d2ymd"
c     ymd2d takes a date in the year, month, day form and converts it
c     to days since Dec 31. 1899 (nday).  It also needs the
c     cumulative sums of days from the beginning of the year to each
c     month "msum". It returns the number of days in the
c     specified year (ndiy).
c
c     equal year calculations are passed on to subroutine ymd2dc
c
c     input:
c       iyear  = input year
c       imonth = input month
c       iday   = input day of the month
c
c     output:
c       nday   = days since Dec. 31, 1899
c       idoy   = day of the current year
c       idow   = day of the week   1=sun - 7=sat
c       ndim   = number of days in the current month
c       ndiy   = number of days in the current year
c
c     authors: c. h. goldberg        chg@gfdl.gov
c              d. j. goldberg
c======================================================================
c
c======================= include file "calendar.h"======================
c
c                       calendar specification arrays
c
c-----------------------------------------------------------------------
c
c     eqyear = true to select a calendar in which each year
c              has the same number of days (i.e., no leap years)
c              false selects a julian calendar
c
c     eqmon  = true to force all months to have the same number of days
c              false => the usual 31, 28, 31, 30, ..., days per month. 
c              only used when eqyear = true 
c
c     dayname = character names of days
c
c     monname = character names of months
c
c     monlen = the length of each month (in days) when eqmon is true
c
c     yrlen  = the length of a typical (non-leap) year in days
c
c     daypm  = array of month lengths in days   (non-leap)
c
c     msum   = array of cumulative days preceding each month
c              (again, non-leap)
c
c-----------------------------------------------------------------------
      logical eqyear, eqmon
      integer daypm, msum, yrlen, monlen
c
      character*10 dayname
      character*12 monname
c
      common /calenc/ dayname(7), monname(12)
      common /calenl/ eqyear, eqmon
      common /caleni/ daypm(12), msum(12), yrlen, monlen

c
      logical leap
c
c-----------------------------------------------------------------------
c     have subroutine ymd2dc do equal-year calculations
c-----------------------------------------------------------------------
c
      if (eqyear) then
        call ymd2dc (iyear, imonth, iday, nday, idoy, idow, ndim, ndiy)
        return
      end if
c
      if (mod (iyear, 400) .eq. 0) then
        leap = .true.
      elseif ((mod(iyear,4) .eq. 0) .and. (mod(iyear,100) .ne. 0)) then
        leap = .true.
      else
        leap = .false.
      endif
      if (leap) then
        ndiy = 366
      else
        ndiy = 365
      endif
      nday = iday + msum(imonth)
      if (leap .and. (imonth .gt. 2)) then
        nday = nday + 1
      endif
      idoy = nday
      iyr = iyear - 1601
c
c-----------------------------------------------------------------------
c     make corrections for years before 1601.
c-----------------------------------------------------------------------
c
      if (iyr .lt. 0) then
        nfh  = 1 + (-iyr)/400
        nday = nday - 146097*nfh
        iyr  = iyr + 400*nfh
      endif
      nday = nday + 365*iyr
c
c-----------------------------------------------------------------------
c     correct for leap-years between 1601 and iyear-1.
c     A virtual calendar consistent with current leap-year systems
c     is used to extend backwards.  (ie. 1700, 1800, 1900 are not
c     considered leap-year but 2000 is a leap-year)
c-----------------------------------------------------------------------
c
      iyr = iyr/4
      nday = nday + iyr
      iyr = iyr/25
      nday = nday - iyr
      iyr = iyr/4
      nday = nday + iyr
c
c-----------------------------------------------------------------------
c     nday is now in days since Dec. 31, 1600.  Convert to days since
c     Dec 31, 1899.
c-----------------------------------------------------------------------
c
      nday = nday - 109207
      idow = modulo (nday, 7) + 1
      ndim = daypm(imonth)
      if (leap .and. (imonth .eq. 2)) then
        ndim = ndim + 1
      end if
c
      return
      end


      subroutine ymd2dc (iyear, imonth, iday,
     &                   nday, idoy, idow, ndim, ndiy)
c
c=======================================================================
c     inverse of "d2ymdc"
c     ymd2dc takes a date in the year, month, day form and converts
c     to days since Dec 31. 1899 (nday).  It also returns the number
c     of days in the specified year (ndiy).
c
c     ymd2dc uses a year of constant length with no leap years
c
c     input:
c       iyear  = input year
c       imonth = input month
c       iday   = input day of the month
c
c     output:
c       nday   = days since Dec. 31, 1899
c       idoy   = day of the current year
c       idow   = day of the week   1=sun - 7=sat
c       ndim   = number of days in the current month
c       ndiy   = number of days in the current year
c
c     authors: c. h. goldberg        chg@gfdl.gov
c              d. j. goldberg
c=======================================================================
c
c======================= include file "calendar.h"======================
c
c                       calendar specification arrays
c
c-----------------------------------------------------------------------
c
c     eqyear = true to select a calendar in which each year
c              has the same number of days (i.e., no leap years)
c              false selects a julian calendar
c
c     eqmon  = true to force all months to have the same number of days
c              false => the usual 31, 28, 31, 30, ..., days per month. 
c              only used when eqyear = true 
c
c     dayname = character names of days
c
c     monname = character names of months
c
c     monlen = the length of each month (in days) when eqmon is true
c
c     yrlen  = the length of a typical (non-leap) year in days
c
c     daypm  = array of month lengths in days   (non-leap)
c
c     msum   = array of cumulative days preceding each month
c              (again, non-leap)
c
c-----------------------------------------------------------------------
      logical eqyear, eqmon
      integer daypm, msum, yrlen, monlen
c
      character*10 dayname
      character*12 monname
c
      common /calenc/ dayname(7), monname(12)
      common /calenl/ eqyear, eqmon
      common /caleni/ daypm(12), msum(12), yrlen, monlen

c
      idoy = iday + msum(imonth)
      iyr = iyear - 1900
      nday = idoy + yrlen*iyr
      idow = modulo (nday, 7) + 1
      ndim = daypm(imonth)
      ndiy = yrlen
c
      return
      end



      subroutine mkstmp (stamp, year, month, day, hour, min, sec)
c
c=======================================================================
c     make a 32 character time stamp from integer inputs
c
c     inputs: integer year, month, day, hour, min, sec
c     output: stamp
c     authors: c. h. goldberg        chg@gfdl.gov
c              d. j. goldberg
c=======================================================================
c
      integer year, month, day, hour, min, sec
      character*32 stamp
c

      write (stamp,'(a6,i2,a1,i2,a1,i4,a8,i2,a1,i2,a1,i2)')
     &             'm/d/y=',month,'/',day,'/'
     &,             year,', h:m:s=', hour,':'
     &,             min,':', sec

      return
      end

      subroutine rdstmp (stmp, year, month, day, hour, min, sec)
c
c=======================================================================
c     convert 32 character time stamp into integer year month day etc
c
c     authors: c. h. goldberg        chg@gfdl.gov
c              d. j. goldberg
c=======================================================================
c
      character *32 stmp
      character *6  junk6
      character *8  junk8
      character *1  junk1
      integer       year, month, day, hour, min, sec
c

      read  (stmp, '(a6,i2,a1,i2,a1,i4,a8,i2,a1,i2,a1,i2)')
     &       junk6, month, junk1, day, junk1, year, junk8, hour,
     &       junk1, min, junk1, sec

c
      return
      end



      subroutine incstamp (stamp1, days, stamp2)
c
c=======================================================================
c     increment a time stamp by a real number of days
c     input:
c      stamp1 =  character date and time stamp
c      days   =  days to increment stamp (may be negative)
c     output:
c      stamp2 = stamp1 incremented by days
c
c     author:  c. h. goldberg       chg@gfdl.gov
c=======================================================================
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c

      character*(*) stamp1, stamp2
      call settimefromstamp (stamp1, itemptime)
      call settime2 (itemptime2, id(days*86400.0), msec(days*86400.0))
      call addtime (itemptime, itemptime2, itemptime)
      call expandtime2 (itemptime)
      stamp2 = tstamp(itemptime)
      return
      end

      subroutine inctime (index1, days, index2)
c
c=======================================================================
c     increment a full time by a real number of days
c     input:
c      index1 =  subscript of a full time 
c      days   =  days to increment full time (may be negative)
c      index2 = subscript of the answer
c     output:
c      time arrays for index2 (year, month, day, etc) in tmngr.h 
c
c     author:  c. h. goldberg       chg@gfdl.gov
c=======================================================================
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c


      call settime2 (itemptime, id(days*86400.0), msec(days*86400.0))
      call addtime (index1, itemptime, index2)
      call expandtime2 (index2)
      return
      end

      subroutine settimefromstamp (stamp, index)
c
c=======================================================================
c     input:
c      stamp =  character dat and time stamp 
c      index = subscript of the answer
c     output:
c      time arrays for index (year, month, day, etc) in tmngr.h 
c
c     author:  c. h. goldberg       chg@gfdl.gov
c=======================================================================
c
      character*(*) stamp
      call rdstmp (stamp, iyear, imonth, iday, ihour, imin, isec)
      call setfulltime (index, iyear, imonth, iday, ihour, imin, isec)
      return
      end



      subroutine addtime (index1, index2, index)
c
c=======================================================================
c     add two times given in (integer day, nonneg integer ms) form
c     input:
c      index1 =  subscript of the first time into time arrays in tmngr.h 
c      index2 =  subscript of the second time
c      index  = subscript of the answer
c     output:
c      iday(index) = integer day number of answer in tmngr.h
c      msday(index)= millisec fractional day of answer in tmngr.h
c
c     author:  c. h. goldberg       chg@gfdl.gov
c=======================================================================
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c

c
      mst = msday(index1) + msday(index2)
      it  = iday(index1) + iday(index2)
      if (mst .ge. 86400000) then
        mst = mst - 86400000
        it  = it + 1
      end if
      iday(index) = it
      msday(index) = mst
c
      return
      end


      subroutine subtime (index1, index2, index)
c
c=======================================================================
c     subtract two times given in (integer day, nonneg integer ms) form
c     input:
c      index1 =  subscript of the first time into time arrays in tmngr.h 
c      index2 =  subscript of the second time
c      index  = subscript of the answer
c     output:
c      iday(index) = integer day number of answer in tmngr.h
c      msday(index)= millisec fractional day of answer in tmngr.h
c
c     author:  c. h. goldberg       chg@gfdl.gov
c=======================================================================
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c


c
      mst = msday(index1) - msday(index2)
      it  = iday(index1) - iday(index2)
      if (mst .lt. 0) then
        mst = mst + 86400000
        it = it - 1
      end if
      iday(index)  = it
      msday(index) = mst
c
      return
      end


      subroutine multime (n, index1, index)
c
c=======================================================================
c     multiply time (integer day, nonneg integer ms) by an integer
c     input:
c      n      = integer multiple    
c      index1 = subscript of the time
c      index  = subscript of the answer
c     output:
c      iday(index) = integer day number of answer in tmngr.h
c      msday(index)= millisec fractional day of answer in tmngr.h
c
c     author:  c. h. goldberg       chg@gfdl.gov
c=======================================================================
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c


c
      double precision dmst
c
      dmst = n*dble(msday(index1))
      it   = n*iday(index1)
      it   = it + int(dmst/86400000.0d0)
      mst  = nint(mod (dmst, 86400000.0d0))
      iday(index)  = it
      msday(index) = mst
c
      return
      end


      subroutine ms2hms (ms, hour, min, sec)
c
c=======================================================================
c     converts fraction of a day in milliseconds to hour/min/sec
c
c     author:  c. h. goldberg       chg@gfdl.gov
c=======================================================================
c
      integer ms, hour, min, sec
c
      hour  = ms / 3600000
      msrem = ms - hour * 3600000
      min   = msrem / 60000
      sec   = (msrem - min * 60000) / 1000
c
      return
      end


      function hms2ms (hour, min, sec)
c
c=======================================================================
c     converts fraction of a day in hour/min/sec to milliseconds
c
c     author:  c. h. goldberg       chg@gfdl.gov
c=======================================================================
c
      integer hms2ms, hour, min, sec
c
      hms2ms = hour*3600000 + min*60000 + sec*1000
c
      return
      end


      function ifloor (realvalue)
c
c=======================================================================
c     f90 intrinsic "floor"
c     largest integer less than or equal to realvalue
c
c     author:  c. h. goldberg       chg@gfdl.gov
c=======================================================================
c
      iflr = int(realvalue) -1
      ifloor = iflr + int(realvalue - iflr)
c
      return
      end


      function id (realsec)
c
c=======================================================================
c     converts time in real seconds to the integer day part
c     see also "msec" 
c
c     author:  c. h. goldberg       chg@gfdl.gov
c=======================================================================
c
      id = ifloor(realsec/86400.0)
c
      return
      end


      function msec (realsec)
c
c=======================================================================
c     extracts integer milliseconds from time in real seconds
c     see also "id" 
c
c     author:  c. h. goldberg       chg@gfdl.gov
c=======================================================================
c
      msec = nint (1000.0*(realsec-86400.0*id(realsec)))
c
      return
      end


      function realsecs (index)
c
c=======================================================================
c     converts integer days and milliseconds to real seconds
c     input:
c      index = index of any time in tmngr.h
c
c     author:  c. h. goldberg       chg@gfdl.gov
c=======================================================================
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c


c
      realsecs = 86400.0*iday(index) + msday(index)/1000.0
c
      return
      end


      function realdays (index)
c
c=======================================================================
c     converts integer days and milliseconds to real days
c     input:
c      index = index of any time in tmngr.h
c
c     author:  c. h. goldberg       chg@gfdl.gov
c=======================================================================
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c


c
      realdays = iday(index) + msday(index)/86400000.0
c
      return
      end


      function modulo (m, n)
c
c=======================================================================
c     Fortran 90 intrinsic
c     similar to mod, but remainder has sign of n.
c     always gives positive remainder when n .gt. 0, even if m .lt. 0
c
c     author:  c. h. goldberg       chg@gfdl.gov
c=======================================================================
c
      if (m .ge. 0) then
        modulo = mod(m,n)
      else
        modulo = abs(n) - mod(-m-1,n) - 1
      end if
c
      return
      end



      subroutine inittime
c
c=======================================================================
c     initialize time indices for gettime and getfulltime.
c
c     author:  c. h. goldberg       chg@gfdl.gov
c=======================================================================
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c


c
      nextfulltime = 1
      nexttime = nfulltimes + 1
c
      return
      end


      subroutine getfulltime (index)
c
c=======================================================================
c     allocates and returns an index for a full time and increments the
c     next available full time index counter.
c     
c     output:
c      index = index of a full time in tmngr.h
c
c     author:  c. h. goldberg       chg@gfdl.gov
c=======================================================================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c


c
      if (nextfulltime .gt. nfulltimes) then
        write (stdout, "(a,a,i4,a)") '     Too many full times.',
     &                    '  Increase nfulltimes = ', nfulltimes,
     &                    ' in tmngr.h'
        stop 'getfulltime'
      endif
      index = nextfulltime
      nextfulltime = nextfulltime + 1
c
      return
      end


      subroutine gettime (index)
c
c=======================================================================
c     returns an index for a time and increments the next available
c     time index counter.
c     output:
c      index = index of a short time (iday, msday only) in tmngr.h
c
c     author:  c. h. goldberg       chg@gfdl.gov
c=======================================================================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c


c
      if (nexttime .gt. ntimes) then
        write (stdout, "(a,a,i4,a)") '     Too many times.',
     &                    '  Increase ntimes = ', ntimes,
     &                    ' in tmngr.h'
        stop 'gettime'
      endif
      index = nexttime
      nexttime = nexttime + 1
c
      return
      end


      subroutine copyfulltime (index1, index)
c
c=======================================================================
c     copy all fields of a full time structure from one index to
c     another.
c     input:
c      index1 = index of a full time in tmngr.h
c      index  = index of a full time in tmngr.h
c     output:
c      full time fields set for index in tmngr.h
c
c     author:  c. h. goldberg       chg@gfdl.gov
c=======================================================================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c


c
      logical badindex
c
      if (badindex (index1, 'full')) stop 'copyfulltime'
      if (badindex (index,  'full')) stop 'copyfulltime'
      iday  (index) = iday  (index1)
      msday (index) = msday (index1)
      year  (index) = year  (index1)
      month (index) = month (index1)
      day   (index) = day   (index1)
      hour  (index) = hour  (index1)
      minute(index) = minute(index1)
      second(index) = second(index1)
      tstamp (index) = tstamp (index1)
      dayofyear (index) = dayofyear (index1)
      dayofweek (index) = dayofweek (index1)
      daysinmon (index) = daysinmon (index1)
      daysinyear(index) = daysinyear(index1)
c
      return
      end


      subroutine copytime (index1, index)
c
c=======================================================================
c     copy both fields of a short time structure from one index to
c     another.
c     input:
c      index1 = index of a time in tmngr.h
c      index  = index of a short time in tmngr.h
c     output:
c      short time fields set for index in tmngr.h
c
c     author:  c. h. goldberg       chg@gfdl.gov
c=======================================================================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c


c
      logical badindex
c
      if (badindex (index1, 'short')) stop 'copytime'
      if (badindex (index,  'short')) stop 'copytime'
      iday (index) = iday (index1)
      msday(index) = msday(index1)
c
      return
      end


      subroutine settime2 (index, it, mst)
c
c=======================================================================
c     set a time by placing given day and millisecond information in
c     a time structure array indexed by index.
c     input:
c      index  = index of a short time in tmngr.h
c      it     = integer day part
c      mst    = fractional part of day in millisec 
c     output:
c      short time fields set for index in tmngr.h
c
c     author:  c. h. goldberg       chg@gfdl.gov
c=======================================================================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c


c
      logical badindex
c
      if (mst .ge. 86400000 .or. mst .lt. 0) then
        write (stdout, *) '     Invalid millisecond designation'
        stop 'settime2'
      end if
      if (badindex (index,  'short')) stop 'settime2'
      iday(index)  = it
      msday(index) = mst
c
      return
      end


      subroutine settime3 (index, rd)
c
c=======================================================================
c     set a time structure given a time in real days
c     input:
c      index  = index of a short time in tmngr.h
c      rd     = time in real days
c     output:
c      short time fields set for index in tmngr.h
c
c     author:  c. h. goldberg       chg@gfdl.gov
c=======================================================================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c


c
      logical badindex
c
      if (badindex (index,  'short')) stop 'settime3'
c
      iday(index)  = id(rd*86400.0)
      msday(index) = msec(rd*86400.0)
c
      return
      end


      subroutine setfulltime2 (index, it, mst)
c
c=======================================================================
c     set a full time by placing given day and millisecond information
c     in a time structure array indexed by index and expanding it
c     using the d2ymd conversion and making a stamp.
c     input:
c      index  = index of a full time in tmngr.h
c      it     = integer day part
c      mst    = fractional part of day in millisec 
c     output:
c      full time fields set for index in tmngr.h
c
c     author:  c. h. goldberg       chg@gfdl.gov
c=======================================================================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c


c
      logical badindex
c
      if (badindex (index, 'full')) stop 'setfulltime2'
      call settime2 (index, it, mst)
      call d2ymd (it, year(index), month(index), day(index),
     &            dayofyear(index), dayofweek(index), daysinmon(index),
     &            daysinyear(index))
      call ms2hms(mst, hour(index), minute(index), second(index))
      call mkstmp (tstamp(index), year(index), month(index), day(index),
     &             hour(index), minute(index), second(index))
c
      return
      end


      subroutine setfulltime (index, yr, mon, dy, hr, min, sec)
c
c=======================================================================
c     set a full time by specifying the y/m/d, h/m/s and expanding it
c     using the ymd2d conversion and making a stamp.
c     input:
c      index  = index of a full time in tmngr.h
c      yr     = year to set
c      mon    = month to set
c      dy     = day to set
c      hr     = hour to set
c      min    = minute to set
c      sec    = second to set
c     output:
c      full time fields set for index in tmngr.h
c
c     author:  c. h. goldberg       chg@gfdl.gov
c=======================================================================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c


c
      logical badindex
      integer yr, mon, dy, hr, min, sec, hms2ms
c
      if (badindex (index, 'full')) stop 'setfulltime'
      year  (index) = yr
      month (index) = mon
      day   (index) = dy
      hour  (index) = hr
      minute(index) = min
      second(index) = sec
      call ymd2d (yr, mon, dy, iday(index),
     &            dayofyear(index), dayofweek(index),
     &            daysinmon(index), daysinyear(index))     
      msday(index) = hms2ms(hr, min, sec)
      call mkstmp (tstamp(index), yr, mon, dy, hr, min, sec)
c
      return
      end


      subroutine expandtime (index)
c
c=======================================================================
c     expand a full time specified by the y/m/d, h/m/s
c     using the ymd2d conversion and making a stamp.
c     input:
c      index  = index of a full time in tmngr.h
c      y/m/d, h/m/s must be set for time index
c     output:
c      full time fields (iday,msday, tstamp) set for index in tmngr.h
c
c     author:  c. h. goldberg       chg@gfdl.gov
c=======================================================================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c


c
      logical badindex
      integer hms2ms
c
      if (badindex (index, 'full')) stop 'expandtime'
      call ymd2d (year(index), month(index), day(index),
     &            iday(index), dayofyear(index), dayofweek(index),
     &            daysinmon(index), daysinyear(index))     
      msday(index) = hms2ms(hour(index), minute(index), second(index))
      call mkstmp (tstamp(index), year(index), month(index), day(index),
     &             hour(index), minute(index), second(index))
c
      return
      end


      subroutine expandtime2 (index)
c
c=======================================================================
c     expand a full time specified by absolute day and millisecond
c     information using d2ymd conversion and making a stamp.
c     input:
c      index  = index of a full time in tmngr.h
c      iday, msday must be set for time index
c     output:
c      full time fields (year,month,day,hour,minute,second,tstamp)
c      set for index in tmngr.h
c
c     author:  c. h. goldberg       chg@gfdl.gov
c=======================================================================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c

c
      logical badindex
c
      if (badindex (index, 'full')) stop 'expandtime2'
      call d2ymd (iday(index), year(index), month(index),
     &            day(index), dayofyear(index), dayofweek(index),
     &            daysinmon(index), daysinyear(index))
      call ms2hms(msday(index), hour(index), minute(index),
     &            second(index))
      call mkstmp (tstamp(index), year(index), month(index), day(index),
     &             hour(index), minute(index), second(index))
c
      return
      end


      function timeless (index1, index2)
c
c=======================================================================
c     compare times referenced by index1 and index2.  timeless is
c     true if time1 is less than time2.
c
c     authors: c. h. goldberg        chg@gfdl.gov
c              d. j. goldberg
c=======================================================================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c

c

c
      logical timeless, badindex
c
      if (badindex (index1, 'short')) stop 'timeless'
      if (badindex (index2, 'short')) stop 'timeless'
      if (iday(index1) .lt. iday(index2)) then
        timeless = .true.
      elseif ((iday (index1) .eq. iday (index2)) .and.
     &        (msday(index1) .lt. msday(index2))) then
        timeless = .true.
      else
        timeless = .false.
      end if
c
      return
      end


      function timeequal (index1, index2)
c
c=======================================================================
c     compare times referenced by index1 and index2.  timeequal is
c     true if time1 is equal to  time2.
c
c     authors: c. h. goldberg        chg@gfdl.gov
c              d. j. goldberg
c=======================================================================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c

c

c
      logical timeequal, badindex
c
      if (badindex (index1, 'short')) stop 'timeequal'
      if (badindex (index2, 'short')) stop 'timeequal'
      if (iday(index1) .eq. iday(index2) .and. 
     &    msday(index1) .eq. msday(index2)) then
        timeequal = .true.
      else
        timeequal = .false.
      end if
c
      return
      end


      function timemore (index1, index2)
c
c=======================================================================
c     compare times referenced by index1 and index2.  timemore is
c     true if time1 is more than time2.
c
c     authors: c. h. goldberg        chg@gfdl.gov
c              d. j. goldberg
c=======================================================================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c


c
      logical timemore, badindex
c
      if (badindex (index1, 'short')) stop 'timemore'
      if (badindex (index2, 'short')) stop 'timemore'
      if (iday(index1) .gt. iday(index2)) then
        timemore = .true.
      elseif ((iday (index1) .eq. iday (index2)) .and.
     &        (msday(index1) .gt. msday(index2))) then
        timemore = .true.
      else
        timemore = .false.
      end if
c
      return
      end


      function badindex (index, timetype)

c
c=======================================================================
c     check to see if a given index is in bounds in tmngr.h
c     type = 'full'  means a full time
c     type = 'short' means a short time
c
c     authors: c. h. goldberg        chg@gfdl.gov
c              d. j. goldberg
c=======================================================================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c====================== include file "tmngr.h" =========================
c
c                       time manager variables
c
c-----------------------------------------------------------------------
c     time manager inputs:
c-----------------------------------------------------------------------
c
c     how to choose a reference time:
c
c     refrun  = (true,false) to base calculation for diagnostic switches
c              on (the start of each job, other reference time)
c              example:
c              suppose each job submission integrates
c              for one month but the number of days per month changes.
c              setting "refrun" = true and setting
c              "timavgint" = (days in month)/3 will give 3 averaging
c              periods per month of approximately 10 days each. the
c              only restriction is that "timavgint"is an integral number
c              of time steps (if not then "timavgint" is reset to insure
c              this condition. other diagonstic switches do not have
c              this restriction).
c
c     refinit = (true, false) for basing calculation of logical switches
c              on (initial conditions, other reference time)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refinit = true, then they
c              will be done every 20 days starting from initial
c              condition time.
c
c     refuser = (true, false) to base calculations of logical switches
c              on (user-chosen reference time, other reference time)
c              if refuser = true, the user must also supply values for
c              ryear, rmonth, rday, rhour, rmin, rsec (integer)
c              example: if term balances are desired every 20 days
c              (trmbint=20.0) and refuser = true, then they will be done
c              every 20 days counting from reference time, ignoring the
c              initial condition time. for comparing diagnostics from
c              various experiments with different initial condition
c              times, refuser = true will be more appropriate. setting
c              refuser = true and choosing the reference time to be
c              the initial condition time is the same as refinit = true.
c
c     summary of how to choose the time for referencing calculations
c     of logical switches
c
c     refrun  = T ==>  referenced to the start of each run
c     refinit = T ==>  referenced to initial condition time given by:
c                     year0, month0, day0, hour0, min0, sec0
c     refuser = T ==>  referenced to user specified reference time so
c                     must set: ryear, rmonth, rday, rhour, rmin, rsec
c
c-----------------------------------------------------------------------
c
c     time variable arrays
c
c     arrays "iday" and "msday" contain the primary internal 
c     representation of all times within the time manager. they are
c     referenced by using a subscript to indicate which time.
c
c     iday    = integer days (since Dec 31, 1899 when specifying a date)
c     msday   = non-negative integer milliseconds after midnight
c
c     it is desirable to have time information expanded to include the
c     following secondary time fields:
c
c     year       = 
c     month      = 
c     day        = 
c     hour       = 
c     minute     = 
c     second     =
c     tstamp     = 32 character date and time stamp m/d/y h:m:s
c     dayofyear  = integer day of the year (1..yrlen)
c     dayofweek  = 1=sun - 7=sat
c     daysinmon  = days in the month
c     daysinyear = days in the year
c
c     those times for which primary and secondary information is 
c     maintained by the time manager are called "full times". those for
c     which only primary information is kept are called "short times"
c
c     indices to  "full times" (including year, month ,day, etc).
c
c     itime     = simulation time corresponding to "itt"
c     initial   = time of the initial conditions
c     irunstart = time of the start of the run
c     iuser     = user defined reference time
c     iref      = one of the three above selected by logicals
c                 (refinit, refrun, refuser)
c
c     indices to  "short times". ("iday", "msday" only)
c
c     isunday    = time of a sunday for week and two week switches
c     ihalfstep  = dt/2 beyond itime
c     imodeltime = time since initial conditions
c     iruntime   = time since run start
c     iusertime  = time since user specified reference time
c     idt        = integer days and milliseconds of dt
c     idtd2      = integer days and milliseconds of dt/2
c
c     ireftime   = time used locally in alarm function
c
c     for any time index (short or full) the internal representation
c     may be converted to either real days or real seconds using
c     the functions:
c                  realdays(index)
c                  realsecs(index)
c
c     dayoyr  = relative day number referenced to the beginning
c               of the current year.  (real)
c     relyr   = number of years (and fractional years) of model
c               integration (for time tau+1 {itt}) relative to 
c               initial condition
c     prelyr  = relyr for previous time step
c
c     stamp   = 32 character date and time for current model timestep
c     pstamp  = 32 character date and time for previous model timestep
c
c     itt     = current time step counter (from initial cond.)
c     itt0    = time step at start of current run
c
c               variables used for initialization
c
c     irstdy  = integer number of days at start of run
c     msrsdy  = fractional day in millisec at start of run
c
c     year0   = year of initial conditions
c     month0  = month of initial conditions
c     day0    = day of initial conditions
c     hour0   = hour of initial conditions
c     min0    = minute of initial conditions
c     sec0    = second of initial conditions  
c     
c     ryear   = year of user specified reference time
c     rmonth  = month of user specified reference time
c     rday    = day of user specified reference time
c     rhour   = hour of user specified reference time
c     rmin    = minute of user specified reference time
c     rsec    = second of user specified reference time  
c
c-----------------------------------------------------------------------
c
c
      logical refrun, refinit, refuser
c
      parameter (ntimes = 100, nfulltimes = 20)
      integer iday(ntimes), msday(ntimes)
      integer year(nfulltimes), month(nfulltimes), day(nfulltimes)
      integer hour(nfulltimes), minute(nfulltimes), second(nfulltimes)
      integer dayofyear(nfulltimes), dayofweek(nfulltimes)
      integer daysinmon(nfulltimes), daysinyear(nfulltimes)
      integer year0, month0, day0, hour0, min0, sec0
      integer ryear, rmonth, rday, rhour, rmin, rsec
      character *32 tstamp(nfulltimes), pstamp, stamp
c
      common /tmngrl/ refrun, refinit, refuser
c
      common /tmngrii/ nextfulltime, nexttime
      common /tmngrii/ initial, iref, irunstart, itime, iuser
      common /tmngrii/ iruntime, imodeltime, ireftime, iusertime
      common /tmngrii/ ihalfstep, isunday
      common /tmngrii/ itemptime,itemptime2,itmptime,itmptime2,itmptime3
      common /tmngrii/ idt, idtd2
      common /tmngrii/ iday, msday
      common /tmngrii/ year, month, day, hour, minute, second
      common /tmngrii/ dayofyear, dayofweek, daysinmon, daysinyear
      common /tmngrii/ itt0, itt, irstdy, msrsdy
c
      common /tmngrr/ dayoyr
      common /tmngrr/ relyr, prelyr
c
      common /tmngrc/ tstamp, stamp, pstamp
c
      common /tmngrii/ year0, month0, day0, hour0, min0, sec0
      common /tmngrii/ ryear, rmonth, rday, rhour, rmin, rsec
c

c
      logical badindex
      character *(*) timetype
c
      if (timetype .eq. 'full') then
        if (index .lt. 1 .or. index .gt. nfulltimes) then
          badindex = .true.
          print *, '     Invalid full time index = ',index
        else
          badindex = .false.
        end if
      else
        if (index .lt. 1 .or. index .gt. ntimes) then
          badindex = .true.
          print *, '     Invalid time index = ',index
        else
          badindex = .false.
        end if
      end if
c
      return
      end





      function indp (value, array, ia)
c
c=======================================================================
c
c     indp = index of nearest data point within "array" corresponding to
c            "value".
c
c     inputs:
c
c     value  = arbitrary data...same units as elements in "array"
c     array  = array of data points  (must be monotonically increasing)
c     ia     = dimension of "array"
c
c     output:
c
c     indp =  index of nearest data point to "value"
c             if "value" is outside the domain of "array" then indp = 1
c             or "ia" depending on whether array(1) or array(ia) is
c             closest to "value"
c
c             note: if "array" is dimensioned array(0:ia) in the calling
c                   program, then the returned index should be reduced
c                   by one to account for the zero base.
c
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c
c     example:
c
c     let model depths be defined by the following:
c     parameter (km=5)
c     dimension z(km)
c     data z /5.0, 10.0, 50.0, 100.0, 250.0/
c
c     k1 = indp (12.5, z, km)
c     k2 = indp (0.0, z, km)
c
c     k1 would be set to 2, & k2 would be set to 1 so that
c     z(k1) would be the nearest data point to 12.5 and z(k2) would
c     be the nearest data point to 0.0
c
c=======================================================================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c
      dimension array(ia)
c
      do i=2,ia
        if (array(i) .lt. array(i-1)) then
	  write (stdout,*)
     &   ' => Error: array must be monotonically increasing in "indp"' 
     &,  '           when searching for nearest element to value=',value 
	  write (stdout,*) '           array(i) < array(i-1) for i=',i 
          write (stdout,*) '           array(i) for i=1..ia follows:'
	  do ii=1,ia
	    write (stdout,*) 'i=',ii, ' array(i)=',array(ii)
          enddo
	  stop '=>indp'
	endif
      enddo
      if (value .lt. array(1) .or. value .gt. array(ia)) then
        if (value .lt. array(1))  indp = 1
        if (value .gt. array(ia)) indp = ia
        return
      else
        do i=2,ia
          if (value .le. array(i)) then
            indp = i
            if (array(i)-value .gt. value-array(i-1)) indp = i-1
            go to 101
          endif
        enddo
101     continue
      endif
      return
      end

      subroutine ftc (f, if, jf, xf, yf, c, ic, jc, istart, iend
     &,               jstart, jend, xc, yc, init, work, lenw)
c
c=======================================================================
c
c     "ftc" is a nemonic for "fine to coarse".
c
c     obtain a coarse grid representaion of a fine grid dataset by area
c     averaging grid boxe values on the fine grid which overlay coarse 
c     grid boxes. note: the coarse grid boxes do not have to contain an
c     integral number of fine grid boxes.
c
c
c     inputs:
c
c     f      = data on fine grid
c     if     = inner dimension of "f"
c     jf     = outer dimension of "f"
c     xf     = coordinates for inner dimension of "f" (eg: longitues)
c     yf     = coordinates for outer dimension of "f" (eg: latitues)
c
c     ic     = inner dimension of coarse grid "c"
c     jc     = outer dimension of coarse grid "c"
c     istart = starting index along inner dimension of "c" for which
c              averaged values are desired
c     iend   = ending index along inner dimension of "c" for which
c              averaged values are desired
c     jstart = starting index along outer dimension of "c" for which
c              averaged values are desired
c     jend   = ending index along outer dimension of "c" for which
c              averaged values are desired
c     xc     = coordinates for inner dimension of "c" (eg: longitues)    
c     yc     = coordinates for outer dimension of "c" (eg: latitues)    
c     init   = initialize the averaging factors
c              "init" should be set = 1 on the first call. 
c              "init" <> 1 uses the previously computed factors stored
c              in "work" array.
c     work   = work array of averaging factors when "init" <> 1
c              (previously calculated by "ftc" when "init" = 1)
c     lenw   = size of work array. lenw should be >= 9*max(if,jf)
c       
c     output:
c
c     c  = coarse grid average of "f" defined over
c          ((c(i,j),i=istart,iend),j=jstart,jend)
c     work   = work array of averaging factors when "init" = 1
c
c     restrictions:
c
c     fine and coarse grids are assumed rectangular with "xf" and "xc"
c     having the same units. "yf" and "yc" must also have the same units
c     the coarse domain xc(istart)...xc(iend) must be within 
c     the fine domain xf(1)...xf(if). similarly,
c     yc(jstart)...yc(jend) must be within yf(1)...yf(jf). all 
c     coordinates must be strictly monotonically increasing.
c 
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c=======================================================================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
      logical error, show_coord
      parameter (len=10000, p5=0.5, c0=0.0)
      dimension iso(0:len), ieo(0:len), jso(0:len), jeo(0:len)
     &,         dx(0:len,2), dy(0:len,2), edgecx(0:len), edgecy(0:len)
     &,         edgefx(0:len), edgefy(0:len)
      dimension f(if,jf), xf(if), yf(jf)
      dimension c(ic,jc), xc(ic), yc(jc)
      dimension work(lenw)
c
        write (stdout,*) ' '
	write (stdout,*)
     & '            Averaging data from "fine" to "coarse" grid'
c
c-----------------------------------------------------------------------
c     initialize weights or use previously calculated weights
c-----------------------------------------------------------------------
c
      if (init .eq. 1) then
        error = .false.
	write (stdout,*)
     & '              (initializing the averaging weights)'
        write (stdout,*) ' '
c
c       test to verify that array sizes do not exceed limits
c
        if (if .gt. len .or. jf .gt. len) then
          i = max(if,jf)
          write (stdout,*) '=>Error: increase "len" in "ftc" to ',i
          stop '=>ftc'        
        endif
	if (lenw .lt. 9*max(if,jf)) then
          write (stdout,*) '=>Error: increase size of "work" array',
     &      ' to at least ',9*max(if,jf),' for calls to "ftc"'
	  error = .true.
        endif
c
c       verify that the "coarse" grid lies within the "fine" grid
c
        if (xf(1) .gt. xc(istart) .or. xf(if) .lt. xc(iend)) then
          write (stdout,*)
     &     '=>Warning: Coarse grid "xc" is outside "fine" grid "xf".'
          if (xf(1) .gt. xc(istart)) then
	    write (stdout,*) '  xc(',istart,')  .lt.  xf(1)'  
	  endif
          if (xf(if) .lt. xc(iend)) then
	    write (stdout,*) '  xc(',iend,')  .gt.  xf(',if,')'  
	  endif
        endif 
        if (yf(1) .gt. yc(jstart) .or. yf(jf) .lt. yc(jend)) then
          write (stdout,*)
     &     '=>Warning: Coarse grid "yc" is outside "fine" grid "yf".'
          if (yf(1) .gt. yc(jstart)) then
	    write (stdout,*) '  yc(',jstart,') .lt. yf(1)' 
	  endif
          if (yf(jf) .lt. yc(jend)) then
	    write (stdout,*) '  yc(',jend,')  .gt.  yf(',jf,')'  
	  endif
        endif
c
c       construct edges of "coarse" grid boxes
c
        do i=1,ic-1
	  edgecx(i) = p5*(xc(i) + xc(i+1))
        enddo
        edgecx(0)  = xc(1) - (edgecx(1) - xc(1))
	edgecx(ic) = xc(ic) + (xc(ic) - edgecx(ic-1))
c
        do j=1,jc-1
	  edgecy(j) = p5*(yc(j) + yc(j+1))
        enddo
        edgecy(0)  = yc(1) - (edgecy(1) - yc(1))
	edgecy(jc) = yc(jc) + (yc(jc) - edgecy(jc-1))
c
c       construct edges of "fine" grid boxes
c
        do i=1,if-1
	  edgefx(i) = p5*(xf(i) + xf(i+1))
        enddo
        edgefx(0)  = xf(1) - (edgefx(1) - xf(1))
	edgefx(if) = xf(if) + (xf(if) - edgefx(if-1))
c
        do j=1,jf-1
	  edgefy(j) = p5*(yf(j) + yf(j+1))
        enddo
        edgefy(0)  = yf(1) - (edgefy(1) - yf(1))
	edgefy(jf) = yf(jf) + (yf(jf) - edgefy(jf-1))
c
c       calculate "dx" and "dy" for the "fine" grid boxes
c
	do i=1,if
	  dx(i,1) = edgefx(i) - edgefx(i-1)       
	  dx(i,2) = dx(i,1)
        enddo
	dx(0,1) = dx(1,1)
	dx(0,2) = dx(1,2)
c
	do j=1,jf
	  dy(j,1) = edgefy(j) - edgefy(j-1)
	  dy(j,2) = dy(j,1)
        enddo
	dy(0,1) = dy(1,1)
	dy(0,2) = dy(1,2)
c
c       modify "dx" and "dy" for possibly partial "fine" grid boxes 
c       near the edges of each coarse grid box.
c       "ii" is the index of the fine grid box which contains the
c       eastern edge of coarse grid box with index "i".
c       dx(ii,1) is the portion of the fine grid box to the west of the
c       edge and dx(ii,2) is the portion to the east. similarly,
c       dy(jj,1) is to the south and dy(jj,2) is to the north of the
c       northern edge of coarse box with index "j".
c        
c       note: edgefx and edgefy are zero based and need the -1 when
c       using "indp" 
c
        do i=0,ic
	  ii   = indp (edgecx(i), edgefx, if+1) - 1
	  frac = abs(edgecx(i) - edgefx(ii))
	  if (edgefx(ii) .lt. edgecx(i)) then
	    ii = ii + 1
	    dx(ii,2) = (edgefx(min(if,ii)) - edgefx(ii-1)) - frac
	    dx(ii,1) = frac
	  else
	    dx(ii,2) = frac
	    dx(ii,1) = (edgefx(ii) - edgefx(max(ii-1,0))) - frac
	  endif
	  ieo(i) = min(if,max(1,ii))
        enddo
        do i=1,ic
	  iso(i) = max(1,ieo(i-1))
        enddo
        iso(0) = ieo(0)
c
        do j=0,jc
	  jj   = indp (edgecy(j), edgefy, jf+1) - 1
	  frac = abs(edgecy(j) - edgefy(jj))
	  if (edgefy(jj) .lt. edgecy(j)) then
	    jj = jj + 1
	    dy(jj,2) = (edgefy(min(jf,jj)) - edgefy(jj-1)) - frac
	    dy(jj,1) = frac
	  else
	    dy(jj,2) = frac
	    dy(jj,1) = (edgefy(jj) - edgefy(max(jj-1,0))) - frac
	  endif
	  jeo(j) = min(jf,max(1,jj))
        enddo
        do j=1,jc
	  jso(j) = max(1,jeo(j-1))	
        enddo
        jso(0) = jeo(0)
c
c       store the weights into the "work" array
c
        indx = 1
        do j=0,jc
	  work(indx)   = jso(j)
	  work(indx+1) = jeo(j)
	  indx         = indx + 2
        enddo
c
        do i=0,ic
	  work(indx)   = iso(i)
	  work(indx+1) = ieo(i)
	  indx         = indx + 2
        enddo
c
        do j=0,jf
	  work(indx)   = dy(j,1)
	  work(indx+1) = dy(j,2)
	  indx         = indx + 2
        enddo
c
        do i=0,if
	  work(indx)   = dx(i,1)
	  work(indx+1) = dx(i,2)
	  indx         = indx + 2
        enddo
c
c       verify that coarse grid is coarser than the fine grid
c
        do j=jstart,jend
	  if ((jso(j) .eq. jso(j+1)) .and. (yc(j) .ge. yf(1))
     &      .and. (yc(j) .le. yf(jf))) then
            write (stdout,*)
     &         '=>Warning: "Coarse" grid is finer than "fine" grid'
     &,     ' near yf(',jso(j),') =',yf(jso(j))
     &,     ' (average may not be accurate)'
	  endif
        enddo
c
        do i=istart,iend
	  if ((iso(i) .eq. iso(i+1)) .and. (xc(i) .ge. xf(1))
     &      .and. (xc(i) .le. xf(if))) then
            write (stdout,*)
     &	    '=>Warning: "Coarse" grid is finer than "fine" grid'
     &,     ' near xf(',iso(i),') = ',xf(iso(i))
     &,     ' (average may not be accurate)'
	  endif
        enddo

        show_coord = .true.
        print '(/a/)'
     &,   'Use -Dskip_interp_details to not show the following'

        if (error .or. show_coord) then
          write (stdout,*)
     & ' Indices for averaging fine grid to coarse grid:'
          write (stdout,*)
     & ' (fractional grid boxes are accounted for)'
          write (stdout,8700)
          write (stdout,9000) (m,iso(m),ieo(m),m=istart,iend)
	  write (stdout,*) ' '
          write (stdout,*) ' Coordinates for coarse grid points "xc" ='
          write (stdout,8500) xc
          write (stdout,*) ' Coordinates for fine grid points "xf" ='
          write (stdout,8500) xf
c
          write (stdout,8800)
          write (stdout,9000) (m,jso(m),jeo(m),m=jstart,jend)
	  write (stdout,*) ' '
          write (stdout,*) ' Coordinates for coarse grid points "yc" ='
          write (stdout,8500) yc
          write (stdout,*) ' Coordinates for fine grid points "yf" ='
          write (stdout,8500) yf
        endif
        if (error) stop '=>ftc'
      else
	write (stdout,*)
     & '              (using previously initialized averaging weights)'
        write (stdout,*) ' '
c
c       extract the weights from the "work" array
c
        indx = 1
        do j=0,jc
	  jso(j) = nint(work(indx))   
	  jeo(j) = nint(work(indx+1))
	  indx   = indx + 2
        enddo
c
        do i=0,ic
	  iso(i) = nint(work(indx))
	  ieo(i) = nint(work(indx+1))
	  indx   = indx + 2
        enddo
c
        do j=0,jf
	  dy(j,1) = work(indx)
	  dy(j,2) = work(indx+1)
	  indx    = indx + 2
        enddo
c
        do i=0,if
	  dx(i,1) = work(indx)
	  dx(i,2) = work(indx+1)
	  indx    = indx + 2
        enddo
      endif
c
c-----------------------------------------------------------------------
c     average the "fine" grid to the "coarse" grid
c-----------------------------------------------------------------------
c
      do m=jstart,jend
        do i=istart,iend
          weight = c0
          sum    = c0
          do j=jso(m),jeo(m)
	    indy = 2
	    if (j .eq. jeo(m)) indy = 1
	    wty = dy(j,indy)
            do ii=iso(i),ieo(i)
	      indx = 2
	      if (ii .eq. ieo(i)) indx = 1
              area   = dx(ii,indx)*wty
              weight = weight + area
              sum    = sum + f(ii,j)*area
            enddo
          enddo
          c(i,m) = sum/weight
        enddo
      enddo
      return
8500  format (1x,10g11.4)
8700  format (/' Along the 1st dimension, the form is (Coarse grid'
     &,' point "xc": range of fine grid points "xf" to average)'/)
8800  format (/' Along the 2nd dimension, the form is (Coarse grid'
     &,' point "yc": range of fine grid points "yf" to average)'/)
9000  format (5(1x,'(',i4,': ',i4,' to ',i4,')'),/)
      end


      subroutine ctf (c, ic, jc, xc, yc, f, if, jf, istart, iend
     &,               jstart, jend, xf, yf, init, work, lenw)
c
c=======================================================================
c
c     "ctf" is a nemonic for "coarse to fine".
c
c     obtain a fine grid representaion of a coarse grid dataset by 
c     linear interpolation of grid box values on the coarse grid to grid   
c     boxes on the fine grid.
c
c
c     inputs:
c
c     c      = coarse grid data
c     ic     = inner dimension of coarse grid "c"
c     jc     = outer dimension of coarse grid "c"
c     xc     = coordinates for inner dimension of "c" (eg: longitues)    
c     yc     = coordinates for outer dimension of "c" (eg: latitues)    
c
c     if     = inner dimension of "f"
c     jf     = outer dimension of "f"
c     xf     = coordinates for inner dimension of "f" (eg: longitues)
c     yf     = coordinates for outer dimension of "f" (eg: latitues)
c
c     istart = starting index along inner dimension of "f" for which
c              interpolated values are desired
c     iend   = ending index along inner dimension of "f" for which
c              interpolated values are desired
c     jstart = starting index along outer dimension of "f" for which
c              interpolated values are desired
c     jend   = ending index along outer dimension of "f" for which
c              interpolated values are desired
c     init   = initialize the interpolation factors
c              "init" should be set = 1 on the first call. 
c              "init" <> 1 uses the previously computed factors stored
c              in "work" array.
c     work   = work array of interpolation factors when "init" <> 1
c              (previously calculated by "ctf" when "init" = 1)
c     lenw   = size of work array. lenw should be >= 8*max(if,jf)
c       
c     output:
c
c     f      = interplated data on fine grid defined over
c              ((f(i,j),i=istart,iend),j=jstart,jend)
c     work   = work array of interpolation factors when "init" = 1
c
c     restrictions:
c
c     fine and coarse grids are assumed rectangular with "xf" and "xc"
c     having the same units. "yf" and "yc" must also have the same units
c     the fine domain xf(istart)...xf(iend) must be within 
c     the coarse domain xc(1)...xc(ic). Similarly,   
c     and yc(js)...yc(je) must be within yf(1)...yf(jf). all coordinates
c     must be strictly monotonically increasing.
c 
c
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c=======================================================================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
      logical error, show_coord
      parameter (len=10000, p5=0.5, c0=0.0)
      dimension indxi(len), indxj(len), dnorth(len), dsouth(len)
     &,         deast(len), dwest(len), width(len), height(len)
      dimension f(if,jf), xf(if), yf(jf)
      dimension c(ic,jc), xc(ic), yc(jc)
      dimension work(lenw)
c
        write (stdout,*) ' '
	write (stdout,*) 
     & '            Interpolating data from "coarse" to "fine" grid'
c
c-----------------------------------------------------------------------
c     initialize weights or use previously calculated weights
c-----------------------------------------------------------------------
c
      if (init .eq. 1) then
        error = .false.
	write (stdout,*) 
     & '              (initializing interpolation weights)'
        write (stdout,*) ' '
c
c       test to verify that array sizes do not exceed limits
c
        if (if .gt. len .or. jf .gt. len) then
          i = max(if,jf)
          write (stdout,*) '=>Error: increase "len" in "ctf" to ',i
	  error = .true.
        endif
	if (lenw .lt. 8*max(if,jf)) then
          write (stdout,*) '=>Error: increase size of "work" array',
     &      ' to at least ',8*max(if,jf),' for calls to "ctf"'
	  error = .true.
        endif
c
c       verify that the "fine" grid lies within the "coarse" grid
c
        epsilon = 1.e-5
        xcminus = xc(1) - epsilon*(xc(2)-xc(1))
	xcplus = xc(ic) + epsilon*(xc(ic)-xc(ic-1))
        if (xf(istart) .lt. xcminus .or. xf(iend) .gt. xcplus) then
	  error = .true.
          write (stdout,*)
     &	  '=>Warning: "fine" grid outside "coarse" grid in "ctf".'
          if (xf(istart) .lt. xc(1)) then
	    write (stdout,*) '  xf(',istart,')  .lt.  xc(1)'  
	  endif
          if (xc(ic) .lt. xf(iend)) then
	    write (stdout,*) '  xf(',iend,')  .gt.  xc(',ic,')'  
	  endif
        endif 
        ycminus = yc(1) - epsilon*(yc(2)-yc(1))
	ycplus = yc(jc) + epsilon*(yc(jc)-yc(jc-1))
        if (ycminus .gt. yf(jstart) .or. ycplus .lt. yf(jend)) then
	  error = .true.
          write (stdout,*)
     &	  '=>Warning: "fine" grid outside "coarse" grid in "ctf".'
          if (yc(1) .gt. yf(jstart)) then
	    write (stdout,*) '  yf(',jstart,') .lt. yc(1)' 
	  endif
          if (yc(jc) .lt. yf(jend)) then
	    write (stdout,*) '  yf(',jend,')  .gt.  yc(',jc,')'  
	  endif
        endif
c
c       find interpolation factors 
c
        indx = 1
        do j=jstart,jend
	  jj = indp (yf(j), yc, jc)
	  if (yc(jj) .gt. yf(j) .or. jj .eq. jc) jj = jj - 1
	  indxj(j) = jj
	  dnorth(j) = yc(jj+1) - yf(j)
	  dsouth(j) = yf(j) - yc(jj)
	  height(j) = yc(jj+1) - yc(jj)
c
c         store into "work" array for future use (when "init" <> 1)
c
          work(indx)   = indxj(j)
	  work(indx+1) = dnorth(j)
	  work(indx+2) = dsouth(j)
	  work(indx+3) = height(j)
	  indx         = indx + 4
        enddo
c
        do i=istart,iend
	  ii = indp (xf(i), xc, ic)
	  if (xc(ii) .gt. xf(i) .or. ii .eq. ic) ii = ii - 1
	  indxi(i) = ii
	  deast(i) = xc(ii+1) - xf(i)
	  dwest(i) = xf(i) - xc(ii)
	  width(i) = xc(ii+1) - xc(ii)
c
c         store into "work" array for future use (when "init" <> 1)
c
          work(indx)   = indxi(i)
	  work(indx+1) = deast(i)
	  work(indx+2) = dwest(i)
	  work(indx+3) = width(i)
	  indx         = indx + 4
        enddo

        show_coord = .true.
        print '(/a/)'
     &,   'Use -Dskip_interp_details to not show the following'

        if (error .or. show_coord) then
	  write (stdout,*) ' '
          write (stdout,*) ' Coordinates for coarse grid points "xc" ='
          write (stdout,8500) xc
	  write (stdout,*) ' Coordinates for fine grid points "xf" ='
          write (stdout,8500) xf

          write (stdout,*) ' Coordinates for coarse grid points "yc" ='
          write (stdout,8500) yc
          write (stdout,*) ' Coordinates for fine grid points "yf" ='
          write (stdout,8500) yf
        endif
	if (error) stop '=>ctf'
      else
c
c       extract previously calculated interpolation weights from "work"
c
	write (stdout,*) 
     &'      (using previously initialized interpolation weights)'
c
        indx = 1
        do j=jstart,jend
          indxj(j)  = nint(work(indx))
	  dnorth(j) = work(indx+1)
	  dsouth(j) = work(indx+2)
	  height(j) = work(indx+3)
	  indx      = indx + 4
        enddo
c
        do i=istart,iend 
          indxi(i) = nint(work(indx))
	  deast(i) = work(indx+1)
	  dwest(i) = work(indx+2)
	  width(i) = work(indx+3)
	  indx     = indx + 4
        enddo
      endif
c
c-----------------------------------------------------------------------
c     interpolate data from "coarse" to "fine" grid
c-----------------------------------------------------------------------
c
      do jj=jstart,jend
        j = indxj(jj)
        do ii=istart,iend
	  i = indxi(ii)
	  f(ii,jj) = (c(i,j)    *deast(ii)*dnorth(jj)
     &              + c(i+1,j)  *dwest(ii)*dnorth(jj)
     &              + c(i,j+1)  *deast(ii)*dsouth(jj)
     &              + c(i+1,j+1)*dwest(ii)*dsouth(jj)) / 
     &               (width(ii)*height(jj))
        enddo
      enddo
c
      return
8500  format (1x,10g11.3)
      end


      subroutine extrap (a, land, sor, res, il, jl, maxscn, crit, text
     &,                  gtype)
c
c=======================================================================
c
c     utility to extrapolate values into land areas neglecting
c     non-uniformity or asymmetry in the grid by solving a simple
c     heat eqn: del**2(a) = 0 over land areas using values over ocean
c     areas as boundary conditions.
c     this alleviates the problem of mismatched land/sea areas due to
c     different geometries or resolutions when interpolating between
c     atmospheric and ocean model grids.
c     the intent is to force reasonable values into land areas
c     near coastlines. far from coasts, the extrapolations may not be
c     reasonable.
c
c     note: the values over land are used as an initial guess field
c           and need to be specified
c
c
c     inputs:
c
c     a       = array with land areas to be filled. land areas contain
c               initial guess field.
c     land    = mask = (0, non zero) to indicate (land, non land) area
c     il      = number of points along 1st dimension to be filled
c     jl      = number of points along 2nd dimension to be filled
c     maxscn  = maximum number of passes allowed in relaxation
c     crit    = criterion for ending relaxation before "maxscn" limit
c     text    = character string (up to 15 chars) to identify data
c     gtype   = grid type = (1,2) to identify (ocean, atmosphere) grid
c     sor     = scratch area
c     res     = scratch area
c
c
c     outputs:
c
c     a       = array with extrapolated values in land areas.
c               non land areas remain unchanged.
c
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c=======================================================================
c
      logical done
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
      integer gtype
      character*(*) text
      parameter (c0=0.0, p25=0.25)
      dimension a(il,jl), land(il,jl), res(il,jl), sor(il,jl)
c
c-----------------------------------------------------------------------
c
c     solve a simple poisson eqn by relaxation to extrapolate data into
c     land areas using values over non land areas as boundary values.
c
c     note: sucessive calls to extrap will require fewer scans beacuse
c           the initial guess field over land areas gets better with
c           each call.
c-----------------------------------------------------------------------
c
c
c     check on the grid type: atmosphere or ocean
c
      if (gtype .ne. 1 .and. gtype .ne. 2) then
        write (stdout,98) gtype
        stop '=>extrap'
      endif     
c
c-----------------------------------------------------------------------
c     set the relaxation coefficient to zero over ocean or air
c     relc is somewhat arbitrary
c-----------------------------------------------------------------------
c
      relc = 0.6
      do j=1,jl
        do i=1,il
          if (land(i,j) .eq. 0) then
            sor(i,j) = relc
          else
            sor(i,j) = c0
          endif
        enddo
      enddo
c
c-----------------------------------------------------------------------
c     iterate until errors are acceptable.
c-----------------------------------------------------------------------
c     
      n = 0
100   continue
        resmax = c0
        done   = .true.
        n    = n + 1
        do j=2,jl-1
          do i=2,il-1
            res(i,j) = p25*(a(i-1,j) + a(i+1,j) + a(i,j-1) + a(i,j+1)) 
     &                 - a(i,j)
          enddo
        enddo
        do j=2,jl-1
          do i=2,il-1
            res(i,j) = res(i,j)*sor(i,j)
            a(i,j) = a(i,j) + res(i,j)
            absres = abs(res(i,j))
            if (absres .gt. crit) done = .false.
            resmax = max(absres,resmax)
          enddo
        enddo
c
c-----------------------------------------------------------------------
c       set conditions at edge of grid
c-----------------------------------------------------------------------
c
        if (gtype .eq. 1) then
c
c         use cyclic or no flux conditions on ocean grids
c
          do j=1,jl

            a(1,j)  = a(2,j)
            a(il,j) = a(il-1,j)

          enddo
        elseif (gtype .eq. 2) then
c
c         always put cyclic conditions on atmosphere grids
c
          do j=1,jl
            a(1,j)  = a(il-1,j)
            a(il,j) = a(2,j)
          enddo
        endif
c
c       no flux condition at northern and southern boundaries
c
        do i=1,il
          a(i,1)  = a(i,2)
          a(i,jl) = a(i,jl-1)
          enddo
c
      if (.not. done .and. n .le. maxscn) go to 100
c
      write (stdout,99) text, n, resmax
99    format (1x,'==> Extrapolated ',a15,' into land using ',i4
     &,       ' scans.  max residual=', g14.7)
98    format (1x,'==> Error:   gtype =',i6,' in extrap')
      return
      end



      subroutine setbcx (a, imt, jmtorkm)
c
c=======================================================================
c     set zonal boundary condition on the first index of array "a" for
c     every second index. the first index corresponds to the "x"
c     or longitude direction. 
c
c     input:
c      a = array in need of setting the zonal b.c.
c     output
c      a = array with zonal b.c. set 
c=======================================================================
c
      dimension a(imt,jmtorkm)
      do k=1,jmtorkm


        a(1,k)   = 0.0


	a(imt,k) = 0.0


      enddo
      return
      end


      subroutine iplot (iarray, im, il, jl)
c
c=======================================================================
c      map integer array "iarray" into characters for printing with
c      format (a1) to provide a contour map of the integer field.
c      note: max number of unique characters = 80
c
c     inputs:
c
c     iarray = integer array to be plotted
c     im     = inner dimension of "iarray"
c     il     = number of points along inner dimension to plot (along x)
c     jl     = number of points along outer dimension to plot (along y)
c
c     output: prints contour map of "iarray"
c
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c=======================================================================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
      dimension iarray(im,jl)
      character*80 levels
      character*80 lev1
      save levels
      write (stdout,*) ' '
c
c     set character markers
c

      lev1(1:51) = '.+*ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuv'
      levels = lev1(1:51)//'wxyz0123456789-=!@#$%<>[]{}()'

c
c     find range of integers
c
      maxint = iarray(1,1)
      minint = iarray(1,1)
      do j=1,jl
        do i=1,il
          maxint = max(maxint,iarray(i,j))
          minint = min(minint,iarray(i,j))
        enddo
      enddo
c
c     show mapping of integers into characters
c
      write (stdout,*) ' '
      write (stdout,*)
     & ' "iplot" mapping of integers to characters is as follows:'
      inc  = 3
      last = min(minint+80-1,maxint) 
      do i=minint,last,inc
        ii = i-minint+1
	if (i+inc .le. last) then
	  jinc = inc
	else
	  jinc = last-i+1
	endif
	write (stdout,'(6(1x,i6,a,a,3x))') 
     &  (j+minint-1," is printed as ",levels(j:j),j=ii,ii+jinc-1)
      enddo
      write (stdout,*) ' '
c
      if (maxint - minint + 1 .gt. 80) then
        write (stdout,*)
     & ' => Note: there are ',maxint-minint+1,' integers in the field'
        write (stdout,*) '          "iplot" cannot uniquely assign '
     &,' more than 80 characters for plotting symbols.'
        write (stdout,*) '          therfore integers are'
     &, ' represented by cyclicly reusing the list of plotting symbols'
        write (stdout,*) '   '
      endif
c
c     print character representation of integers
c
      inc=124
      do l=0,il,inc
        incr = min(inc,il-l)
        write (stdout,8800) (l+i,i=1,incr,4)
        do  jj=1,jl
          j  = jl+1-jj
c          write (stdout,8900) j, (levels(min(80,iarray(l+i,j)-minint+1):
c     &                        min(80,iarray(l+i,j)-minint+1)),i=1,incr) 
          write (stdout,8900) j, 
     &  (levels(mod(iarray(l+i,j)-minint+1-1,80)+1:
     &          mod(iarray(l+i,j)-minint+1-1,80)+1),i=1,incr) 
        enddo
      enddo
      return
8800  format (/, 2x, 31i4)
8900  format (1x,i3,1x, 124a1)
      end


      subroutine imatrx (iarray, im, istrt, iend, jstrt, jend, iform)
c
c=======================================================================
c      integer matrix print with various formats
c
c     inputs:
c
c     iarray = integer array to be printed
c     im     = the 1st dimension of array
c     istrt  = starting index along 1st dimension for plot
c     iend   = ending index along 1st dimension for plot
c     jstrt  = starting index along 2nd dimension for plot
c     jend   = ending index along 2nd dimension for plot
c              note: if jstrt and jend are negative then the vertical
c                   y-axis is inverted.
c     iform  = format designator: 1 => format (i1) 
c                                 2 => format (i2)
c                                 3 => format (i3)
c                                 4 => format (i4)
c
c
c     output: print integer "iarray" with user format control
c
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c=======================================================================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
      dimension iarray(im,1000)
c
c     choose the plotting domain
c
      js = min(abs(jstrt),abs(jend))
      je = max(abs(jstrt),abs(jend))
      is = min(abs(istrt),abs(iend))
      ie = max(abs(istrt),abs(iend))
      il = ie-is+1
c
      write (stdout,*) ' '
      if (iform .eq. 1) then
c
c       use I1 format to print the integer array
c
        inc=120
        do l=0,il,inc
          incr = min(inc,il-l)
          write (stdout,8800) (l+i+is-1,i=1,incr,4)
          do jj=js,je
            if (jstrt .lt. 0 .or. jend .lt. 0) then
              j = je - (jj-js)
            else
              j = jj
            endif
            write (stdout,8900) j, (iarray(l+i+is-1,j),i=1,incr)
          enddo
        enddo
      elseif (iform .eq. 2) then
c
c       use I2 format to print the integer array
c
        inc=60
        do l=0,il,inc
          incr = min(inc,il-l)
          write (stdout,9000) (l+i+is-1,i=1,incr,2)
          do jj=js,je
            if (jstrt .lt. 0 .or. jend .lt. 0) then
              j = je - (jj-js)
            else
              j = jj
            endif
            write (stdout,9200) j, (iarray(l+i+is-1,j),i=1,incr)
          enddo
        enddo
      elseif (iform .eq. 3) then
c
c       use I3 format to print the integer array
c
        inc=40
        do l=0,il,inc
          incr = min(inc,il-l)
          write (stdout,9400) (l+i+is-1,i=1,incr,2)
          do jj=js,je
            if (jstrt .lt. 0 .or. jend .lt. 0) then
              j = je - (jj-js)
            else
              j = jj
            endif
            write (stdout,9500) j, (iarray(l+i+is-1,j),i=1,incr)
          enddo
        enddo
      elseif (iform .eq. 4) then
c
c       use I4 format to print the integer array
c
        inc=30
        do l=0,il,inc
          incr = min(inc,il-l)
          write (stdout,9600) (l+i+is-1,i=1,incr,2)
          do jj=js,je
            if (jstrt .lt. 0 .or. jend .lt. 0) then
              j = je - (jj-js)
            else
              j = jj
            endif
            write (stdout,9700) j, (iarray(l+i+is-1,j),i=1,incr)
          enddo
        enddo
      endif
      return
8800  format (/, 2x, 30i4)
8900  format (1x,i3,1x, 120i1)
9000  format (/, 3x, 30i4)
9200  format (1x,i3,1x, 60i2)
9400  format (/,/,/,2x,20i6/)
9500  format (1x,i3,1x,40i3)
9600  format (/,/,/,1x,20i8/)
9700  format (1x,i3,1x,30i4)
      end


      subroutine matrix (array, irdim, istrt, im, jstrt, jm, scale)
c
c=======================================================================
c
c     matrix is a general two-dimensional array printing routine,
c     input:
c     array = the array to be printed
c     irdim = the 1st dimension of array
c     istrt = the 1st element of the 1st dimension to be printed
c     im    = the last element of the 1st dimension to be printed
c     jstrt = the 1st element of the 2nd dimension to be printed
c     jm    = the last element of the 2nd dimension to be printed
c             the 2nd dimension is printed in reverse order if both
c             jstrt & jm are negative
c     scale = a scaling factor by which array is divided before
c             printing.  (if this is zero, no scaling is done.)
c             if scale=0, 10 columns are printed across in e format
c             if scale>0, 20 columns are printed across in f format
c
c     output: print "array" as a matrix
c=======================================================================
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
      parameter (c0=0.0, c1=1.0)
      dimension array(irdim,1000)
c
      if (jstrt*jm .lt. 0) then
        write (stdout,999)  jstrt, jm
        stop '=>matrix'
      endif
c
c     allow for inversion of 2nd dimension
c
      if (jm .lt. 0) then
        js   = -jm
        je   = -jstrt
        jinc = -1
      else
        js   = jstrt
        je   = jm
        jinc = 1
      endif
c
      if (scale .eq. c0) then
c
        do is=istrt,im,10
          ie = min(is + 9,im)
          write (stdout,9001) (i, i=is,ie)
          do l=js,je,jinc
            write (stdout,9002) l, (array(i,l),i=is,ie)
          enddo
          write (stdout,'(/)')
        enddo
      else
        scaler = c1/scale
        do is=istrt,im,20
          ie = min(is + 19,im)
          write (stdout,9003) (i, i=is,ie)
          do l=js,je,jinc
            write (stdout,9004) l, (array(i,l)*scaler,i=is,ie)
          enddo
          write (stdout,'(/)')
        enddo
      endif
      return
999   format (1x,'jstrt=',i5,' jm=',i5,' in matrix')
9001  format(10i13)
9002  format(1x,i2,10(1pe13.5))
9003  format(3x,20i6)
9004  format(1x,i3,1x,20f6.2)
      end


      subroutine scope (array, im, il, jl, text)
c
c=======================================================================
c     scope interrogates "array" for the min, max (with respective
c            locations), and simple unweighted average
c
c     inputs:
c     array = the array to be interrogated
c     im    = the inner dimension of "array"
c     il    = the number of points along the inner dimension to consider
c     jl    = the number of points along the inner dimension to consider
c     text  = descriptive text (up to 15 chars) to be printed
c
c     output: prints min, max (with locations), and average of "array"
c
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c=======================================================================
c
      character*(*) text
      dimension array(im,jl)
      umax  = array(1,1)
      umin  = array(1,1)
      iumax = 1
      jumax = 1
      iumin = 1
      jumin = 1
      sum    = 0.0
      do j=1,jl
        do i=1,il
          sum = sum + array(i,j)
          if (array(i,j) .gt. umax) then
            umax = array(i,j)
            iumax = i
            jumax = j
          endif
          if (array(i,j) .lt. umin) then
            umin = array(i,j)
            iumin = i
            jumin = j
          endif
        enddo
      enddo
      avg = sum/(il*jl)
      write (*,9200) text, il, jl, iumin, jumin, umin, iumax, jumax
     &,              umax, avg
      return
9200  format (1x,'Scope: ',a15,': il=',i4,', jl=',i4
     &,', min(',i4,',',i4,')=',g10.3,', max(',i4,',',i4,')=',g10.3
     &,', avg=',g10.3/)
      end


      subroutine sum1st (a, imt, jmt, text)
c
c=======================================================================
c     inputs:
c     a     = the array to be interrogated
c     imt   = the 1st dimension of "a"
c     imt   = the 2nd dimension of "a"
c     text  = descriptive text to be printed
c
c     output: sums the first index of array "a" for each 2nd index
c
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c=======================================================================
c
      character*(*) text
      dimension a(imt,jmt)
      print *,' '
      print *,text
      big = abs(a(1,1))
      imax = 0
      jmax = 0
      do j=1,jmt
        sum = 0.0
	do i=1,imt
	  sum = sum + a(i,j)
          if (abs(a(i,j)) .gt. big) then
	    big = abs(a(i,j))
	    imax = i
	    jmax = j
          endif
	enddo
	if (sum .ne. 0.0) then
	  write (*,'(a,i4,a,e14.7)')
     &    '2nd index=',j,'. sum over 1st index =',sum
	endif
      enddo
      if (imax .ne. 0 .and. jmax .ne. 0) then
        write (*,*) ' biggest=',a(imax,jmax),' at i=',imax,' j=',jmax
      else
        write (*,*) ' ---field is a constant =', a(1,1)
      endif
      return
      end


      subroutine plot (array, im, istrt, iend, jstrt,  jend 
     &,                  zmin, zmax, nbin, title)
c
c=======================================================================
c     "plot" contours "array" by dividing the array values into bins, 
c     assigning a character to each bin, and printing the characters to
c     produce a contour map.
c     The inner (1st) dimension is plotted horizontally (x-axis) and the
c     outer (2nd) dimension is plotted vertically (y-axis) and can be
c     inverted.
c
c     inputs:
c     array = the array to be contoured
c     im    = the inner dimension of "array"
c     istrt = starting index along 1st dimension for plot
c     iend  = ending index along 1st dimension for plot
c     jstrt = starting index along 2nd dimension for plot
c     jend  = ending index along 2nd dimension for plot
c             note: if jstrt and jend are negative then the vertical
c                   y-axis is inverted.
c     zmin  = the minimum value to plot
c     zmax  = the maximum value to plot
c             note: if zmin=zmax then then min and max of "array"
c                   is used.
c     nbin  = the number of bins between zmin and zmax
c     title = descriptive text string
c
c     output: contours "array"
c
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c=======================================================================
c
      parameter (maxbin=52, ncols=124)
      character*(*) title
      dimension array(im,1000), bin(maxbin,3)
      character*(maxbin) c, cc
      character*1 line(ncols)
      data c/'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'/
      save c
c
c     choose the plotting domain
c
      js = min(abs(jstrt),abs(jend))
      je = max(abs(jstrt),abs(jend))
      is = min(abs(istrt),abs(iend))
      ie = max(abs(istrt),abs(iend))
      il = ie-is+1
c
c     set the max and min
c
      if (zmax .eq. zmin) then
        big = array(is,js)
        sml = array(is,js)
        do j=js,je
          do i=is,ie
            if (array(i,j) .gt. big) big = array(i,j)
            if (array(i,j) .lt. sml) sml = array(i,j)
          enddo
	enddo
      else
        big = max(zmin,zmax)
        sml = min(zmin,zmax)
      endif
c
c     set up the discretization into bins
c
      write (*,*) ' '
      write (*,*) ' => contour bins for: ', title
      delta = (big-sml)/max(1,abs(nbin))
      limit = min(maxbin,max(1,abs(nbin)))
      do n=1,limit
        bin(n,1) = sml + (n-1)*delta
        bin(n,2) = sml + n*delta
        bin(n,3) = 0.5*(bin(n,1)+bin(n,2))
        cc(n:n)  = c(n:n)
        if (n .eq. 1) cc(n:n) = '-'
        if (n .ge. max(1,abs(nbin)) .or. n .eq. maxbin) cc(n:n) = '+'
        if (bin(n,1) .le. 0.0 .and. bin(n,2) .gt. 0.0) cc(n:n) = '.'
        if (n .lt. limit) then
          write (*,'(1x,a,a,g10.3,a,g10.3,a,g10.3,a)')  cc(n:n)
     &,   ' = ', bin(n,3) 
     &,   ', (', bin(n,1),' <= x < ', bin(n,2),')'
        else
          write (*,'(1x,a,a,g10.3,a,g10.3,a,g10.3,a)') cc(n:n)
     &,   ' = ', bin(n,3) 
     &,   ', (', bin(n,1),' <= x <=', bin(n,2),')'
	endif
      enddo
      if (abs(nbin) .gt. maxbin) then
        write (*,*)
     &    ' => Note: numbers larger than this are also plotted as +'
      endif
c
c     plot the character representation of the bins
c
      write (*,*) ' '
      do l=0,il,ncols
        incr = min(ncols,il-l)
        write (*,8800) (l+i+is-1,i=1,incr,4)
        do jj=js,je
          if (jstrt .lt. 0 .or. jend .lt. 0) then
            j = jj
          else
            j = je - (jj-js)
          endif
          do i=1,incr
            k = min(ifix((array(l+i+is-1,j) - sml)/delta) + 1, limit)
            line(i) = cc(k:k)
          enddo
          write (*,8900) j, (line(i),i=1,incr)
        enddo
      enddo
      return
8800  format (/, 2x, 31i4)
8900  format (1x,i3,1x, 124a1)
      end


      subroutine print_checksum (a, im, jm, text)
      dimension a(im,jm)
      character*(*) text
      sum = checksum (a, im, jm)
      print *, text, sum
      return
      end

      function checksum (a, im, jm)
      dimension a(im,jm)
      sum = 0.0
      do j=1,jm
        do i=1,im
	  sum = sum + abs(a(i,j))
	enddo
      enddo
      checksum = sum
      return
      end


      subroutine wrufio (iounit, array, len)
c
c=======================================================================
c     write unformatted fortran i/o
c
c     input:
c
c     iounit = fortran unit number
c     array  = array to be written to "iounit"
c     len    = length of array
c
c     output: writes to unit "iounit"
c=======================================================================
c
      dimension array(len)
      write (iounit) array
      return
      end


      subroutine rdufio (iounit, array, len)
c
c=======================================================================
c     read unformatted fortran i/o
c
c     input:
c
c     iounit = fortran unit number
c     array  = array to be read from "iounit"
c     len    = length of array
c
c     output: none
c=======================================================================
c
      dimension array(len)
      read (iounit) array
      return
      end

      subroutine tranlon (c, ic, il, jl, t, cx, fx, ifl, tx)
c
c-----------------------------------------------------------------------
c     grid interpolators in MOM require the grid coordinates to be
c     monotonic. when the prime meridian lies within the model grid,
c     global datasets (e.g. Scripps topography) must be translated in
c     longitude to remove the jump in
c     longitudes (358.5 359.5, 0.5, 1.5) across the meridian before
c     interpolating to the model grid. This is only of concern in
c     limited domain grids (e.g. atlantic basin) that contain the 
c     prime meridian.
c     
c     translate longitudes  "cx" to "tx" so that tx(i) i=1..ic
c     completely encloses model longitudes  fx(i) i=1..ifl
c     note that "tx" may extend beyond 360 degrees to contain "fx".
c     use same mapping to translate data in "c"
c
c     input:
c     c  = original data array
c     t  = temp array for translating data
c     cx = original data longitudes
c     tx = translated data longitudes
c     fx = model longitudes
c
c     output
c     c  = translated data array
c-----------------------------------------------------------------------
c
      dimension c(ic,jl), t(ic), tx(ic), cx(ic), fx(ifl)
c
c-----------------------------------------------------------------------
c     find the index of the 1st model grid point on the data grid
c-----------------------------------------------------------------------
c
      iw = indp (fx(1), cx, ic)
      if (cx(iw) .gt. fx(1)) iw = max(1,iw-1)
c
c-----------------------------------------------------------------------
c     translate data longitudes so that tx(1) = cx(iw), tx(2) = cx(iw+1)
c-----------------------------------------------------------------------
c
      do i=1,ic
        tx(i) = cx(mod(i+iw-2,il) + 1)
        im1   = max(1,i-1)
        if (tx(i) .lt. tx(im1)) tx(i) = tx(i) + 360.0
      enddo
      if (fx(ifl) .gt. tx(ic)) then
        write (6,997) iw, ic, ifl
        write (6,998) 'tx= ',(tx(i),i=1,ic)
        write (6,998) 'fx= ',(fx(i),i=1,ifl)
        stop
      endif
c
c-----------------------------------------------------------------------
c     translate data to match translated longitudes
c-----------------------------------------------------------------------
c
      do j=1,jl
        do i=1,ic
          t(i) = c(mod(i+iw-2,il) + 1,j)
        enddo
        do i=1,ic
          c(i,j) = t(i)
        enddo
      enddo
c
      return
997   format (1x, ' ===>  tx(ic) < fx(ifl) in tranlon. iw=',i6,
     1         ' il=',i6,' ifl=',i6)
998   format (1x,a4,(5x,10e11.4))
      end




c martin
c     function LEN_TRIM (string)
c
c     defines length of "string" ignoring trailing blanks
c
c     character * (*) string
c     integer LEN_TRIM, i
c
c     LEN_TRIM = 0
c     do i = LEN (string), 1, -1
c       if (string(i:i) .NE. ' ') then
c         LEN_TRIM = i
c         goto 999
c       end if
c     end do
c999   continue
c      
c     return
c     end


      subroutine windstress
c
c=======================================================================
c     calculate the geostrophic wind stress and wind speed or anomalies
c     based on code by a.fanning
c
c     author:   m.eby   e-mail: eby@uvic.ca
c=======================================================================
c





c
      return
      end

      subroutine windsp
c
c=======================================================================
c     convert wind stress tx & ty to wind speed for use in calculating
c     heat flux from atmosphere
c     based on code by a.fanning
c
c     author:   m.eby   e-mail: eby@uvic.ca
c=======================================================================
c

c====================== include file "param.h" =========================
c
c     main parameter file which sets ocean characteristics:
c
c     "size.h" sets model size "imt", "jmt", and "km"
c
c====================== include file "size.h" ==========================
c                                                                       
c-----------------------------------------------------------------------
c     USER INPUT: 
c-----------------------------------------------------------------------
c
c     imt    = number of grid points in the longitudinal direction
c              (calculated points are from 2 through imt-1. End points
c               are boundaries)          
c
c     jmt    = number of grid points (latitude rows) in the latitudinal
c              direction (calculated points are from 2 through jmt-1.           
c              End points are boundaries)   
c                                
c     km     = number of grid points in the vertical direction          
c              (calculated points are from 1 through km)
c
c     nt     = number of tracers (temperature, salinity, ...)
c
c     mnisle = maximum number of islands (unconnected land masses)
c
c     maxipp = maximum number of all island perimeter points
c-----------------------------------------------------------------------
c                                                                       
      parameter (imt=  92, jmt=  61, km= 15)
      parameter (nt=2)
      parameter (nat=2)
      parameter (mnisle=50, maxipp=5000)
c

c






c
c-----------------------------------------------------------------------
c     END USER INPUT
c-----------------------------------------------------------------------
c                                                                       
c-----------------------------------------------------------------------
c     By default, the MW (memory window) is 2nd order except for the
c     following options which require a 4th order MW 
c
c     for 2nd order schemes, the minimum sized MW is 3 latitude rows
c     for 4th order schemes, the minimum sized MW is 4 latitude rows
c                            (5 if using coarse_grained_parallelism)
c-----------------------------------------------------------------------
c













c
c-----------------------------------------------------------------------
c     set MW (memory window) size "jmw" 
c-----------------------------------------------------------------------
c                                                                       

c
c     for UNI-TASKING: "jmw" is set to the minimum for each option class 
c     "jmw" may be increased up to "jmt" 
c

      parameter (jmw=jmt)


c
c-----------------------------------------------------------------------
c     set first and last calculated row within the MW. other rows
c     are used as buffers
c-----------------------------------------------------------------------
c
c     jsmw   = 1st calculated row within the MW     
c     jemw   = last calculated row within the MW
c
      parameter (jsmw=2, jemw=jmw-1)
c
c
c     jextra = extra buffer rows needed for coarse_grained_parallelism.
c              "jextra" rows are added to the top and bottom of the MW
c              so the MW size increases by 2*jextra       
c

          parameter (jextra = 0)




c
c     nvar   = number of prognostic variables
c     lseg   = maximum number of longitudinal stream function segments
c     nlatpr = maximum number of latitudes for matrix printouts
c              on diagnostic time steps
c     nhreg  = number of regions in the horizontal used for averaging
c              tracers.
c     nvreg  = number of regions in the vertical used for term balance
c              calculations. note "nvreg" isn`t used for tracer averages
c     numreg = total number of regions ( = product of nhreg & nvreg)
c              used for term balance calculations
c
      parameter (lseg=5, nlatpr=10)

      parameter (nhreg=5, nvreg=2, numreg=nhreg*nvreg)

      parameter (nvar=nt+2)
c

c
      parameter (imtm1=imt-1, kmm1=km-1)                                
      parameter (imtp1=imt+1, imtm2=imt-2
     &,          jmtp1=jmt+1, jmtm1=jmt-1, jmtm2=jmt-2

     &,          jscan=jmtm2

     &,          kmp1=km+1, kmp2=km+2
     &,          imtkm=imt*km, nwds=imt*jmt, nkflds=2
     &,          nslab=imt*nvar*km, ntmin2=nt+1/nt)
c
c     include parameter constants
c
c====================== include file "pconst.h" ========================
c
c
c     rules for parameter constants
c
c     use prefix of "c" for whole real numbers (eg: c57 for 57.0)
c     use "m" after prefix to designate negative values (minus sign)
c       (eg: cm7 for -7.0)
c     use prefix of "p" for non repeating fractions (eg: p5 for 0.5)
c     use prefix of "r" for reciprocals (eg: r3 for 1/3.0)
c     combine use of prefix above and "e" for scientific notation, with
c       (eg: c5e4 for 5.0e4, c1em10 for 1.0e-10)
c
      parameter (c0=0.0, c1=1.0, c2=2.0, c3=3.0, c4=4.0, c5=5.0, c7=7.0)
      parameter (c8=8.0)
      parameter (c14=14.0, c16=16.0, c360=360.0)
      parameter (p125=0.125, p25=0.25, p5=0.5, p75=0.75)
      parameter (epsln=1.0e-20)
c
      parameter (c24=24.0, c60=60.0, c1440=1440.0)
      parameter (r24=c1/c24, r60=c1/c60, r1440=c1/c1440)
      parameter (secday=c1/(c60*c1440))
c
c     include standard I/O units
c
c====================== include file "stdunits.h" ======================
c
c     stdin  = unit number for standard input.
c     stdout = unit number for standard output.
c     stderr = unit number for standard error.
c
      integer stdin, stdout, stderr
      parameter (stdin = 5, stdout = 6, stderr = 6)
c
c
c
c     ncrows = number of calculated rows within the MW.
c              (the remaining rows are buffer rows). 
c


      parameter (ncrows = jmw - 2)


c====================== include file "atm.h" ===========================
c
c     arrays for the energy-moisture balance model
c
c     note: units for heat flux are in g/cm**2/s**3/cm**2 or (mW/m**2)
c           units for fresh water flux are in cm/s
c           downward is into the surface (ocean, ice or land)
c           upward is into the bottom of the atmosphere
c           outward is out of the top of the atmosphere
c           inward is into the top of the atmosphere
c
c     outlwr(imt,jmt)	 = outgoing atmosphere longwave flux
c     at(imt,jmt,2,nat)	 = tracers (previous and most recent)
c     surf(imt,jmt,nat)	 = surface values (1=temperature, 2=humidity)
c     flux(imt,jmt,nat)	 = downward flux (1=heat, 2=fresh water)
c     precip(imt,jmt)	 = precipitation
c     evap(imt,jmt)	 = evaporation
c     dnswr(imt,jmt)  	 = downward surface shortwave flux
c     uplwr(imt,jmt)  	 = upward surface longwave flux
c     upsens(imt,jmt)	 = upward surface sensible heat flux
c     upltnt(imt,jmt)    = upward surface latent heat flux
c     ssh(imt,jmt) 	 = saturation specific humidity
c     spd(imt,jmt) 	 = wind speed (cm/sec)
c     da(jmt,nat)	 = tracer diffusivity parameterization
c     coalbedo(jmt)	 = planetary coalbedo
c     solins(jmt)	 = solar insolation (units of solarconst)
c     esatm(jmt)	 = atmosphere emissivity times Stefan's constant
c     scatter(jmt)	 = solar scattering into atmosphere





c     cori(jmt,2)	 = Coriolis parameter

c
      real outlwr(imt,jmt), at(imt,jmt,3,nat), surf(imt,jmt,nat)
      real flux(imt,jmt,nat), precip(imt,jmt), evap(imt,jmt)
      real dnswr(imt,jmt), uplwr(imt,jmt), upsens(imt,jmt)
      real upltnt(imt,jmt), ssh(imt,jmt), spd(imt,jmt), da(jmt,nat)
      real coalbedo(jmt), solins(jmt), esatm(jmt), scatter(jmt)





      real cori(jmt,2)
c
      common /atm/ outlwr, at, surf, flux, precip, evap, dnswr, uplwr
     &,            upsens, upltnt, spd, ssh, da, coalbedo, solins
     &,            esatm, scatter





     &,            cori
c
c====================== include file "cembm.h" =========================
c
c     parameters for use in the energy balance model (also see atm.h)
c
c     addflux		= logical flag for adding only even mode fluxes
c     nats		= number of atmospheric time steps since mixing
c     namix		= time steps between mixing (set in atmos.in)
c     lf		= time step flag (1=>leapfrog, 2=>forward)
c     pyear		= calendar year (set in atmos.in, -/+ = BC/AD)
c     dtatm 		= time step for atmosphere (set in atmos.in)
c     dts		= time step (2*dtatm=>leapfrog, dtatm=>forward)
c     co2ccn		= CO2 concentration
c     anthro		= radiative forcing by CO2
c     co2ccni		= initial CO2 concentration
c     co2yri		= last year of initial CO2 concentration
c     co2ccnf		= final CO2 concentration
c     co2yrf		= first year of final CO2 concentration
c     solarconst	= solar constant (g/s**3)
c     ssp		= sea surface pressure (g/cm/s**2)
c     cdatm 		= drag coefficient (dimensionless)
c     cpatm		= atmospheric heat capacity (cm**2/s**2/K)
c     ht		= scale height for temperature
c     hq		= scale height for specific humidity
c     rhoatm		= density of air at sea surface (g/cm**3)
c     rhoocn		= representative sea surface density
c     esocn		= ocean emissivity times Stefan's constant 
c     vlocn		= latent heat of vaporization of water
c     socn		= constant ocean salinity
c     cdice 		= drag coefficient (dimensionless)
c     rhoice		= ice density (g/cm**3)
c     esice		= ice emissivity times Stefan's constant 
c     slice		= latent heat of sublimation of ice
c     flice		= latent heat of fusion of ice (cm**2/s**2)
c     condice		= ice conductivity (g*cm/s**3/K)
c     kadv		= time step divider for ice advection
c     ntats		= time step counter for time averaging
c     avetime		= time for averaging fluxes
c     totaltime		= total time for long term averages
c
      logical addflux
c
      common /cembm/ addflux
      common /cembm/ nats, namix, lf, kadv, ntats
      common /cembm/ pyear, dtatm, dts, co2ccn, anthro, co2ccni, co2yri
     &,              co2ccnf, co2yrf, solarconst, ssp, cdatm, cpatm, ht
     &,              hq, rhoatm, rhoocn, esocn, vlocn, socn, cdice
     &,              rhoice, esice, slice, flice, condice, avetime 
     &,              totaltime
c
c====================== include file "csbc.h" ==========================
c
c                    surface boundary conditions (S.B.C.)
c
c
c     numosbc = number of ocean S.B.C..
c
c     numasbc = number of atmospheric S.B.C..
c
c     maxsbc  = maximum number of allowable S.B.C. fields.
c
c     numsbc  = total number of S.B.C. this is the sum of the 
c               atmosphere S.B.C. and ocean S.B.C. fields. it must
c               be less than or equal to "maxsbc".
c
c     sbcocn  = S.B.C. fields on the ocean grid.
c               n=1..numosbc are for the incoming ocean S.B.C.
c               n=numosbc+1..numosbc+numasbc are for the outgoing S.B.C.
c

c
c     ntspos  = number of time steps per ocean segment
c
c     sbcname  = S.B.C. character string names (eg: "SST", "taux", etc)
c               note that these character strings should be changed with
c               care since they are used to identify fields for special
c               treatment
c
c     dunits  = dimensional units for S.B.C. (eg: "deg C")
c
c     mapsbc  = indices for relating how S.B.C. fields are stored
c               within arrays "sbcocn" and "sbcatm"  
c               eg: m = mapsbc(n) where sbcocn(,,m) is S.B.C. "n"
c
c     restrictions on re-arranging S.B.C. fields and "mapsbc":
c
c     1) all ocean S.B.C. (taux, tauy, etc) should be grouped together. 
c        relative ordering within the group is unimportant but the
c        group must preceed the atmos S.B.C. group.
c
c     2) all atmos S.B.C. (sst, ...) should also be grouped together.
c        relative ordering within the group is unimportant.
c
c     the default arrangement is defined as:
c
c             (these five ocean S.B.C. come from the atmos )
c     mapsbc(1) references taux
c     mapsbc(2) references tauy
c     mapsbc(3) references heat flux
c     mapsbc(4) references salt flux
c      if the atmos supplied fresh water flux then it
c      would have to be converted to ...
c      salt flux  = -(P-E+R) * rho * Sref
c      where...
c      P-E+R represents a precipitation minus evaporation
c            plus runoff rate in cm of water/sec
c      rho is the density if water taken to be 1 g/cm**3, and
c      Sref is a reference salinity in units of grams of salt per
c            gram of water (in units of "parts per part" such
c            as 0.035 ... not "parts per thousand")
c      Depending upon the application of interest, users may wish
c      to set Sref to either be a constant over the entire model
c      domain or for it to be the locally predicted salinity of
c      the uppermost model level (S(1)).  If one desires to ensure
c      that a global average P-E+R flux of zero translates to zero
c      trend in the salt content of the ocean, then a constant Sref
c      is needed.      
c     mapsbc(5) references short wave
c
c             (these four atmos S.B.C. come from the ocean)
c     mapsbc(6) references SST
c     mapsbc(7) references SSS
c     mapsbc(8) references surface u
c     mapsbc(9) references surface v
c
c
c     when re-ordering S.B.C., search for "mapsbc"  
c     (eg: grep mapsbc *.F) to insure the new indexing is consistant
c     with the re-ordering. also make changes in "sbcname", "dunits", 
c     "coabc", and "crits" to maintain consistancy.
c
c     example 1: suppose you want only the first six S.B.C...
c                in "csbc.h", set  numosbc=5, numasbc=1
c                this reduces memory requirements.
c                no other changes are necessary
c
c     example 2: suppose you want to remove the short wave boundary
c                condition (to save more memory) from example 1 . 
c                a) in "csbc.h", set numosbc=4, numasbc=1
c                b) grep "mapsbc(5)" *.F to find and remove references
c                c) grep "mapsbc(6)" *.F to change references to 
c                                        mapsbc(5)
c
c     
c     author:      r. c. pacanowski      e-mail=> rcp@gfdl.gov
c
c
      logical asegs, asege, afirst, alast
      character*10 sbcname
      character*15 dunits
c
      parameter (numosbc=5
     &,          numasbc=4
     &,          maxsbc=numosbc+numasbc, numsbc=maxsbc)
c
      common /csbc/ sbcocn(imt,jmt,numsbc) 
      common /csbc/ dampts(nt), dampdz(nt)
      common /csbc/ coabc(maxsbc), crits(maxsbc)
      common /csbc1/ mapsbc(maxsbc), numpas, iombc, ntspos, ntspas
      common /csbc2/ sbcname(maxsbc), dunits(maxsbc)
      common /csbc3/ asegs, asege, afirst, alast 
c
c====================== include file "mapsbc.h" ========================
c
c     indicies for surface boundary condition arrays.  names must be
c     unique and are set at the begining of "driver"
c
c     itaux is the x component of wind stress
c     itauy is the y component of wind stress
c     ihflx is heat flux
c     ipme is for precipitation minus evaporation
c     ipsw is for penitrating shortwave (into ocean first layer)
c     isst is the ocean model SST
c     isss is the ocean model SSS
c     isu is the x component of the ocean model first layer velocity
c     isv is the y component of the ocean model first layer velocity
c     it10 is the 10 metre atmopheric temperature
c     iq10 is the 10 metre atmopheric humidity
c     ilwr is incoming longwave radiation
c     iswr is incoming shortwave radiation
c     igu is the x component of the ocean model second layer velocity
c     igv is the y component of the ocean model second layer velocity
c
      common /mapsbc/ itaux, itauy, ihflx, ipme, ipsw, isst, isss
     &,               isu, isv, it10, iq10, ilwr, iswr, igu, igv
c
c
c     calculate wind speed from stress
c
      drag = cdatm*rhoatm
      do j=1,jmt
        do i=1,imt
          tau = sqrt(sbcocn(i,j,itaux)**2 + sbcocn(i,j,itauy)**2)
          spd(i,j) = sqrt(tau/drag)
        enddo
      enddo
c
c     do a four point average to get to t from u,v points
c
      do j=jmtm1,2,-1
        do i=imtm1,2,-1
          spd(i,j) = 0.25*(spd(i,j) + spd(i-1,j) + spd(i-1,j-1)
     &             + spd(i,j-1))
        enddo
      enddo
c
      call embmbc (spd)

c
      return
      end

